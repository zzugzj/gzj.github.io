<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="gzj"><meta name="copyright" content="gzj"><meta name="generator" content="Hexo 5.3.0"><meta name="theme" content="hexo-theme-yun"><title>InnoDB的锁和事务模型 | gzj-blogs</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.22/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_ed8vp4atwoj.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link class="aplayer-style-marker" rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script class="aplayer-script-marker" src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" defer></script><script class="meting-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js" defer></script><script src="/jsax.js" defer></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/themes/prism.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/themes/prism-tomorrow.css" media="(prefers-color-scheme: dark)"><link rel="shortcut icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><link rel="alternate" href="/atom.xml" title="gzj-blogs" type="application/atom+xml"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"zzugzj.github.io","root":"/","title":"勿在浮沙筑高台","version":"1.3.0","mode":"auto","copycode":true,"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"local_search":{"path":"/search.xml"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><meta name="description" content="InnoDB与MyISAM的最大不同有两点:一是支持事务(TRANSACTION);二是采用了行级锁。关于事务我们之前有专题介绍,这里就着重介绍下它的锁机制。 总的来说,InnoDB按照不同的分类...">
<meta property="og:type" content="article">
<meta property="og:title" content="InnoDB的锁和事务模型">
<meta property="og:url" content="https://zzugzj.github.io/posts/5c27e2b9/index.html">
<meta property="og:site_name" content="gzj-blogs">
<meta property="og:description" content="InnoDB与MyISAM的最大不同有两点:一是支持事务(TRANSACTION);二是采用了行级锁。关于事务我们之前有专题介绍,这里就着重介绍下它的锁机制。 总的来说,InnoDB按照不同的分类...">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-04-13T01:37:59.592Z">
<meta property="article:modified_time" content="2021-04-13T12:34:14.301Z">
<meta property="article:author" content="gzj">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="gzj"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="gzj"><span class="site-author-status" title="不想上班">😭</span></a><div class="site-author-name"><a href="/about/">gzj</a></div><a class="site-name" href="/about/site.html">gzj-blogs</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">30</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">8</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">12</span></a></div><a class="site-state-item hty-icon-button" href="/about" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/zzugzj" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=1317412612" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:1045643052@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E7%9A%84%E9%94%81"><span class="toc-number">1.</span> <span class="toc-text">InnoDB的锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81"><span class="toc-number">1.1.</span> <span class="toc-text">共享锁和排他锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">1.2.</span> <span class="toc-text">意向锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E9%94%81-Record-Locks"><span class="toc-number">1.3.</span> <span class="toc-text">记录锁(Record Locks)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81-Gap-Locks"><span class="toc-number">1.4.</span> <span class="toc-text">间隙锁(Gap Locks)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Next-Key-Locks"><span class="toc-number">1.5.</span> <span class="toc-text">Next-Key Locks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">1.6.</span> <span class="toc-text">插入意向锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AUTO-INC%E9%94%81%EF%BC%88%E8%87%AA%E5%A2%9E%E9%94%81%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">AUTO-INC锁（自增锁）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#autocommit-Commit-and-Rollback"><span class="toc-number">2.</span> <span class="toc-text">autocommit, Commit, and Rollback</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E4%B8%AD%E7%94%B1%E4%B8%8D%E5%90%8C%E7%9A%84SQL%E8%AF%AD%E5%8F%A5%E8%AE%BE%E7%BD%AE%E7%9A%84%E9%94%81"><span class="toc-number">3.</span> <span class="toc-text">InnoDB中由不同的SQL语句设置的锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">4.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%AD%BB%E9%94%81%E4%BE%8B%E5%AD%90"><span class="toc-number">4.1.</span> <span class="toc-text">一个死锁例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-number">4.2.</span> <span class="toc-text">死锁检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E7%94%A8%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-number">4.2.1.</span> <span class="toc-text">禁用死锁检测</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%92%8C%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81"><span class="toc-number">4.3.</span> <span class="toc-text">如何减少和处理死锁</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://zzugzj.github.io/posts/5c27e2b9/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="gzj"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="gzj-blogs"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">InnoDB的锁和事务模型</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <span class="post-meta-icon-text">发表于</span> <time title="创建时间：2021-04-13 09:37:59" itemprop="dateCreated datePublished" datetime="2021-04-13T09:37:59+08:00">2021-04-13</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="本文字数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="本文字数">4.7k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读时长"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="阅读时长">17m</span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">数据库</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/tags/MySQL/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">MySQL</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h2 id="InnoDB的锁"><a href="#InnoDB的锁" class="headerlink" title="InnoDB的锁"></a>InnoDB的锁</h2><h3 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h3><p>InnoDB通过共享锁和排他锁实现了行级锁。</p>
<ul>
<li>共享(s)锁允许持有锁的事务读取一行。</li>
<li>排他(x)锁允许持有锁的事务更新或删除一行。</li>
</ul>
<p>事务T1在row行上拥有s锁，那事务T2申请row行上的s锁可立即获得，T1，2会同时拥有s锁。申请x锁需要等待T1释放锁。</p>
<p>事务T1在row行上拥有x锁，那事务T2申请row行的s或x锁必须等待T1释放锁。</p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>InnoDB存储引擎支持多粒度的锁：即可以同时支持行锁和表锁。为了支持这个机制，有了意图锁。</p>
<p>意向锁是表级锁，目的是表明事务稍后需要对表中的行使用那种类型的锁(s或x)。</p>
<p>存在两种类型的意向锁：</p>
<ul>
<li>意向共享(IS)锁：事务打算在一张表的个别行申请共享锁(select … lock in share mode)。</li>
<li>意向排他(IX)锁：事务打算再一张表的个别行申请排他锁(select … for update)。</li>
</ul>
<p>意向锁需要遵循一下协定：</p>
<ul>
<li>事务打算在一张表的个别行申请一个s锁前，必须先申请表的IS或IX锁。</li>
<li>事务打算在一张表的个别行申请一个x锁前，必须先申请表的IX锁。</li>
</ul>
<p>表的锁类型兼容性：</p>
<table>
<thead>
<tr>
<th></th>
<th>X</th>
<th>IX</th>
<th>S</th>
<th>IS</th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td>互斥</td>
<td>互斥</td>
<td>互斥</td>
<td>互斥</td>
</tr>
<tr>
<td>IX</td>
<td>互斥</td>
<td>兼容</td>
<td>互斥</td>
<td>兼容</td>
</tr>
<tr>
<td>S</td>
<td>互斥</td>
<td>互斥</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IS</td>
<td>互斥</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p>（意图锁之间互相兼容，其余遵循X,S互斥原则）</p>
<p>如果事务请求的锁与现有锁兼容，则将其授予请求的事务。 事务会等待直到现有的锁被释放。 如果锁请求与现有锁发生冲突，并且由于可能导致死锁而无法被授予许可，则会发生错误。</p>
<p>意向锁不会阻塞除表级锁(比如：lock tables … write)外的任何锁，意图锁的主要目的是表明有人正在锁表中的行，或者将要锁表中的行。</p>
<h3 id="记录锁-Record-Locks"><a href="#记录锁-Record-Locks" class="headerlink" title="记录锁(Record Locks)"></a>记录锁(Record Locks)</h3><p>记录锁是索引记录上的锁。比如：SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;就是给c1=10的行上加排他锁，防止别的事务的insert、update、delete这个c1=10的行。即使这个表没有定义索引，InnoDB也会隐式的创建一个聚集索引来加记录锁。</p>
<p>记录锁的事务在SHOW ENGINE INNODB STATUS和InnoDB监视器输出中看起来类似于以下内容：</p>
<pre class="language-mysql" data-language="mysql"><code class="language-mysql">RECORD LOCKS space id 58 page no 3 n bits 72 index &#96;PRIMARY&#96; of table &#96;test&#96;.&#96;t&#96;
trx id 10078 lock_mode X locks rec but not gap
Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 8000000a; asc     ;;
 1: len 6; hex 00000000274f; asc     &#39;O;;
 2: len 7; hex b60000019d0110; asc        ;;</code></pre>
<h3 id="间隙锁-Gap-Locks"><a href="#间隙锁-Gap-Locks" class="headerlink" title="间隙锁(Gap Locks)"></a>间隙锁(Gap Locks)</h3><p>间隙锁是对索引记录间的间隙的锁定。比如：SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;给10-20上排他间隙锁，防止其他事务插入10-20间的值。</p>
<p>间隙锁在部分隔离级别下使用。</p>
<p>对于使用唯一索引来查询行的语句，不需要间隙锁(如果是多列的索引，需要where条件全部命中，才不会加间隙锁，只会加记录锁)。例如，<code>SELECT * FROM child WHERE id = 100;</code>只有记录锁，没有间隙锁。如果id没有索引或者不是唯一索引，则该语句会锁住前面的间隙。</p>
<p>注意：不同的事务可以在一个间隙上拥有不同的间隙锁。例如：事务A在一个间隙上拥有共享间隙锁，同时事务B在同一间隙上可以拥有排他间隙锁（无论是间隙S锁还是间隙X锁）。这个机制被允许存在是因为，一个记录被删除时，会合并不同事务在这个记录上的间隙锁。</p>
<p>InnoDB中的间隙锁“纯粹是抑制性的”，这意味着它们的唯一目的是防止其他事务更改间隙间的内容。 间隙锁可以共存。一个事务进行的间隙锁不会阻止另一事务对相同的间隙获取间隙锁。 共享间隙锁和排他间隙锁之间没有区别。 它们彼此不冲突，并且执行相同的功能。</p>
<p>间隙锁可以在READ COMMITTED隔离级别下显式禁用。在这种情况下，将禁用间隙锁进行搜索和索引扫描，并且仅将其用于外键约束检查和重复键检查。</p>
<p>在READ COMMITTED隔离级别上还有其他效果。 MySQL评估WHERE条件后，将释放不匹配行的记录锁。 对于UPDATE语句，InnoDB进行“半一致”读取，将最新的提交版本返回给MySQL，以便MySQL可以确定该行是否与UPDATE的WHERE条件匹配。</p>
<h3 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h3><p>Next-Key Locks是索引记录上的记录锁和索引记录之前的间隙上的间隙锁的组合。</p>
<p>InnoDB执行行级锁的方式是：当它搜索或扫描表索引时，会在遇到的索引记录上设置共享或排他锁。 因此，行级锁实际上是索引记录锁。 索引记录上的Next-Key Locks也会影响该索引记录之前的“间隙”。 所以，Next-Key Locks是索引记录锁加上索引记录之前的间隙上的间隙锁。</p>
<p>如果一个会话在索引中的记录R上具有共享或排他锁，则另一会话不能按照索引顺序在R之前的间隙中插入新的索引记录。</p>
<p>假设一个索引包含10，11，13和20，该索引可能的Next-Key Locks覆盖以下间隔：</p>
<pre class="language-mysql" data-language="mysql"><code class="language-mysql">(负无穷, 10]
(10, 11]
(11, 13]
(13, 20]
(20, 正无穷)</code></pre>
<p>最后一个间隔，next-key lock锁定最大索引值之后的间隙。</p>
<p>默认情况下，InnoDB在REPEATABLE READ隔离级别中运行。 在这种情况下，InnoDB使用next-key锁进行搜索和索引扫描，这可以防止幻读。</p>
<h3 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h3><p>插入意向锁是一种在行插入之前通过INSERT操作设置的间隙锁。</p>
<p>如果多个事务插入共同的索引间隙的不同位置，那无需等待。假设有索引记录，其值分别为4和7。单独的事务分别尝试插入值5和6，在获得插入行的排他锁之前，每个事务都使用插入意图锁来锁定4和7之间的间隙， 但不互相阻塞，因为行是无冲突的。</p>
<p>举例：客户端A创建一张表有2个索引数据（90和102），开始一个事务，放置一个排他索引记录锁在ID&gt;100的数据，排他锁也包括一个102数据之前的间隙锁。</p>
<pre class="language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; CREATE TABLE child (id int(11) NOT NULL, PRIMARY KEY(id)) ENGINE&#x3D;InnoDB;
mysql&gt; INSERT INTO child (id) values (90),(102);

mysql&gt; START TRANSACTION;
mysql&gt; SELECT * FROM child WHERE id &gt; 100 FOR UPDATE;
+-----+
| id  |
+-----+
| 102 |
+-----+</code></pre>
<p>客户端B开始一个事务插入一条记录到间隙中，这个事务在等待排他锁的时候持有一个插入意图锁</p>
<pre class="language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; START TRANSACTION;
mysql&gt; INSERT INTO child (id) VALUES (101);</code></pre>
<h3 id="AUTO-INC锁（自增锁）"><a href="#AUTO-INC锁（自增锁）" class="headerlink" title="AUTO-INC锁（自增锁）"></a>AUTO-INC锁（自增锁）</h3><p>AUTO-INC锁是一种特殊的表级锁，当事务插入表并有自增列的时候持有。 在最简单的情况下，如果一个事务正在向表中插入值，其他事务都必须等待自己的插入，以便第一个事务插入的行接收连续的主键值。</p>
<h2 id="autocommit-Commit-and-Rollback"><a href="#autocommit-Commit-and-Rollback" class="headerlink" title="autocommit, Commit, and Rollback"></a>autocommit, Commit, and Rollback</h2><p>在InnoDB中，所有用户活动都在事务内部进行。 如果启用了自动提交模式，则每个SQL语句将自己形成一个事务。 默认情况下，MySQL在启用了自动提交的情况下为每个新连接启动会话，因此如果该SQL语句未返回错误，则MySQL在每个SQL语句之后执行一次提交。 如果一条语句返回错误，则提交或回退行为取决于该错误。 </p>
<p>启用了自动提交的会话可以通过以显式START TRANSACTION或BEGIN语句开始并以COMMIT或ROLLBACK语句结束的方式执行多语句事务。</p>
<p>如果在SET autocommit = 0的会话中禁用了自动提交模式，则该会话将始终打开一个事务。 COMMIT或ROLLBACK语句结束当前事务，并开始新的事务。如果没有在显式提交最终事务的情况下结束，则MySQL将回滚事务。</p>
<p>COMMIT表示在当前事务中所做的更改将永久化，并在其他会话中可见。 另一方面，ROLLBACK语句取消当前事务所做的所有修改。 COMMIT和ROLLBACK都释放在当前事务期间设置的所有InnoDB锁。</p>
<h2 id="InnoDB中由不同的SQL语句设置的锁"><a href="#InnoDB中由不同的SQL语句设置的锁" class="headerlink" title="InnoDB中由不同的SQL语句设置的锁"></a>InnoDB中由不同的SQL语句设置的锁</h2><p>锁读取、更新或删除通常会对SQL语句扫描的每个索引记录设置记录锁。语句中是否存在排除该行的WHERE条件并不重要。InnoDB不知道确切的WHERE条件，只知道扫描了哪些索引范围。这些锁通常是next-key锁，也会阻止插入到紧靠记录之前的“间隙”中。</p>
<p>如果没有适合语句的索引，MySQL必须扫描整个表来处理语句，那么表的每一行都会被锁定，从而阻止其他用户对表的所有插入。创建好的索引非常重要，这样查询就不会扫描许多行。</p>
<p>下面是一些InnoDB设置的特殊类型的锁：</p>
<ul>
<li><p>SELECT … FROM是一致的读取，读取数据库的快照并且没有锁，除非将事务隔离级别设置为SERIALIZABLE。对于SERIALIZABLE级别，搜索会在遇到的索引记录上设置共享的下一键锁定。但是，对于使用唯一索引来搜索唯一行的行锁定的语句，仅需要索引记录锁。 </p>
</li>
<li><p>SELECT … FOR UPDATE或SELECT … LOCK IN SHARE MODE，将为扫描的行获取锁，并释放在结果集中不符合查询条件的行（例如，如果它们不符合WHERE子句中给出的条件）。但是，在某些情况下，行可能不会立即被解锁，因为结果行与其原始行之间的关系在查询执行过程中会丢失。例如，在UNION中，在评估它们是否符合结果集之前，可以将表中的扫描（和锁定）行插入到临时表中。在这种情况下，临时表中的行与原始表中的行之间的关系将丢失，并且直到查询执行结束后，行才被解锁。 </p>
</li>
<li><p>SELECT … LOCK IN SHARE MODE在所有遇到的索引记录上设置共享的next-key锁。但是，对于使用唯一索引来搜索的语句，仅需要索引记录锁定。 </p>
</li>
<li><p>SELECT … FOR UPDATE在所有遇到的记录上设置排他的next-key锁。但是，对于使用唯一索引来搜索的语句，仅需要索引记录锁定。 </p>
<p>对于查询索引记录遇到的问题，SELECT … FOR UPDATE阻止其他会话执行SELECT … LOCK IN SHARE MODE。</p>
</li>
<li><p>UPDATE … WHERE …在搜索遇到的每条记录上设置排他的next-key锁。但是，对于使用唯一索引的语句，仅需要索引记录锁。 </p>
</li>
<li><p>当UPDATE修改聚簇索引记录时，将对受影响的辅助索引记录进行隐式锁定。在插入新的二级索引记录之前执行重复检查扫描时，以及在插入新的二级索引记录时，UPDATE操作还会在受影响的二级索引记录上获得共享锁。 </p>
</li>
<li><p>DELETE FROM … WHERE …在搜索遇到的每条记录上设置独占的next-key锁。但是，对于使用唯一索引的语句，仅需要索引记录锁定。 </p>
</li>
<li><p>INSERT在插入的行上设置排他锁。该锁是索引记录锁，不是next-key锁（即没有间隙锁），并且不会阻止其他事务插入到插入行之前的间隙中。 </p>
<p>在插入行之前，设置了一种称为插入意图间隙锁的间隙锁。此锁表示：如果插入到同一索引间隙中的多个事务不在间隙中的同一位置插入，则它们无需等待对方。假设有索引记录，其值为4和7，在插入行上获得排他锁之前，插入值5和6的事务都使用插入意图锁来锁定4和7之间的间隙，不会彼此阻塞。</p>
</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="一个死锁例子"><a href="#一个死锁例子" class="headerlink" title="一个死锁例子"></a>一个死锁例子</h3><p>下面的示例说明了锁请求可能会导致死锁。 该示例涉及两个客户端A和B。</p>
<p>首先，客户端A创建一个包含一行的表，然后开始事务。 在事务中，A通过在共享模式下选择该行来获得该行的S锁：</p>
<pre class="language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; CREATE TABLE t (i INT) ENGINE &#x3D; InnoDB;
Query OK, 0 rows affected (1.07 sec)

mysql&gt; INSERT INTO t (i) VALUES(1);
Query OK, 1 row affected (0.09 sec)

mysql&gt; START TRANSACTION;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SELECT * FROM t WHERE i &#x3D; 1 LOCK IN SHARE MODE;
+------+
| i    |
+------+
|    1 |
+------+</code></pre>
<p>客户端B开启一个事务并尝试删除一行：</p>
<pre class="language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; START TRANSACTION;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; DELETE FROM t WHERE i &#x3D; 1;</code></pre>
<p>删除操作需要x锁，但由于客户端A持有s锁，不与x锁兼容，客户端请求不到x锁，发生阻塞，进入请求队列中。</p>
<p>最后，客户端A尝试删除该行：</p>
<pre class="language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; DELETE FROM t WHERE i &#x3D; 1;
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</code></pre>
<p>此处发生了死锁，客户端A需要x锁才能删除该行，但不能授予x锁。因为B已经在申请x锁，并等待A释放s锁。由于B事先要求X锁，因此A持有的S锁也不能升级为X锁。结果就是InnoDB为其中 一个客户端生成错误并释放其锁，客户端返回错误。</p>
<h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>启用死锁检测（默认）后，InnoDB自动检测事务死锁并回滚一个或多个事务以打破死锁。 InnoDB会尝试选择一些小的事务以进行回滚，其中事务的大小取决于插入，更新或删除的行数。</p>
<p>如果innodb_table_locks = 1（默认值）且autocommit = 0，则InnoDB可以检测表锁，并且它上面的MySQL层可以检测行级锁。 否则，InnoDB无法检测到涉及MySQL LOCK TABLES语句设置的表锁或InnoDB以外的存储引擎设置的锁的死锁。 通过设置innodb_lock_wait_timeout系统变量的值来解决这些情况。</p>
<p>如果InnoDB Monitor输出的LATEST DETECTED DEADLOCK部分包含一条消息，指出<code>TOO DEEP OR LONG SEARCH IN THE LOCK TABLE WAITS-FOR GRAPH, WE WILL ROLL BACK FOLLOWING TRANSACTION,</code>，这表明等待的事务数 list已达到200的限制。超过200个事务的等待列表将被视为死锁，并且尝试检查等待列表的事务将回退。 如果锁定线程必须查看等待列表上的事务拥有的1,000,000个以上的锁，也可能发生相同的错误。</p>
<h4 id="禁用死锁检测"><a href="#禁用死锁检测" class="headerlink" title="禁用死锁检测"></a>禁用死锁检测</h4><p>在高并发系统上，当多个线程等待相同的锁时，死锁检测会导致速度变慢。 有时，当发生死锁时，禁用死锁检测并依靠innodb_lock_wait_timeout设置进行事务回滚可能会更有效。 可以使用innodb_deadlock_detect配置选项禁用死锁检测。</p>
<h3 id="如何减少和处理死锁"><a href="#如何减少和处理死锁" class="headerlink" title="如何减少和处理死锁"></a>如何减少和处理死锁</h3><p>死锁是含有事务的数据库的经典问题，但死锁并不危险，除非死锁发生很频繁以至于无法运行某些事务。通常需要编写应用程序，以便在由于死锁而使事务回滚时，可以准备重新启动事务。</p>
<p>InnoDB使用行级锁。 即使在仅插入或删除单行的事务中，可能会陷入死锁。 这是因为这些操作并不是真正的“原子”操作。 它们会自动对插入或删除的行的（可能是多个）索引记录设置锁。</p>
<p>您可以使用以下技术来处理死锁并减少发生死锁的可能性：</p>
<ul>
<li><p>在任何时候，发出SHOW ENGINE INNODB STATUS命令来确定最新死锁的原因。 这可以帮助您调整应用程序以避免死锁。</p>
</li>
<li><p>如果频繁出现死锁警告引起关注，请通过启用innodb_print_all_deadlocks配置选项来收集更广泛的调试信息。有关每个死锁的信息，而不仅仅是最新的死锁，都记录在MySQL错误日志中。 完成调试后，请禁用此选项。</p>
</li>
<li><p>如果由于死锁而失败，请始终准备重新发出事务。 死锁并不危险。 请再试一次。</p>
</li>
<li><p>保持事务小巧且持续时间短，以使事务不易发生冲突。</p>
</li>
<li><p>如果使用锁定读取（SELECT … FOR UPDATE或SELECT … LOCK IN SHARE MODE），请尝试使用较低的隔离级别，例如READ COMMITTED。</p>
</li>
<li><p>修改事务中的多个表或同一表中的不同行时，每次都要以一致的顺序执行这些操作。 然后，事务形成定义良好的队列，并且不会死锁。 例如，将数据库操作组织到应用程序内的函数中，或调用存储的例程，而不是在不同位置编码多个类似的INSERT，UPDATE和DELETE语句序列。</p>
</li>
<li><p>将索引添加到表中。然后，查询需要扫描更少的索引记录，并因此设置更少的锁。 使用EXPLAIN SELECT确定MySQL服务器认为哪个索引最适合需要的查询。</p>
</li>
<li><p>使用更少的锁定。 如果您有能力允许SELECT从旧快照返回数据，请不要在其中添加FOR UPDATE或LOCK IN SHARE MODE子句。在这里使用READ COMMITTED隔离级别是好的，因为在同一事务中的每个一致读取都从其自己的新快照读取。</p>
</li>
<li><p>如果没有其他帮助，请使用表级锁序列化事务。将LOCK TABLES与事务表（例如InnoDB表）一起使用的正确方法是，先以SET autocommit = 0（不是START TRANSACTION）加上LOCK TABLES开始事务，然后在明确提交事务之前不调用UNLOCK TABLES。 例如，如果您需要写入表t1并从表t2中读取，则可以执行以下操作：</p>
<pre class="language-mysql" data-language="mysql"><code class="language-mysql">SET autocommit&#x3D;0;
LOCK TABLES t1 WRITE, t2 READ, ...;
... do something with tables t1 and t2 here ...
COMMIT;
UNLOCK TABLES;</code></pre>
<p>表级锁可防止对表的并发更新，从而避免死锁，但代价是对繁忙系统的响应速度较慢。</p>
</li>
<li><p>序列化事务的另一种方法是创建一个仅包含一行的辅助“信号量”表。 在访问其他表之前，让每个事务更新该行。 这样，所有事务都以串行方式进行。 请注意，在这种情况下，InnoDB即时死锁检测算法也适用，因为序列化锁是行级锁。 对于MySQL表级锁，必须使用超时方法来解决死锁。</p>
</li>
</ul>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>gzj</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://zzugzj.github.io/posts/5c27e2b9/" title="InnoDB的锁和事务模型">https://zzugzj.github.io/posts/5c27e2b9/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/posts/d05c43b2/" rel="prev" title="REST原则六约束与Richardson成熟度模型"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">REST原则六约束与Richardson成熟度模型</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/posts/9617db49/" rel="next" title="MySQL幻读和可重复读"><span class="post-nav-text">MySQL幻读和可重复读</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div id="comment"><div class="comment-tooltip text-center"><span>点击按钮跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br><a class="hty-button hty-button--raised" id="github-issues" target="_blank" rel="noopener" href="https://github.com/zzugzj/zzugzj.github.io/issues?q=is:issue+InnoDB的锁和事务模型">GitHub Issues</a></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2020 – 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> gzj</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.3.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.3.0</span></div><div class="live_time"><span>本博客已运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  window.setTimeout(blog_live_time, 1000);
  const start = new Date('2020-12-31T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="搜索..." value=""></div><div id="local-search-result"></div></div><div class="aplayer no-destroy" id="aplayer" data-id="7840106285" data-server="tencent" data-type="playlist" data-fixed="true" data-theme="#0078E7" data-loop="all" data-order="list" data-preload="auto" data-volume="0.7" data-mutex data-lrctype="0" data-listmaxheight="340px" data-storagename="metingjs"></div></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script></body></html>