<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="gzj"><meta name="copyright" content="gzj"><meta name="generator" content="Hexo 5.3.0"><meta name="theme" content="hexo-theme-yun"><title>Java8实战笔记 | gzj-blogs</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.22/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_ed8vp4atwoj.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/themes/prism.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/themes/prism-tomorrow.css" media="(prefers-color-scheme: dark)"><link rel="shortcut icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><link rel="alternate" href="/atom.xml" title="gzj-blogs" type="application/atom+xml"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"zzugzj.github.io","root":"/","title":"莫在浮沙筑高台","version":"1.3.0","mode":"auto","copycode":true,"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><meta name="description" content="Java 8中的新增功能是自Java 1.0发布18年以来，Java发生的最大变化。没有去掉任何东西，因此你现有的Java代码都能工作，但新功能提供了强大的新语汇和新设计模式，能帮助你编写更清楚、更简洁的代码。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java8实战笔记">
<meta property="og:url" content="https://zzugzj.github.io/posts/30888651/index.html">
<meta property="og:site_name" content="gzj-blogs">
<meta property="og:description" content="Java 8中的新增功能是自Java 1.0发布18年以来，Java发生的最大变化。没有去掉任何东西，因此你现有的Java代码都能工作，但新功能提供了强大的新语汇和新设计模式，能帮助你编写更清楚、更简洁的代码。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210310193142971.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210310223646991.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210310223702177.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210310224129130.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210312103902789.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210312105030226.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210313225757611.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210314011758437.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210316090243757.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210316222100864.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210316222143103.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210316222644795.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210316223131490.png">
<meta property="article:published_time" content="2021-03-09T14:36:25.000Z">
<meta property="article:modified_time" content="2023-11-05T05:48:34.128Z">
<meta property="article:author" content="gzj">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210310193142971.png"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="gzj"><img width="96" loading="lazy" src="/Yun.png" alt="gzj"></a><div class="site-author-name"><a href="/about/">gzj</a></div><a class="site-name" href="/about/site.html">gzj-blogs</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">31</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">9</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">13</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/zzugzj" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8ALambda%E4%BB%98%E8%AF%B8%E5%AE%9E%E8%B7%B5%EF%BC%9A%E7%8E%AF%E7%BB%95%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">把Lambda付诸实践：环绕执行模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.</span> <span class="toc-text">使用函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Predicate"><span class="toc-number">2.1.</span> <span class="toc-text">Predicate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Consumer"><span class="toc-number">2.2.</span> <span class="toc-text">Consumer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Function"><span class="toc-number">2.3.</span> <span class="toc-text">Function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.4.</span> <span class="toc-text">常用函数式接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">2.5.</span> <span class="toc-text">一些使用案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E3%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%8F%8A%E9%99%90%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">类型推断、类型检查及限制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">3.1.</span> <span class="toc-text">使用局部变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">方法引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">如何构建方法引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%9C%89%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">复合 Lambda 表达式的有用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%99%A8%E5%A4%8D%E5%90%88"><span class="toc-number">5.1.</span> <span class="toc-text">比较器复合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%93%E8%AF%8D%E5%A4%8D%E5%90%88"><span class="toc-number">5.2.</span> <span class="toc-text">谓词复合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A4%8D%E5%90%88"><span class="toc-number">5.3.</span> <span class="toc-text">函数复合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E4%B8%8E%E9%9B%86%E5%90%88"><span class="toc-number">6.</span> <span class="toc-text">流与集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E8%83%BD%E9%81%8D%E5%8E%86%E4%B8%80%E6%AC%A1"><span class="toc-number">6.1.</span> <span class="toc-text">只能遍历一次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E8%BF%AD%E4%BB%A3%E4%B8%8E%E5%86%85%E9%83%A8%E8%BF%AD%E4%BB%A3"><span class="toc-number">6.2.</span> <span class="toc-text">外部迭代与内部迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%93%8D%E4%BD%9C"><span class="toc-number">6.3.</span> <span class="toc-text">流操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B5%81"><span class="toc-number">7.</span> <span class="toc-text">使用流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84"><span class="toc-number">7.1.</span> <span class="toc-text">映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E7%BA%A6"><span class="toc-number">7.2.</span> <span class="toc-text">归约</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%93%8D%E4%BD%9C%EF%BC%9A%E6%97%A0%E7%8A%B6%E6%80%81%E5%92%8C%E6%9C%89%E7%8A%B6%E6%80%81"><span class="toc-number">7.3.</span> <span class="toc-text">流操作：无状态和有状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E6%B5%81"><span class="toc-number">7.4.</span> <span class="toc-text">数值流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E6%B5%81%E7%89%B9%E5%8C%96"><span class="toc-number">7.4.1.</span> <span class="toc-text">原始类型流特化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E8%8C%83%E5%9B%B4-amp-%E7%94%9F%E6%88%90%E6%95%B0"><span class="toc-number">7.4.2.</span> <span class="toc-text">数值范围&amp;生成数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%B5%81"><span class="toc-number">7.5.</span> <span class="toc-text">构建流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B5%81%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE"><span class="toc-number">8.</span> <span class="toc-text">用流收集数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E7%BA%A6%E5%92%8C%E6%B1%87%E6%80%BB"><span class="toc-number">8.1.</span> <span class="toc-text">归约和汇总</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reducing"><span class="toc-number">8.2.</span> <span class="toc-text">reducing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%BB%84"><span class="toc-number">8.3.</span> <span class="toc-text">分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA"><span class="toc-number">8.4.</span> <span class="toc-text">分区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8Optinal%E5%8F%96%E4%BB%A3null"><span class="toc-number">9.</span> <span class="toc-text">用Optinal取代null</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4API"><span class="toc-number">10.</span> <span class="toc-text">新的日期和时间API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LocalDate%E3%80%81LocalTime%E3%80%81Instant%E3%80%81Duration-%E4%BB%A5%E5%8F%8A-Period"><span class="toc-number">10.1.</span> <span class="toc-text">LocalDate、LocalTime、Instant、Duration 以及 Period</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E7%BA%B5%E3%80%81%E8%A7%A3%E6%9E%90%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F"><span class="toc-number">10.2.</span> <span class="toc-text">操纵、解析和格式化日期</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://zzugzj.github.io/posts/30888651/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="gzj"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="gzj-blogs"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java8实战笔记</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2021-03-09 22:36:25" itemprop="dateCreated datePublished" datetime="2021-03-09T22:36:25+08:00">2021-03-09</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2023-11-05 13:48:34" itemprop="dateModified" datetime="2023-11-05T13:48:34+08:00">2023-11-05</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/Java%E5%9F%BA%E7%A1%80/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">Java基础</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/tags/Java%E5%9F%BA%E7%A1%80/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">Java基础</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h3 id="把Lambda付诸实践：环绕执行模式"><a href="#把Lambda付诸实践：环绕执行模式" class="headerlink" title="把Lambda付诸实践：环绕执行模式"></a>把Lambda付诸实践：环绕执行模式</h3><p>资源处理时常见的一个模式是打开一个资源，做一些处理，然后关闭资源，这个设置和清理阶段类似，并且会围绕着执行处理的业务逻辑。这就是环绕执行模式。</p>
<p>1）第一步，当需要更改逻辑代码是，需要重写代码，所以想到行为参数化</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">processFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">try</span><span class="token punctuation">(</span><span class="token class-name">BufferedReader</span> bufferedReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"data.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
   	    <span class="token comment">// return bufferedReader.readLine();</span>
    	<span class="token keyword">return</span> bufferedReader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> bufferedReader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>2）第二步，使用函数式接口来传递一个行为</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BufferReaderProcessFile</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 方法签名为 BufferReader -> String</span>
    <span class="token class-name">String</span> <span class="token function">peocess</span><span class="token punctuation">(</span><span class="token class-name">BufferedReader</span> bufferedReader<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>3）第三步，执一个行为，任何BufferReader -&gt; String的Lambda表达式都可以作为参数传入。只要符合peocess方法的签名即可。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">processFiles</span><span class="token punctuation">(</span><span class="token class-name">BufferReaderProcessFile</span> bufferReaderProcessFile<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">try</span><span class="token punctuation">(</span><span class="token class-name">BufferedReader</span> bufferedReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"data.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> bufferReaderProcessFile<span class="token punctuation">.</span><span class="token function">peocess</span><span class="token punctuation">(</span>bufferedReader<span class="token punctuation">)</span> <span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>4）第四步，传递Lambda</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> string <span class="token operator">=</span> <span class="token function">processFiles</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">BufferedReader</span> bs<span class="token punctuation">)</span> <span class="token operator">-></span> bs<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><img src="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210310193142971.png" alt="image-20210310193142971" loading="lazy"></p>
<h3 id="使用函数式接口"><a href="#使用函数式接口" class="headerlink" title="使用函数式接口"></a>使用函数式接口</h3><p>函数式接口很有用，因为抽象方法的签名可以描述Lambda表达式的签名。函数式接口的抽象方法的签名称为函数描述符。所以为了应用不同的Lambda表达式，需要一套能够描述常见函数描述符的函数式接口。</p>
<p>Java 8的库设计师在java.util.function包中引入了几个新的函数式接口。</p>
<p>几个常用的函数式接口：</p>
<h4 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h4><p>java.util.function.Predicate&lt;T&gt;接口定义了一个名叫test的抽象方法，它接受泛型T对象，并返回一个boolean。这恰恰和你先前创建的一样，现在就可以直接使用了。在需要表示一个涉及类型T的布尔表达式时，就可以使用这个接口。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span> 
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Predicate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span> 
    <span class="token keyword">boolean</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span> 
 
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> list<span class="token punctuation">,</span> <span class="token class-name">Predicate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> results <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">T</span> s<span class="token operator">:</span> list<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> 
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> 
            results<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">&#125;</span> 
    <span class="token punctuation">&#125;</span> 
    <span class="token keyword">return</span> results<span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span> 
 
<span class="token class-name">Predicate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> nonEmptyStringPredicate <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> nonEmpty <span class="token operator">=</span> <span class="token function">filter</span><span class="token punctuation">(</span>listOfStrings<span class="token punctuation">,</span> nonEmptyStringPredicate<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>java.util.function.Consumer&lt;T&gt;定义了一个名叫accept的抽象方法，它接受泛型T的对象，没有返回（void）。如果需要访问类型T的对象，并对其执行某些操作，就可以使用这个接口。比如，可以用它来创建一个forEach方法，接受一个Integers的列表，并对其中每个元素执行操作。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span> 
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span> 
    <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span> 
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token keyword">void</span> <span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> list<span class="token punctuation">,</span> <span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">T</span> i<span class="token operator">:</span> list<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> 
        c<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">&#125;</span> 
<span class="token punctuation">&#125;</span> 
 
<span class="token function">forEach</span><span class="token punctuation">(</span> 
         <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
        <span class="token punctuation">(</span><span class="token class-name">Integer</span> i<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>  
       <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><p>java.util.function.Function&lt;T, R&gt;接口定义了一个叫作apply的方法，它接受一个泛型T的对象，并返回一个泛型R的对象。如果需要定义一个Lambda，将输入对象的信息映射到输出，就可以使用这个接口（比如提取苹果的重量，或把字符串映射为它的长度）。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span> 
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span> 
    <span class="token class-name">R</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span> 
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">></span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">></span></span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> list<span class="token punctuation">,</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">></span></span> f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">></span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">T</span> s<span class="token operator">:</span> list<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> 
        result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">&#125;</span> 
    <span class="token keyword">return</span> result<span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span> 
<span class="token comment">// [7, 2, 6] </span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> l <span class="token operator">=</span> <span class="token function">map</span><span class="token punctuation">(</span> 
                       <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"lambdas"</span><span class="token punctuation">,</span><span class="token string">"in"</span><span class="token punctuation">,</span><span class="token string">"action"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
                       <span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token operator">-></span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
               <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h4 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h4><p><img src="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210310223646991.png" alt="image-20210310223646991" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210310223702177.png" alt="image-20210310223702177" loading="lazy"></p>
<h4 id="一些使用案例"><a href="#一些使用案例" class="headerlink" title="一些使用案例"></a>一些使用案例</h4><p><img src="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210310224129130.png" alt="image-20210310224129130" loading="lazy"></p>
<p><strong>异常，Lambda，还有函数式接口：</strong></p>
<p><strong>任何的函数式接口都不能抛出受检异常(check exception)，如果你需要lambda 表达式抛出异常，有两种方法：</strong></p>
<p><strong>定义一个自己的函数式接口，并申明受检异常，或者把Lambda包在一个try/catch块中。</strong></p>
<h3 id="类型推断、类型检查及限制"><a href="#类型推断、类型检查及限制" class="headerlink" title="类型推断、类型检查及限制"></a>类型推断、类型检查及限制</h3><h4 id="使用局部变量"><a href="#使用局部变量" class="headerlink" title="使用局部变量"></a>使用局部变量</h4><p>Lambda表达式也允许使用自由变量（不是参数，而是在外层作用域中定义的变量），就像匿名类一样。 它们被称作捕获Lambda。例如，下面的Lambda捕获了portNumber变量： </p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> portNumber <span class="token operator">=</span> <span class="token number">1337</span><span class="token punctuation">;</span> 
<span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>portNumber<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre>
<p>尽管如此，还有一点点小麻烦：关于能对这些变量做什么有一些限制。Lambda可以没有限制地捕获（也就是在其主体中引用）实例变量和静态变量。但局部变量必须显式声明为final，或事实上是final。换句话说，Lambda表达式只能捕获指派给它们的局部变量一次。（注：捕获实例变量可以被看作捕获最终局部变量this。） 例如，下面的代码无法编译，因为portNumber变量被赋值两次： </p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> portNumber <span class="token operator">=</span> <span class="token number">1337</span><span class="token punctuation">;</span> 
<span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>portNumber<span class="token punctuation">)</span><span class="token punctuation">;</span>  
portNumber <span class="token operator">=</span> <span class="token number">31337</span><span class="token punctuation">;</span></code></pre>
<p><strong>对局部变量的限制</strong> </p>
<p>你可能会问自己，为什么局部变量有这些限制。第一，实例变量和局部变量背后的实现有一个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线程将这个变量收回之后，去访问该变量。因此，Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了这个限制。 </p>
<p>在JDK8中如果我们在匿名内部类中需要访问局部变量，那么这个局部变量不需要用final修饰符修饰。看似是一种编译机制的改变，实际上就是一个语法糖（底层还是帮你加了final）。但通过反编译没有看到底层为我们加上final，但我们无法改变这个局部变量的引用值，如果改变就会编译报错。</p>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>需要使用方法引用时，目标引用放在分隔符::前，方法的名称放在后面。</p>
<p><img src="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210312103902789.png" alt="image-20210312103902789" loading="lazy"></p>
<h4 id="如何构建方法引用"><a href="#如何构建方法引用" class="headerlink" title="如何构建方法引用"></a>如何构建方法引用</h4><p>方法引用主要有三类。 </p>
<p>(1) 指向静态方法的方法引用（例如Integer的parseInt方法，写作Integer::parseInt）。</p>
<p>(2) 指 向 任 意 类 型 实 例 方 法 的 方 法 引 用 （ 例 如 String 的 length 方 法 ， 写 作String::length）。</p>
<p>(3) 指向现有对象的实例方法的方法引用（假设你有一个局部变量expensiveTransaction用于存放Transaction类型的对象，它支持实例方法getValue，那么你就可以写expensiveTransaction::getValue）。</p>
<p><img src="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210312105030226.png" alt="image-20210312105030226" loading="lazy"></p>
<h3 id="复合-Lambda-表达式的有用方法"><a href="#复合-Lambda-表达式的有用方法" class="headerlink" title="复合 Lambda 表达式的有用方法"></a>复合 Lambda 表达式的有用方法</h3><h4 id="比较器复合"><a href="#比较器复合" class="headerlink" title="比较器复合"></a>比较器复合</h4><p>使用静态方法Comparator.comparing，根据提取用于比较的键值的Function来返回一个Comparator</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Apple</span><span class="token punctuation">></span></span> c <span class="token operator">=</span> <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">Apple</span><span class="token operator">::</span><span class="token function">getWeight</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ol>
<li><p>逆序<br> 接口有一个默认方法reversed可以使给定的比较器逆序。因此仍然用开始的那个比较器，只要修改一下前一个例子就可以对苹果按重量递减排序： </p>
<pre class="language-java" data-language="java"><code class="language-java">inventory<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">Apple</span><span class="token operator">::</span><span class="token function">getWeight</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
<li><p>比较器链<br>如果发现有两个苹果一样重怎么办？哪个苹果应该排在前面呢？你可能需要再提供一个Comparator来进一步定义这个比较。thenComparing方法就是做这个用的。它接受一个函数作为参数（就像comparing方法一样），如果两个对象用第一个Comparator比较之后是一样的，就提供第二个Comparator。你又可以优雅地解决这个问题了： </p>
<pre class="language-java" data-language="java"><code class="language-java">inventory<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">Apple</span><span class="token operator">::</span><span class="token function">getWeight</span><span class="token punctuation">)</span> 
         <span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
         <span class="token punctuation">.</span><span class="token function">thenComparing</span><span class="token punctuation">(</span><span class="token class-name">Apple</span><span class="token operator">::</span><span class="token function">getCountry</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>


</li>
</ol>
<h4 id="谓词复合"><a href="#谓词复合" class="headerlink" title="谓词复合"></a>谓词复合</h4><p>谓词接口包括三个方法：negate、and和or，可以重用已有的Predicate来创建更复杂的谓词。</p>
<p>表达要么是重（150克以上）的苹果，要么是绿苹果： </p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Predicate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Apple</span><span class="token punctuation">></span></span> redAndHeavyAppleOrGreen <span class="token operator">=</span> 
    redApple<span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span>a <span class="token operator">-></span> a<span class="token punctuation">.</span><span class="token function">getWeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">150</span><span class="token punctuation">)</span> 
            <span class="token punctuation">.</span><span class="token function">or</span><span class="token punctuation">(</span>a <span class="token operator">-></span> <span class="token string">"green"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre>
<p>请注意，and和or方法是按照在表达式链中的位置，从左向右确定优先级的。因此，a.or(b).and(c)可以看作(a || b) &amp;&amp; c。</p>
<h4 id="函数复合"><a href="#函数复合" class="headerlink" title="函数复合"></a>函数复合</h4><p>Function接口为此配了andThen和compose两个默认方法，它们都会返回Function的一个实例。</p>
<p>andThen方法，会返回一个函数，它先对输入应用一个给定函数，再对输出应用另一个函数。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> f <span class="token operator">=</span> x <span class="token operator">-></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//数学上会写作g(f(x))</span>
<span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> g <span class="token operator">=</span> x <span class="token operator">-></span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> h <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">andThen</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出4</span></code></pre>
<p>compose方法，先把给定的函数用作compose的参数里面给的那个函数，然后再把函数本身用于结果。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> f <span class="token operator">=</span> x <span class="token operator">-></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//数学上会写作f(g(x))</span>
<span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> g <span class="token operator">=</span> x <span class="token operator">-></span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> h <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">compose</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出3</span></code></pre>
<h3 id="流与集合"><a href="#流与集合" class="headerlink" title="流与集合"></a>流与集合</h3><h4 id="只能遍历一次"><a href="#只能遍历一次" class="headerlink" title="只能遍历一次"></a>只能遍历一次</h4><p>流和迭代器类似，只能遍历一次。遍历完后，这个流已经被消费掉了。</p>
<p>可以从原始数据源那里再获得一个新的流来重新遍历一遍，就像迭代器一样（这里假设它是集<br>合之类的可重复的源，如果是I/O通道就没戏了）。</p>
<h4 id="外部迭代与内部迭代"><a href="#外部迭代与内部迭代" class="headerlink" title="外部迭代与内部迭代"></a>外部迭代与内部迭代</h4><p>使用Collection接口需要用户去做迭代（比如用for-each），这称为外部迭代。 相反， Streams库使用内部迭代，它帮你把迭代做了，还把得到的流值存在了某个地方，你只要给出一个函数说要干什么就可以了。</p>
<h4 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h4><p>可以连接起来的流操作称为中间操作，关闭流的操作称为终端操作。</p>
<p>1）中间操作：一般都可以合并起来，在终端操作时一次性全部处理。</p>
<p>2）终端操作：会从流的流水线生成结果。其结果是任何不是流的值，比如List、Integer，甚<br>至void。</p>
<p><img src="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210313225757611.png" alt="image-20210313225757611" loading="lazy"></p>
<h3 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h3><p>基本的一些流操作：filter筛选，distinct去重，limit截断，skip跳过</p>
<h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p>1）对流中每一个元素应用函数：流支持map方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素（使用映射一词，是因为它和转换类似，但其中的细微差别在于它是“创建一 个新版本“，而不是去“修改”）。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> dishname <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Dish</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>2）流的扁平化</p>
<p>flatMap方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。flatmap方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Stream</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> stream <span class="token operator">=</span> list1<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment">//使用flatMap</span>
    <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>i <span class="token operator">-></span> list2<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>j <span class="token operator">-></span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>i<span class="token punctuation">,</span> j<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Stream</span><span class="token operator">&lt;</span><span class="token class-name">Stream</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">>></span> stream <span class="token operator">=</span> list1<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//使用map</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>i <span class="token operator">-></span> list2<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>j <span class="token operator">-></span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>i<span class="token punctuation">,</span> j<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h4 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h4><p>即把集合中的元素反复结合起来，得到一个值，即将流归约为一个值，用函数式编程语言叫折叠。</p>
<p>1）元素求和：reduce方法</p>
<p><strong>reduce接受两个参数：</strong> </p>
<ol>
<li>一个初始值，这里是0；</li>
<li>一个BinaryOperator&lt;T&gt;来将两个元素结合起来产生一个新值。</li>
</ol>
<p>在Java 8中，Integer类现在有了一个静态的sum方法来对两个数求和，这恰好是我们想要的，用不着反复用Lambda写同一段代码了： </p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> sum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">sum</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong>无初始值</strong> </p>
<p>reduce还有一个重载的变体，它不接受初始值，但是会返回一个Optional对象： </p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> sum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre>
<p>为什么它返回一个Optional&lt;Integer&gt;呢？考虑流中没有任何元素的情况。reduce操作无法返回其和，因为它没有初始值。这就是为什么结果被包裹在一个Optional对象里，以表明和可能不存在。</p>
<p><strong>map和reduce的连接通常称为map-reduce模式，因Google用它来进行网络搜索而出名，因为它很容易并行化。</strong></p>
<h4 id="流操作：无状态和有状态"><a href="#流操作：无状态和有状态" class="headerlink" title="流操作：无状态和有状态"></a>流操作：无状态和有状态</h4><ul>
<li><p>map或filter等操作会从输入流中获取每一个元素，并在输出流中得到0或1个结果。这些操作一般都是无状态无状态的：它们没有内部状态（假设用户提供的Lambda或方法引用没有内部可变状态）。</p>
</li>
<li><p>reduce、sum、max等操作需要内部状态来累积结果。在上面的情况下，内部状态很小。在我们的例子里就是一个int或double。不管流中有多少元素要处理，内部状态都是有界的。</p>
</li>
<li><p>sort或distinct等操作一开始都和filter和map差不多——都是接受一个流，再生成一个流（中间操作），但有一个关键的区别。从流中排序和删除重复项时都需要知道先前的历史。例如，排序要求所有元素都放入缓冲区后才能给输出流加入一个项目，这一操作的存储要求是无界的。要是流比较大或是无限的，就可能会有问题（把质数流倒序会做什么呢？它应当返回最大的质数，但数学告诉我们它不存在）。我们把这些操作叫作有状态操作。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210314011758437.png" alt="image-20210314011758437" loading="lazy"></p>
<h4 id="数值流"><a href="#数值流" class="headerlink" title="数值流"></a>数值流</h4><p>我们在前面看到了可以使用reduce方法计算流中元素的总和。例如，你可以像下面这样计算菜单的热量： </p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> calories <span class="token operator">=</span> menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
                   <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Dish</span><span class="token operator">::</span><span class="token function">getCalories</span><span class="token punctuation">)</span> 
                   <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">sum</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>这段代码的问题是，它有一个暗含的装箱成本。每个Integer都必须拆箱成一个原始类型，再进行求和。但 Stream API还提供了原始类型流特化，专门支持处理数值流的方法。</p>
<h5 id="原始类型流特化"><a href="#原始类型流特化" class="headerlink" title="原始类型流特化"></a>原始类型流特化</h5><p>Java 8引入了三个原始类型特化流接口来解决这个问题：IntStream、DoubleStream和LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的装箱成本。每个接口都带来了进行常用数值归约的新方法，比如对数值流求和的sum，找到最大元素的max。此外还有在必要时再把它们转换回对象流的方法。</p>
<ol>
<li><p><strong>映射到数值流</strong></p>
<p>将流转换为特化版本的常用方法是mapToInt、mapToDouble和mapToLong。这些方法和前面说的map方法的工作方式一样，只是它们返回的是一个特化流，而不是Stream&lt;T&gt;。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> calories <span class="token operator">=</span> menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
                   <span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span><span class="token class-name">Dish</span><span class="token operator">::</span><span class="token function">getCalories</span><span class="token punctuation">)</span>  
                   <span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>这里，mapToInt会从每道菜中提取热量（用一个Integer表示），并返回一个IntStream（而不是一个Stream&lt;Integer&gt;）。<strong>如果流是空的，sum默认返回0。</strong>IntStream还支持其他的方便方法，如max、min、average等。</p>
</li>
<li><p><strong>转换回对象流</strong></p>
<p>由于IntStream的map操作接受的Lambda必须接受int并返回int，那有时可能会想把数值流转换回非特化流。</p>
<p>要把原始流转换成一般流（每个int都会装箱成一个Integer），可以使用boxed方法。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">IntStream</span> intStream <span class="token operator">=</span> menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span><span class="token class-name">Dish</span><span class="token operator">::</span><span class="token function">getCalories</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> stream <span class="token operator">=</span> intStream<span class="token punctuation">.</span><span class="token function">boxed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h5 id="数值范围-amp-生成数"><a href="#数值范围-amp-生成数" class="headerlink" title="数值范围&amp;生成数"></a>数值范围&amp;生成数</h5></li>
</ol>
<p>Java 8引入了两个可以用于IntStream和LongStream的静态方法，帮助生成这种范围：range和rangeClosed。这两个方法都是第一个参数接受起始值，第二个参数接受结束值。但range是不包含结束值的：<code>[l, r)</code>，而rangeClosed则包含结束值：<code>[l, r]</code>。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">IntStream</span> evenNumbers <span class="token operator">=</span> <span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">rangeClosed</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>   <span class="token comment">//表示范围[1, 100]</span>
                <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>n <span class="token operator">-></span> n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>evenNumbers<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//50</span></code></pre>
<h4 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h4><ul>
<li><p>由值创建流</p>
<p>使用静态方法Stream.of，通过显式值创建一个流。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> stream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Java 8 "</span><span class="token punctuation">,</span> <span class="token string">"Lambdas "</span><span class="token punctuation">,</span> <span class="token string">"In "</span><span class="token punctuation">,</span> <span class="token string">"Action"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
stream<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">toUpperCase</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> emptyStream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//空流</span></code></pre></li>
<li><p>由数组创建流</p>
<p>Arrays.stream从数组创建一个流。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
<li><p>由文件生成流</p>
<p>Java中用于处理文件等I/O操作的NIO API（非阻塞 I/O）已更新，以便利用Stream API。java.nio.file.Files中的很多静态方法都会返回一个流。比如：<code>Files.lines</code>，它会返回一个由指定文件中的各行构成的字符串流。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Pattern</span> pattern <span class="token operator">=</span> <span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">"[a-zA-Z]+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//统计一个英文文件中各个单词出现的次数，并排序</span>
<span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> lines <span class="token operator">=</span> <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">lines</span><span class="token punctuation">(</span><span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"D:/data.txt"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Charset</span><span class="token punctuation">.</span><span class="token function">defaultCharset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">></span></span> collect <span class="token operator">=</span> lines<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>i <span class="token operator">-></span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">final</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s1 <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> s1<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">final</span> <span class="token class-name">Matcher</span> matcher <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>s1<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            s1<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> matcher<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> matcher<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>i <span class="token operator">-></span> i<span class="token punctuation">,</span> <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">counting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">></span><span class="token punctuation">></span></span> entries <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>collect<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    entries<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">.</span><span class="token function">comparingByValue</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">reverseOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entries<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entries<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mapToLong</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">::</span><span class="token function">getValue</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p>由函数生成流：创建无限流</p>
<p>Stream API提供了两个静态方法来从函数生成流：Stream.iterate和Stream.generate。 这两个操作可以创建所谓的无限流：不像从固定集合创建的流那样有固定大小的流。由iterate 和generate产生的流会用给定的函数按需创建值，因此可以无穷无尽地计算下去！<strong>必须使用limit(n)来对这种流加以限制。</strong></p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> a <span class="token operator">-></span> a <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>iterate方法接受一个初始值（在这里是0），还有一个依次应用在每个产生的新值上的Lambda（UnaryOperator&lt;t&gt;类型）。</p>
<p>generate接受一个Supplier&lt;T&gt;类型的Lambda提供新的值。</p>
</li>
</ul>
<h3 id="用流收集数据"><a href="#用流收集数据" class="headerlink" title="用流收集数据"></a>用流收集数据</h3><h4 id="归约和汇总"><a href="#归约和汇总" class="headerlink" title="归约和汇总"></a>归约和汇总</h4><p><strong>maxBy/minBy：</strong>计算流中的最大或最小值。</p>
<p><strong>summingInt/summingLong/summingDouble：</strong>生成一个用于求元素和的Collector，首先通过给定的mapper将元素转换类型，然后再求和。参数的作用就是将元素转换为指定的类型，最后结果与转换后类型一致。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> i <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">summingInt</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">valueOf</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//list中String转为int求和</span>
<span class="token keyword">int</span> totalCalories <span class="token operator">=</span> menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">summingInt</span><span class="token punctuation">(</span><span class="token class-name">Dish</span><span class="token operator">::</span><span class="token function">getCalories</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//类获取属性求和</span></code></pre>
<p><strong>averagingInt/averagingLong/averagingDouble：</strong>生成一个用于求元素平均值的Collector，首选通过参数将元素转换为指定的类型。用法和上面差不多。</p>
<p><strong>joining：</strong>joining工厂方法返回的收集器会把对流中每一个对象应用toString方法得到的所有字符串连接成一个字符串。在内部使用了StringBuilder来把生成的字符串逐个追加起来。可以指定连接符，甚至是结果的前后缀。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> shortMenu <span class="token operator">=</span> menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Dish</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> shortMenu <span class="token operator">=</span> menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Dish</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> sss <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">,</span><span class="token string">"S"</span><span class="token punctuation">,</span><span class="token string">"E"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h4 id="reducing"><a href="#reducing" class="headerlink" title="reducing"></a>reducing</h4><p>我们已经讨论的所有收集器，都是一个可以用reducing工厂方法定义的归约过程的特殊情况而已。Collectors.reducing工厂方法是所有这些特殊情况的一般化。可以说，先前讨论的案例仅仅是为了方便程序员而已。</p>
<p>它需要三个参数。 </p>
<ul>
<li>第一个参数是归约操作的起始值，也是流中没有元素时的返回值，所以很显然对于数值和而言0是一个合适的值。 </li>
<li>第二个参数就是应用于每个输入值的映射函数。</li>
<li>第三个参数是一个BinaryOperator，将两个项目累积成一个同类型的值。这里它就是对两个int求和。</li>
</ul>
<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>给groupingBy方法传递了一个Function（以方法引用的形式），它提取了流中每 一道Dish的Dish.Type。</p>
<p>我们把这个Function叫作分类函数，因为它用来把流中的元素分成不同的组。</p>
<p>分组操作的结果是一个Map，把分组函数返回的值作为映射的键，把流中所有具有这个分类值的项目的列表作为对应的映射值。</p>
<p><img src="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210316090243757.png" alt="image-20210316090243757" loading="lazy"></p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> collect <span class="token operator">=</span> lists<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">length</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong>多级分组</strong></p>
<p>要实现多级分组，我们可以使用一个由双参数版本的Collectors.groupingBy工厂方法创建的收集器，它除了普通的分类函数之外，还可以接受collector类型的第二个参数。那么要进行二级分组的话，我们可以把一个内层groupingBy传递给外层groupingBy，并定义一个为流<br>中项目分类的二级标准。</p>
<pre class="language-java" data-language="java"><code class="language-java">lists<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">hashCode</span><span class="token punctuation">,</span> <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">length</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong>按子组收集数据</strong></p>
<p>groupingBy的第二个参数可以是Collector，所以除了多级分组还有别的用处。</p>
<p>比如查询某种菜的数量：</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Dish<span class="token punctuation">.</span>Type</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">></span></span> typesCount <span class="token operator">=</span> menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">Dish</span><span class="token operator">::</span><span class="token function">getType</span><span class="token punctuation">,</span> <span class="token function">counting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//返回：&#123;MEAT=3, FISH=2, OTHER=4&#125;</span></code></pre>
<p><strong>把收集器的结果转换为另一种类型</strong> </p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Dish<span class="token punctuation">.</span>Type</span><span class="token punctuation">,</span> <span class="token class-name">Dish</span><span class="token punctuation">></span></span> mostCaloricByType <span class="token operator">=</span> <span class="token class-name">Dish</span><span class="token punctuation">.</span>menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">Dish</span><span class="token operator">::</span><span class="token function">getType</span><span class="token punctuation">,</span>
                                <span class="token function">collectingAndThen</span><span class="token punctuation">(</span>
                                        <span class="token function">maxBy</span><span class="token punctuation">(</span><span class="token function">comparingInt</span><span class="token punctuation">(</span><span class="token class-name">Dish</span><span class="token operator">::</span><span class="token function">getCalories</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                        <span class="token class-name">Optional</span><span class="token operator">::</span><span class="token function">get</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p>分区是分组的特殊情况：由一个谓词（返回一个布尔值的函数）作为分类函数，它称分区函数。分区函数返回一个布尔值，这意味着得到的分组Map的键类型是Boolean，于是它最多可以分为两组——true是一组，false是一组。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Dish</span><span class="token punctuation">></span><span class="token punctuation">></span></span> partitionedMenu <span class="token operator">=</span> 
             menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">partitioningBy</span><span class="token punctuation">(</span><span class="token class-name">Dish</span><span class="token operator">::</span><span class="token function">isVegetarian</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3 id="用Optinal取代null"><a href="#用Optinal取代null" class="headerlink" title="用Optinal取代null"></a>用Optinal取代null</h3><p>变量存在时，Optional类只是对类简单封装。变量不存在时，缺失的值会被建模成一个“空” 的Optional对象，由方法<code>Optional.empty()</code>返回。<br><code>Optional.empty()</code>方法是一个静态工厂 方法，它返回Optional类的特定单一实例。：如果你尝试引用一个null，一定会触发NullPointerException，不过使用<code>Optional.empty()</code>就完全没事儿，它是Optional类的一个有效对象，多种场景都能调用，非 常有用。</p>
<ol>
<li><p>创建Optional对象</p>
<ol>
<li><p>声明一个空的Optional ,可以通过静态工厂方法Optional.empty，创建一个空的Optional 对象： </p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Car</span><span class="token punctuation">></span></span> optCar <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
<li><p>依据一个非空值创建Optional :还可以使用静态工厂方法Optional.of，依据一个非空值创建一个Optional对象： </p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Car</span><span class="token punctuation">></span></span> optCar <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>car<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
<li><p>可接受null的Optional ,使用静态工厂方法Optional.ofNullable，你可以创建一个允许null值的Optional 对象： </p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Car</span><span class="token punctuation">></span></span> optCar <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>car<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ol>
</li>
<li><p>使用map 从 Optional 对象中提取和转换值 </p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Insurance</span><span class="token punctuation">></span></span> optInsurance <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>insurance<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> name <span class="token operator">=</span> optInsurance<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Insurance</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
<li><p>默认行为即解引用的Optional对象</p>
<ol>
<li><code>get()</code>是这些方法中最简单但又最不安全的方法。如果变量存在，它直接返回封装的变量 值，否则就抛出一个NoSuchElementException异常。所以，除非你非常确定Optional 变量一定包含值，否则使用这个方法是个相当糟糕的主意。此外，这种方式即便相对于 嵌套式的null检查，也并未体现出多大的改进。</li>
<li><code>orElse(T other)</code>它允许你在 Optional对象不包含值时提供一个默认值。</li>
<li><code>orElseGet(Supplier&lt;? extends T&gt; other)</code>是orElse方法的延迟调用版，Supplier 方法只有在Optional对象不含值时才执行调用。如果创建默认值是件耗时费力的工作， 你应该考虑采用这种方式（借此提升程序的性能），或者你需要非常确定某个方法仅在 Optional为空时才进行调用，也可以考虑该方式（这种情况有严格的限制条件）。</li>
<li><code>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code>和get方法非常类似， 它们遭遇Optional对象为空时都会抛出一个异常，但是使用orElseThrow你可以定制希 望抛出的异常类型。</li>
<li><code>ifPresent(Consumer&lt;? super T&gt;)</code>让你能在变量值存在时执行一个作为参数传入的 方法，否则就不进行任何操作。 </li>
</ol>
</li>
</ol>
<h3 id="新的日期和时间API"><a href="#新的日期和时间API" class="headerlink" title="新的日期和时间API"></a>新的日期和时间API</h3><h4 id="LocalDate、LocalTime、Instant、Duration-以及-Period"><a href="#LocalDate、LocalTime、Instant、Duration-以及-Period" class="headerlink" title="LocalDate、LocalTime、Instant、Duration 以及 Period"></a>LocalDate、LocalTime、Instant、Duration 以及 Period</h4><p><strong>LocalDate、LocalTime</strong></p>
<p>通过静态工厂方法of创建一个实例。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">LocalDate</span> localDate <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2021</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">LocalTime</span> localTime <span class="token operator">=</span> <span class="token class-name">LocalTime</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"21:55:32"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//LocalDate.parse("2021-12-12");</span>
<span class="token class-name">LocalDateTime</span> localDateTime1 <span class="token operator">=</span> localDate<span class="token punctuation">.</span><span class="token function">atTime</span><span class="token punctuation">(</span>localTime<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//也有：localTime.atDate(date)</span>
<span class="token class-name">LocalDateTime</span> localDateTime <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">LocalDate</span> localDate1 <span class="token operator">=</span> localDateTime<span class="token punctuation">.</span><span class="token function">toLocalDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//获取LocalDate或LocalTime</span>
localDateTime<span class="token punctuation">.</span><span class="token function">getYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//直接读取</span>
localDateTime<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">ChronoField</span><span class="token punctuation">.</span>DAY_OF_WEEK<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//使用ChronoField读取值  可以读取到各种需要的值</span></code></pre>
<p><strong>机器的日期和时间格式：Instant</strong></p>
<p>你可以通过向静态工厂方法ofEpochSecond传递一个代表秒数的值创建一个该类的实例。</p>
<p>Instant类也支持静态工厂方法now，它能够帮你获取当前时刻的时间戳</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Instant</span><span class="token punctuation">.</span><span class="token function">ofEpochSecond</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从UNIX元年1970年1月1日，往后12秒，再加上32纳秒，第二个参数可以是负数，意思是减去</span></code></pre>
<p><strong>定义 Duration 或 Period</strong></p>
<p>Duration类的静态工厂方法between就是为求两个时间中间差而设计的。可以创建两个LocalTimes对象、两个LocalDateTimes对象，或者两个Instant对象之间的duration。但不能混着创建，比如求LocalDateTimes和Instant对象之间的duration。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Duration</span> d1 <span class="token operator">=</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>time1<span class="token punctuation">,</span> time2<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token class-name">Duration</span> d1 <span class="token operator">=</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>dateTime1<span class="token punctuation">,</span> dateTime2<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token class-name">Duration</span> d2 <span class="token operator">=</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>instant1<span class="token punctuation">,</span> instant2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>但Duration不能求两个LocalDate间的时差，如果你需要以年、月或者日的方式对多个时间单位建模，可以使用Period类。使用该类的工厂方法between，你可以使用得到两个LocalDate之间的时长。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Period</span> tenDays <span class="token operator">=</span> <span class="token class-name">Period</span><span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span><span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Duration和Period类都提供了很多非常方便的工厂类，直接创建对应的实例：</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Duration</span> threeMinutes <span class="token operator">=</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofMinutes</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Duration</span> threeMinutes <span class="token operator">=</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token class-name">ChronoUnit</span><span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Period</span> tenDays <span class="token operator">=</span> <span class="token class-name">Period</span><span class="token punctuation">.</span><span class="token function">ofDays</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Period</span> threeWeeks <span class="token operator">=</span> <span class="token class-name">Period</span><span class="token punctuation">.</span><span class="token function">ofWeeks</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Period</span> twoYearsSixMonthsOneDay <span class="token operator">=</span> <span class="token class-name">Period</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><img src="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210316222100864.png" alt="image-20210316222100864" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210316222143103.png" alt="image-20210316222143103" loading="lazy"></p>
<h4 id="操纵、解析和格式化日期"><a href="#操纵、解析和格式化日期" class="headerlink" title="操纵、解析和格式化日期"></a>操纵、解析和格式化日期</h4><p>这些日期对象比如LocalDate以及其内的年月日属性都是final的，也就是说要修改返回的肯定是一个新的对象，保证了线程安全。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">LocalDate</span> date1 <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">LocalDate</span> date2 <span class="token operator">=</span> date1<span class="token punctuation">.</span><span class="token function">withYear</span><span class="token punctuation">(</span><span class="token number">2011</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2011-03-18</span>
<span class="token class-name">LocalDate</span> date3 <span class="token operator">=</span> date2<span class="token punctuation">.</span><span class="token function">withDayOfMonth</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2011-03-25</span>
<span class="token class-name">LocalDate</span> date4 <span class="token operator">=</span> date3<span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token class-name">ChronoField</span><span class="token punctuation">.</span>MONTH_OF_YEAR<span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2011-09-25</span>

<span class="token class-name">LocalDate</span> date5 <span class="token operator">=</span> date1<span class="token punctuation">.</span><span class="token function">plusWeeks</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2014-3-25</span>
<span class="token class-name">LocalDate</span> date6 <span class="token operator">=</span> date2<span class="token punctuation">.</span><span class="token function">minusYears</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2011-03-25</span>
<span class="token class-name">LocalDate</span> date7 <span class="token operator">=</span> date3<span class="token punctuation">.</span><span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token class-name">ChronoUnit</span><span class="token punctuation">.</span>MONTHS<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2011-09-25</span></code></pre>
<p>像LocalDate、LocalTime、LocalDateTime以及Instant这样表示时间点的日期时间类提供了大量通用的方法的总结：</p>
<p><img src="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210316222644795.png" alt="image-20210316222644795" loading="lazy"></p>
<p><strong>使用 TemporalAdjuster</strong></p>
<p>有的时候，你需要进行一些更加复杂的操作，比如，将日期调整到下个周日、下个工作日，或者是本月的最后一天。这时，使用重载版本的with方法，向其传递一个提供了更多定制化选择的TemporalAdjuster对象，更加灵活地处理日期。最常见的用例，日期和时间API已经提供了大量预定义的TemporalAdjuster。可以通过TemporalAdjuster类的静态工厂方法访问它们，如下所示：</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">LocalDate</span> date1 <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">LocalDate</span> date2 <span class="token operator">=</span> date1<span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token class-name">TemporalAdjusters</span><span class="token punctuation">.</span><span class="token function">nextOrSame</span><span class="token punctuation">(</span><span class="token class-name">DayOfWeek</span><span class="token punctuation">.</span>SUNDAY<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2014-03-23</span>
<span class="token class-name">LocalDate</span> date3 <span class="token operator">=</span> date2<span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token class-name">TemporalAdjusters</span><span class="token punctuation">.</span><span class="token function">lastDayOfMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2014-03-31</span></code></pre>
<p><img src="https://raw.githubusercontent.com/zzugzj/blogImg/master/img/image-20210316223131490.png" alt="image-20210316223131490" loading="lazy"></p>
<p>若是没有从表中找到自己需要的方法，那也可以自己定义TemporalAdjuster。</p>
<p><strong>打印输出及解析日期-时间对象</strong></p>
<p>处理日期和时间对象时，格式化以及解析日期-时间对象是另一个非常重要的功能。新的<code>java.time.format</code>包就是特别为这个目的而设计的。这个包中，最重要的类是<code>DateTime- Formatter</code>。创建格式器最简单的方法是通过它的静态工厂方法以及常量。像<code>ASIC_ISO_DATE</code>和<code>ISO_LOCAL_DATE</code>这样的常量是<code>DateTimeFormatter</code>类的预定义实例。所有的<code>DateTimeFormatter</code>实例都能用于以一定的格式创建代表特定日期或时间的字符串。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">LocalDate</span> date <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token class-name">String</span> s1 <span class="token operator">=</span> date<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span>BASIC_ISO_DATE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//20140318</span>
<span class="token class-name">String</span> s2 <span class="token operator">=</span> date<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span>ISO_LOCAL_DATE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//2014-03-18</span>

<span class="token class-name">LocalDate</span> date1 <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"20140318"</span><span class="token punctuation">,</span> <span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span>BASIC_ISO_DATE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">LocalDate</span> date2 <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"2014-03-18"</span><span class="token punctuation">,</span> <span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span>ISO_LOCAL_DATE<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>所有的DateTimeFormatter实例都是线程安全的。所以，你能够以单例模式创建格式器实例，就像DateTimeFormatter所定义的那些常量，并能在多个线程间共享这些实例。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">DateTimeFormatter</span> formatter <span class="token operator">=</span> <span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"dd/MM/yyyy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">LocalDate</span> date1 <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//  18/03/2014</span>
<span class="token class-name">String</span> formattedDate <span class="token operator">=</span> date1<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>formatter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">LocalDate</span> date2 <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>formattedDate<span class="token punctuation">,</span> formatter<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//特殊格式转LocalDate  2014-03-18</span></code></pre>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/zzugzj/blogImg/master/github/image-20231105141247333.png"><img loading="lazy" src="https://raw.githubusercontent.com/zzugzj/blogImg/master/github/image-20231105141247333.png" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/zzugzj/blogImg/master/github/image-20231105141223394.png"><img loading="lazy" src="https://raw.githubusercontent.com/zzugzj/blogImg/master/github/image-20231105141223394.png" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>gzj</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://zzugzj.github.io/posts/30888651/" title="Java8实战笔记">https://zzugzj.github.io/posts/30888651/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/posts/9617db49/" rel="prev" title="MySQL幻读和可重复读"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">MySQL幻读和可重复读</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/posts/a0d99dad/" rel="next" title="Maven实战笔记"><span class="post-nav-text">Maven实战笔记</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div id="comment"><div class="comment-tooltip text-center"><span>点击按钮跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br><a class="hty-button hty-button--raised" id="github-issues" target="_blank" rel="noopener" href="https://github.com/YunYouJun/yunyoujun.github.io/issues?q=is:issue+Java8实战笔记">GitHub Issues</a></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2021 – 2023 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> gzj</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.3.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.3.0</span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script></body></html>