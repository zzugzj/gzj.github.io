<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL幻读和可重复读</title>
      <link href="posts/9617db49/"/>
      <url>posts/9617db49/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="幻读和可重复读"><a href="#幻读和可重复读" class="headerlink" title="幻读和可重复读"></a>幻读和可重复读</h3><ol><li>由于很多人容易搞混 <code>不可重复读</code> 和 <code>幻读</code>，这两者确实非常相似。<ul><li>但 <code>不可重复读</code> 主要是说多次读取一条记录, 发现该记录中某些列值被修改过。</li><li>而 <code>幻读</code> 主要是说多次读取一个范围内的记录(包括直接查询所有记录结果或者做聚合统计), 发现结果不一致(标准档案一般指记录增多, 记录的减少应该也算是幻读)。(可以参考<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html">MySQL官方文档对 Phantom Rows 的介绍</a>)</li></ul></li><li>其实对于 <code>幻读</code>, MySQL的InnoDB引擎默认的<code>RR</code>级别已经通过<code>MVCC自动帮我们解决了</code>, 所以该级别下, 你也模拟不出幻读的场景; 退回到 <code>RC</code> 隔离级别的话, 你又容易把<code>幻读</code>和<code>不可重复读</code>搞混淆, 所以这可能就是比较头痛的点吧!<br>具体可以参考《高性能MySQL》对 <code>RR</code> 隔离级别的描述, 理论上RR级别是无法解决幻读的问题, 但是由于InnoDB引擎的RR级别还使用了MVCC, 所以也就避免了幻读的出现!</li></ol><p>MVCC虽然解决了<code>幻读</code>问题, 但严格来说只是解决了<strong>部分</strong>幻读问题。</p><p>比如可能会发生这种情况：</p><p>事务A：</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/image-20210412220546067.png" alt="image-20210412220546067" loading="lazy"></p><p>另外一个直接执行：</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/image-20210412220604432.png" alt="image-20210412220604432" loading="lazy"></p><p>就会发生图片上的情况。</p><p>关于第5步可以读出最新数据而且第6步无法插入，是因为select分为当前读和快照读，普通select不加for update是快照读，insert、delete、update都是当前读。</p><h3 id="关于快照读和当前读"><a href="#关于快照读和当前读" class="headerlink" title="关于快照读和当前读"></a>关于快照读和当前读</h3><ul><li><p>快照读, 读取专门的快照</p><pre class="language-none"><code class="language-none">简单的select操作即可(不需要加锁,如: select ... lock in share mode, select ... for update)</code></pre><p>针对的也是select操作</p></li><li><p>当前读, 读取最新版本的记录</p><pre class="language-none"><code class="language-none">select ... lock in share modeselect ... for update</code></pre><p>针对如下操作, 会让如下操作阻塞:    </p><pre class="language-none"><code class="language-none">insertupdatedelete</code></pre></li><li><p>在RR级别下, 快照读是通过MVVC(多版本控制)和undo log来实现的, 当前读是通过手动加record lock(记录锁)和gap lock(间隙锁)来实现的。所以从上面的显示来看，如果需要实时显示数据，还是需要通过加锁来实现。这个时候会使用next-key技术来实现。</p></li></ul><h3 id="SERIALIZABLE隔离级别如何解决幻读"><a href="#SERIALIZABLE隔离级别如何解决幻读" class="headerlink" title="SERIALIZABLE隔离级别如何解决幻读"></a>SERIALIZABLE隔离级别如何解决幻读</h3><p>RR隔离级别可以使用对记录手动加 X锁 的方法消除幻读，比如select … for update等可以加锁，存在则会被加行（X）锁，如果不存在，则会加 next-lock key / gap 锁（范围行锁），即记录存在与否，mysql 都会对记录应该对应的索引加锁，其他事务是无法再获得做操作的。</p><p>另外，使用SERIALIZABLE 隔离级别也可以完全解决幻读，它是对所有事务都加 X锁，不过我们大部分事务都没必要，所以造成了性能浪费</p><p>在此级别下，我们便不需要对 SELECT 操作显式加锁，InnoDB会自动加锁，事务安全，但性能很低</p><h3 id="关于MySQL隔离级别为什么是RR"><a href="#关于MySQL隔离级别为什么是RR" class="headerlink" title="关于MySQL隔离级别为什么是RR"></a>关于MySQL隔离级别为什么是RR</h3><p>众所周知，常见的关系型数据库的默认事务隔离级别采用的是READ_COMMITED，例如PostgreSQL、ORACLE、SQL Server和DB2。但是使用InnoDB引擎的MySQL数据库默认事务隔离级别是REPEATABLE_READ。</p><p>那为什么MySQL要独树一帜的选用RR的隔离级别呢？</p><p>其实这是一个历史遗留问题。</p><p>我们都知道，MySQL的主从复制是基于binlog复制的，在MySQL 5.7.7之前，默认的格式是 <code>STATEMENT</code>，在 MySQL 5.7.7 及更高版本中，默认值是 <code>ROW</code>。日志格式通过 <code>binlog-format</code> 指定。</p><p>binlog目前有三种格式：statement、row、mixed：</p><ul><li><p>statement:记录的是修改SQL语句</p></li><li><p>row：记录的是每行实际数据的变更</p></li><li><p>mixed：statement和row模式的混合</p></li></ul><p>MySQL5.0以前只有statement格式，而这种格式在读已提交(Read Commited)这个隔离级别下主从复制是有bug的，因此Mysql将可重复读(Repeatable Read)作为默认的隔离级别。<br>接下来，就要说说当binlog为STATEMENT格式，且隔离级别为读已提交(Read Commited)时，有什么bug呢？如下图所示，在主(master)上执行如下事务:<br>  <img src="https://gitee.com/gzj1999/blogImg/raw/master/img/c0243ecb466b6f3c7c30c26bb26c757d.png" alt="在这里插入图片描述" loading="lazy"><br> 此时在主库中查询：</p><pre class="language-none"><code class="language-none">select * from t;1</code></pre><p>输出结果：</p><pre class="language-none"><code class="language-none">+---+---+| c1 |c2+---+---+| 2 | 2+---+---+1 row in set</code></pre><p>从库中查询：</p><pre class="language-none"><code class="language-none">select * from t;1</code></pre><p>输出结果：</p><pre class="language-none"><code class="language-none">Empty set1</code></pre><p>这里出现了主从不一致性的问题！原因其实很简单，就是在master上执行的顺序为先删后插！而此时binlog为STATEMENT格式，它记录的顺序为先插后删！从(slave)同步的是binglog，因此从机执行的顺序和主机不一致！就会出现主从不一致！<br>如何解决？<br>解决方案有两种！<br>(1)隔离级别设为可重复读(Repeatable Read),在该隔离级别下引入间隙锁。当Session 1执行delete语句时，会锁住间隙。那么，Ssession 2执行插入语句就会阻塞住！<br>(2)将binglog的格式修改为row格式，此时是基于行的复制，自然就不会出现sql执行顺序不一样的问题！奈何这个格式在mysql5.1版本开始才引入。<br><strong>因此由于历史原因，mysql将默认的隔离级别设为可重复读(Repeatable Read)，保证主从复制不出问题！</strong></p><p>当前这个历史遗漏问题以及解决，大家可以将其设置为RC+ROW组合的方式（例如ORACLE等数据库隔离级别就是RC），而不是必须使用RR（会带来更多的锁等待），具体可以视情况选择。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8实战笔记</title>
      <link href="posts/30888651/"/>
      <url>posts/30888651/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="把Lambda付诸实践：环绕执行模式"><a href="#把Lambda付诸实践：环绕执行模式" class="headerlink" title="把Lambda付诸实践：环绕执行模式"></a>把Lambda付诸实践：环绕执行模式</h3><p>资源处理时常见的一个模式是打开一个资源，做一些处理，然后关闭资源，这个设置和清理阶段类似，并且会围绕着执行处理的业务逻辑。这就是环绕执行模式。</p><p>1）第一步，当需要更改逻辑代码是，需要重写代码，所以想到行为参数化</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">processFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span><span class="token punctuation">(</span><span class="token class-name">BufferedReader</span> bufferedReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"data.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token comment">// return bufferedReader.readLine();</span>    <span class="token keyword">return</span> bufferedReader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> bufferedReader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>2）第二步，使用函数式接口来传递一个行为</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BufferReaderProcessFile</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 方法签名为 BufferReader -> String</span>    <span class="token class-name">String</span> <span class="token function">peocess</span><span class="token punctuation">(</span><span class="token class-name">BufferedReader</span> bufferedReader<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>3）第三步，执一个行为，任何BufferReader -&gt; String的Lambda表达式都可以作为参数传入。只要符合peocess方法的签名即可。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">processFiles</span><span class="token punctuation">(</span><span class="token class-name">BufferReaderProcessFile</span> bufferReaderProcessFile<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span><span class="token keyword">try</span><span class="token punctuation">(</span><span class="token class-name">BufferedReader</span> bufferedReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"data.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> bufferReaderProcessFile<span class="token punctuation">.</span><span class="token function">peocess</span><span class="token punctuation">(</span>bufferedReader<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>4）第四步，传递Lambda</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> string <span class="token operator">=</span> <span class="token function">processFiles</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">BufferedReader</span> bs<span class="token punctuation">)</span> <span class="token operator">-></span> bs<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/image-20210310193142971.png" alt="image-20210310193142971" loading="lazy"></p><h3 id="使用函数式接口"><a href="#使用函数式接口" class="headerlink" title="使用函数式接口"></a>使用函数式接口</h3><p>函数式接口很有用，因为抽象方法的签名可以描述Lambda表达式的签名。函数式接口的抽象方法的签名称为函数描述符。所以为了应用不同的Lambda表达式，需要一套能够描述常见函数描述符的函数式接口。</p><p>Java 8的库设计师在java.util.function包中引入了几个新的函数式接口。</p><p>几个常用的函数式接口：</p><h4 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h4><p>java.util.function.Predicate&lt;T&gt;接口定义了一个名叫test的抽象方法，它接受泛型T对象，并返回一个boolean。这恰恰和你先前创建的一样，现在就可以直接使用了。在需要表示一个涉及类型T的布尔表达式时，就可以使用这个接口。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span> <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Predicate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>     <span class="token keyword">boolean</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> list<span class="token punctuation">,</span> <span class="token class-name">Predicate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> results <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">T</span> s<span class="token operator">:</span> list<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>             results<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span>     <span class="token keyword">return</span> results<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token class-name">Predicate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> nonEmptyStringPredicate <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> nonEmpty <span class="token operator">=</span> <span class="token function">filter</span><span class="token punctuation">(</span>listOfStrings<span class="token punctuation">,</span> nonEmptyStringPredicate<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>java.util.function.Consumer&lt;T&gt;定义了一个名叫accept的抽象方法，它接受泛型T的对象，没有返回（void）。如果需要访问类型T的对象，并对其执行某些操作，就可以使用这个接口。比如，可以用它来创建一个forEach方法，接受一个Integers的列表，并对其中每个元素执行操作。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span> <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>     <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token keyword">void</span> <span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> list<span class="token punctuation">,</span> <span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">T</span> i<span class="token operator">:</span> list<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         c<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span>  <span class="token function">forEach</span><span class="token punctuation">(</span>          <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>         <span class="token punctuation">(</span><span class="token class-name">Integer</span> i<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>         <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><p>java.util.function.Function&lt;T, R&gt;接口定义了一个叫作apply的方法，它接受一个泛型T的对象，并返回一个泛型R的对象。如果需要定义一个Lambda，将输入对象的信息映射到输出，就可以使用这个接口（比如提取苹果的重量，或把字符串映射为它的长度）。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span> <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>     <span class="token class-name">R</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">></span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">></span></span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> list<span class="token punctuation">,</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">></span></span> f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">></span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">T</span> s<span class="token operator">:</span> list<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     <span class="token keyword">return</span> result<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// [7, 2, 6] </span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> l <span class="token operator">=</span> <span class="token function">map</span><span class="token punctuation">(</span>                        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"lambdas"</span><span class="token punctuation">,</span><span class="token string">"in"</span><span class="token punctuation">,</span><span class="token string">"action"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        <span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token operator">-></span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h4><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/image-20210310223646991.png" alt="image-20210310223646991" loading="lazy"></p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/image-20210310223702177.png" alt="image-20210310223702177" loading="lazy"></p><h4 id="一些使用案例"><a href="#一些使用案例" class="headerlink" title="一些使用案例"></a>一些使用案例</h4><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/image-20210310224129130.png" alt="image-20210310224129130" loading="lazy"></p><p><strong>异常，Lambda，还有函数式接口：</strong></p><p><strong>任何的函数式接口都不能抛出受检异常(check exception)，如果你需要lambda 表达式抛出异常，有两种方法：</strong></p><p><strong>定义一个自己的函数式接口，并申明受检异常，或者把Lambda包在一个try/catch块中。</strong></p><h3 id="类型推断、类型检查及限制"><a href="#类型推断、类型检查及限制" class="headerlink" title="类型推断、类型检查及限制"></a>类型推断、类型检查及限制</h3><h4 id="使用局部变量"><a href="#使用局部变量" class="headerlink" title="使用局部变量"></a>使用局部变量</h4><p>Lambda表达式也允许使用自由变量（不是参数，而是在外层作用域中定义的变量），就像匿名类一样。 它们被称作捕获Lambda。例如，下面的Lambda捕获了portNumber变量： </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> portNumber <span class="token operator">=</span> <span class="token number">1337</span><span class="token punctuation">;</span> <span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>portNumber<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>尽管如此，还有一点点小麻烦：关于能对这些变量做什么有一些限制。Lambda可以没有限制地捕获（也就是在其主体中引用）实例变量和静态变量。但局部变量必须显式声明为final，或事实上是final。换句话说，Lambda表达式只能捕获指派给它们的局部变量一次。（注：捕获实例变量可以被看作捕获最终局部变量this。） 例如，下面的代码无法编译，因为portNumber变量被赋值两次： </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> portNumber <span class="token operator">=</span> <span class="token number">1337</span><span class="token punctuation">;</span> <span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>portNumber<span class="token punctuation">)</span><span class="token punctuation">;</span>  portNumber <span class="token operator">=</span> <span class="token number">31337</span><span class="token punctuation">;</span></code></pre><p><strong>对局部变量的限制</strong> </p><p>你可能会问自己，为什么局部变量有这些限制。第一，实例变量和局部变量背后的实现有一个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线程将这个变量收回之后，去访问该变量。因此，Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了这个限制。 </p><p>在JDK8中如果我们在匿名内部类中需要访问局部变量，那么这个局部变量不需要用final修饰符修饰。看似是一种编译机制的改变，实际上就是一个语法糖（底层还是帮你加了final）。但通过反编译没有看到底层为我们加上final，但我们无法改变这个局部变量的引用值，如果改变就会编译报错。</p><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>需要使用方法引用时，目标引用放在分隔符::前，方法的名称放在后面。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/image-20210312103902789.png" alt="image-20210312103902789" loading="lazy"></p><h4 id="如何构建方法引用"><a href="#如何构建方法引用" class="headerlink" title="如何构建方法引用"></a>如何构建方法引用</h4><p>方法引用主要有三类。 </p><p>(1) 指向静态方法的方法引用（例如Integer的parseInt方法，写作Integer::parseInt）。</p><p>(2) 指 向 任 意 类 型 实 例 方 法 的 方 法 引 用 （ 例 如 String 的 length 方 法 ， 写 作String::length）。</p><p>(3) 指向现有对象的实例方法的方法引用（假设你有一个局部变量expensiveTransaction用于存放Transaction类型的对象，它支持实例方法getValue，那么你就可以写expensiveTransaction::getValue）。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/image-20210312105030226.png" alt="image-20210312105030226" loading="lazy"></p><h3 id="复合-Lambda-表达式的有用方法"><a href="#复合-Lambda-表达式的有用方法" class="headerlink" title="复合 Lambda 表达式的有用方法"></a>复合 Lambda 表达式的有用方法</h3><h4 id="比较器复合"><a href="#比较器复合" class="headerlink" title="比较器复合"></a>比较器复合</h4><p>使用静态方法Comparator.comparing，根据提取用于比较的键值的Function来返回一个Comparator</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Apple</span><span class="token punctuation">></span></span> c <span class="token operator">=</span> <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">Apple</span><span class="token operator">::</span><span class="token function">getWeight</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol><li><p>逆序<br> 接口有一个默认方法reversed可以使给定的比较器逆序。因此仍然用开始的那个比较器，只要修改一下前一个例子就可以对苹果按重量递减排序： </p><pre class="language-java" data-language="java"><code class="language-java">inventory<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">Apple</span><span class="token operator">::</span><span class="token function">getWeight</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>比较器链<br>如果发现有两个苹果一样重怎么办？哪个苹果应该排在前面呢？你可能需要再提供一个Comparator来进一步定义这个比较。thenComparing方法就是做这个用的。它接受一个函数作为参数（就像comparing方法一样），如果两个对象用第一个Comparator比较之后是一样的，就提供第二个Comparator。你又可以优雅地解决这个问题了： </p><pre class="language-java" data-language="java"><code class="language-java">inventory<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">Apple</span><span class="token operator">::</span><span class="token function">getWeight</span><span class="token punctuation">)</span>          <span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token punctuation">.</span><span class="token function">thenComparing</span><span class="token punctuation">(</span><span class="token class-name">Apple</span><span class="token operator">::</span><span class="token function">getCountry</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><h4 id="谓词复合"><a href="#谓词复合" class="headerlink" title="谓词复合"></a>谓词复合</h4><p>谓词接口包括三个方法：negate、and和or，可以重用已有的Predicate来创建更复杂的谓词。</p><p>表达要么是重（150克以上）的苹果，要么是绿苹果： </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Predicate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Apple</span><span class="token punctuation">></span></span> redAndHeavyAppleOrGreen <span class="token operator">=</span>     redApple<span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span>a <span class="token operator">-></span> a<span class="token punctuation">.</span><span class="token function">getWeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">150</span><span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">or</span><span class="token punctuation">(</span>a <span class="token operator">-></span> <span class="token string">"green"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>请注意，and和or方法是按照在表达式链中的位置，从左向右确定优先级的。因此，a.or(b).and(c)可以看作(a || b) &amp;&amp; c。</p><h4 id="函数复合"><a href="#函数复合" class="headerlink" title="函数复合"></a>函数复合</h4><p>Function接口为此配了andThen和compose两个默认方法，它们都会返回Function的一个实例。</p><p>andThen方法，会返回一个函数，它先对输入应用一个给定函数，再对输出应用另一个函数。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> f <span class="token operator">=</span> x <span class="token operator">-></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//数学上会写作g(f(x))</span><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> g <span class="token operator">=</span> x <span class="token operator">-></span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> h <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">andThen</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出4</span></code></pre><p>compose方法，先把给定的函数用作compose的参数里面给的那个函数，然后再把函数本身用于结果。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> f <span class="token operator">=</span> x <span class="token operator">-></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//数学上会写作f(g(x))</span><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> g <span class="token operator">=</span> x <span class="token operator">-></span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> h <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">compose</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出3</span></code></pre><h3 id="流与集合"><a href="#流与集合" class="headerlink" title="流与集合"></a>流与集合</h3><h4 id="只能遍历一次"><a href="#只能遍历一次" class="headerlink" title="只能遍历一次"></a>只能遍历一次</h4><p>流和迭代器类似，只能遍历一次。遍历完后，这个流已经被消费掉了。</p><p>可以从原始数据源那里再获得一个新的流来重新遍历一遍，就像迭代器一样（这里假设它是集<br>合之类的可重复的源，如果是I/O通道就没戏了）。</p><h4 id="外部迭代与内部迭代"><a href="#外部迭代与内部迭代" class="headerlink" title="外部迭代与内部迭代"></a>外部迭代与内部迭代</h4><p>使用Collection接口需要用户去做迭代（比如用for-each），这称为外部迭代。 相反， Streams库使用内部迭代，它帮你把迭代做了，还把得到的流值存在了某个地方，你只要给出一个函数说要干什么就可以了。</p><h4 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h4><p>可以连接起来的流操作称为中间操作，关闭流的操作称为终端操作。</p><p>1）中间操作：一般都可以合并起来，在终端操作时一次性全部处理。</p><p>2）终端操作：会从流的流水线生成结果。其结果是任何不是流的值，比如List、Integer，甚<br>至void。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/image-20210313225757611.png" alt="image-20210313225757611" loading="lazy"></p><h3 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h3><p>基本的一些流操作：filter筛选，distinct去重，limit截断，skip跳过</p><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p>1）对流中每一个元素应用函数：流支持map方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素（使用映射一词，是因为它和转换类似，但其中的细微差别在于它是“创建一 个新版本“，而不是去“修改”）。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> dishname <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Dish</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>2）流的扁平化</p><p>flatMap方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。flatmap方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Stream</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> stream <span class="token operator">=</span> list1<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment">//使用flatMap</span>    <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>i <span class="token operator">-></span> list2<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>j <span class="token operator">-></span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>i<span class="token punctuation">,</span> j<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Stream</span><span class="token operator">&lt;</span><span class="token class-name">Stream</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">>></span> stream <span class="token operator">=</span> list1<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//使用map</span>    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>i <span class="token operator">-></span> list2<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>j <span class="token operator">-></span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>i<span class="token punctuation">,</span> j<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h4><p>即把集合中的元素反复结合起来，得到一个值，即将流归约为一个值，用函数式编程语言叫折叠。</p><p>1）元素求和：reduce方法</p><p><strong>reduce接受两个参数：</strong> </p><ol><li>一个初始值，这里是0；</li><li>一个BinaryOperator&lt;T&gt;来将两个元素结合起来产生一个新值。</li></ol><p>在Java 8中，Integer类现在有了一个静态的sum方法来对两个数求和，这恰好是我们想要的，用不着反复用Lambda写同一段代码了： </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> sum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">sum</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>无初始值</strong> </p><p>reduce还有一个重载的变体，它不接受初始值，但是会返回一个Optional对象： </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> sum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>为什么它返回一个Optional&lt;Integer&gt;呢？考虑流中没有任何元素的情况。reduce操作无法返回其和，因为它没有初始值。这就是为什么结果被包裹在一个Optional对象里，以表明和可能不存在。</p><p><strong>map和reduce的连接通常称为map-reduce模式，因Google用它来进行网络搜索而出名，因为它很容易并行化。</strong></p><h4 id="流操作：无状态和有状态"><a href="#流操作：无状态和有状态" class="headerlink" title="流操作：无状态和有状态"></a>流操作：无状态和有状态</h4><ul><li><p>map或filter等操作会从输入流中获取每一个元素，并在输出流中得到0或1个结果。这些操作一般都是无状态无状态的：它们没有内部状态（假设用户提供的Lambda或方法引用没有内部可变状态）。</p></li><li><p>reduce、sum、max等操作需要内部状态来累积结果。在上面的情况下，内部状态很小。在我们的例子里就是一个int或double。不管流中有多少元素要处理，内部状态都是有界的。</p></li><li><p>sort或distinct等操作一开始都和filter和map差不多——都是接受一个流，再生成一个流（中间操作），但有一个关键的区别。从流中排序和删除重复项时都需要知道先前的历史。例如，排序要求所有元素都放入缓冲区后才能给输出流加入一个项目，这一操作的存储要求是无界的。要是流比较大或是无限的，就可能会有问题（把质数流倒序会做什么呢？它应当返回最大的质数，但数学告诉我们它不存在）。我们把这些操作叫作有状态操作。</p></li></ul><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/image-20210314011758437.png" alt="image-20210314011758437" loading="lazy"></p><h4 id="数值流"><a href="#数值流" class="headerlink" title="数值流"></a>数值流</h4><p>我们在前面看到了可以使用reduce方法计算流中元素的总和。例如，你可以像下面这样计算菜单的热量： </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> calories <span class="token operator">=</span> menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Dish</span><span class="token operator">::</span><span class="token function">getCalories</span><span class="token punctuation">)</span>                    <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">sum</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这段代码的问题是，它有一个暗含的装箱成本。每个Integer都必须拆箱成一个原始类型，再进行求和。但 Stream API还提供了原始类型流特化，专门支持处理数值流的方法。</p><h5 id="原始类型流特化"><a href="#原始类型流特化" class="headerlink" title="原始类型流特化"></a>原始类型流特化</h5><p>Java 8引入了三个原始类型特化流接口来解决这个问题：IntStream、DoubleStream和LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的装箱成本。每个接口都带来了进行常用数值归约的新方法，比如对数值流求和的sum，找到最大元素的max。此外还有在必要时再把它们转换回对象流的方法。</p><ol><li><p><strong>映射到数值流</strong></p><p>将流转换为特化版本的常用方法是mapToInt、mapToDouble和mapToLong。这些方法和前面说的map方法的工作方式一样，只是它们返回的是一个特化流，而不是Stream&lt;T&gt;。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> calories <span class="token operator">=</span> menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span><span class="token class-name">Dish</span><span class="token operator">::</span><span class="token function">getCalories</span><span class="token punctuation">)</span>                     <span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里，mapToInt会从每道菜中提取热量（用一个Integer表示），并返回一个IntStream（而不是一个Stream&lt;Integer&gt;）。<strong>如果流是空的，sum默认返回0。</strong>IntStream还支持其他的方便方法，如max、min、average等。</p></li><li><p><strong>转换回对象流</strong></p><p>由于IntStream的map操作接受的Lambda必须接受int并返回int，那有时可能会想把数值流转换回非特化流。</p><p>要把原始流转换成一般流（每个int都会装箱成一个Integer），可以使用boxed方法。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">IntStream</span> intStream <span class="token operator">=</span> menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span><span class="token class-name">Dish</span><span class="token operator">::</span><span class="token function">getCalories</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> stream <span class="token operator">=</span> intStream<span class="token punctuation">.</span><span class="token function">boxed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="数值范围-amp-生成数"><a href="#数值范围-amp-生成数" class="headerlink" title="数值范围&amp;生成数"></a>数值范围&amp;生成数</h5></li></ol><p>Java 8引入了两个可以用于IntStream和LongStream的静态方法，帮助生成这种范围：range和rangeClosed。这两个方法都是第一个参数接受起始值，第二个参数接受结束值。但range是不包含结束值的：<code>[l, r)</code>，而rangeClosed则包含结束值：<code>[l, r]</code>。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">IntStream</span> evenNumbers <span class="token operator">=</span> <span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">rangeClosed</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>   <span class="token comment">//表示范围[1, 100]</span>                <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>n <span class="token operator">-></span> n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>evenNumbers<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//50</span></code></pre><h4 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h4><ul><li><p>由值创建流</p><p>使用静态方法Stream.of，通过显式值创建一个流。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> stream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Java 8 "</span><span class="token punctuation">,</span> <span class="token string">"Lambdas "</span><span class="token punctuation">,</span> <span class="token string">"In "</span><span class="token punctuation">,</span> <span class="token string">"Action"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> stream<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">toUpperCase</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> emptyStream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//空流</span></code></pre></li><li><p>由数组创建流</p><p>Arrays.stream从数组创建一个流。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>由文件生成流</p><p>Java中用于处理文件等I/O操作的NIO API（非阻塞 I/O）已更新，以便利用Stream API。java.nio.file.Files中的很多静态方法都会返回一个流。比如：<code>Files.lines</code>，它会返回一个由指定文件中的各行构成的字符串流。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Pattern</span> pattern <span class="token operator">=</span> <span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">"[a-zA-Z]+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//统计一个英文文件中各个单词出现的次数，并排序</span><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> lines <span class="token operator">=</span> <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">lines</span><span class="token punctuation">(</span><span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"D:/data.txt"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Charset</span><span class="token punctuation">.</span><span class="token function">defaultCharset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">></span></span> collect <span class="token operator">=</span> lines<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>i <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s1 <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> s1<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">final</span> <span class="token class-name">Matcher</span> matcher <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>s1<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            s1<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> matcher<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> matcher<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>i <span class="token operator">-></span> i<span class="token punctuation">,</span> <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">counting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">></span><span class="token punctuation">></span></span> entries <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>collect<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    entries<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">.</span><span class="token function">comparingByValue</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">reverseOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entries<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entries<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mapToLong</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">::</span><span class="token function">getValue</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></code></pre></li><li><p>由函数生成流：创建无限流</p><p>Stream API提供了两个静态方法来从函数生成流：Stream.iterate和Stream.generate。 这两个操作可以创建所谓的无限流：不像从固定集合创建的流那样有固定大小的流。由iterate 和generate产生的流会用给定的函数按需创建值，因此可以无穷无尽地计算下去！<strong>必须使用limit(n)来对这种流加以限制。</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> a <span class="token operator">-></span> a <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>iterate方法接受一个初始值（在这里是0），还有一个依次应用在每个产生的新值上的Lambda（UnaryOperator&lt;t&gt;类型）。</p><p>generate接受一个Supplier&lt;T&gt;类型的Lambda提供新的值。</p></li></ul><h3 id="用流收集数据"><a href="#用流收集数据" class="headerlink" title="用流收集数据"></a>用流收集数据</h3><h4 id="归约和汇总"><a href="#归约和汇总" class="headerlink" title="归约和汇总"></a>归约和汇总</h4><p><strong>maxBy/minBy：</strong>计算流中的最大或最小值。</p><p><strong>summingInt/summingLong/summingDouble：</strong>生成一个用于求元素和的Collector，首先通过给定的mapper将元素转换类型，然后再求和。参数的作用就是将元素转换为指定的类型，最后结果与转换后类型一致。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> i <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">summingInt</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">valueOf</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//list中String转为int求和</span><span class="token keyword">int</span> totalCalories <span class="token operator">=</span> menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">summingInt</span><span class="token punctuation">(</span><span class="token class-name">Dish</span><span class="token operator">::</span><span class="token function">getCalories</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//类获取属性求和</span></code></pre><p><strong>averagingInt/averagingLong/averagingDouble：</strong>生成一个用于求元素平均值的Collector，首选通过参数将元素转换为指定的类型。用法和上面差不多。</p><p><strong>joining：</strong>joining工厂方法返回的收集器会把对流中每一个对象应用toString方法得到的所有字符串连接成一个字符串。在内部使用了StringBuilder来把生成的字符串逐个追加起来。可以指定连接符，甚至是结果的前后缀。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> shortMenu <span class="token operator">=</span> menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Dish</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> shortMenu <span class="token operator">=</span> menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Dish</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> sss <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">,</span><span class="token string">"S"</span><span class="token punctuation">,</span><span class="token string">"E"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="reducing"><a href="#reducing" class="headerlink" title="reducing"></a>reducing</h4><p>我们已经讨论的所有收集器，都是一个可以用reducing工厂方法定义的归约过程的特殊情况而已。Collectors.reducing工厂方法是所有这些特殊情况的一般化。可以说，先前讨论的案例仅仅是为了方便程序员而已。</p><p>它需要三个参数。 </p><ul><li>第一个参数是归约操作的起始值，也是流中没有元素时的返回值，所以很显然对于数值和而言0是一个合适的值。 </li><li>第二个参数就是应用于每个输入值的映射函数。</li><li>第三个参数是一个BinaryOperator，将两个项目累积成一个同类型的值。这里它就是对两个int求和。</li></ul><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>给groupingBy方法传递了一个Function（以方法引用的形式），它提取了流中每 一道Dish的Dish.Type。</p><p>我们把这个Function叫作分类函数，因为它用来把流中的元素分成不同的组。</p><p>分组操作的结果是一个Map，把分组函数返回的值作为映射的键，把流中所有具有这个分类值的项目的列表作为对应的映射值。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/image-20210316090243757.png" alt="image-20210316090243757" loading="lazy"></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> collect <span class="token operator">=</span> lists<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">length</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>多级分组</strong></p><p>要实现多级分组，我们可以使用一个由双参数版本的Collectors.groupingBy工厂方法创建的收集器，它除了普通的分类函数之外，还可以接受collector类型的第二个参数。那么要进行二级分组的话，我们可以把一个内层groupingBy传递给外层groupingBy，并定义一个为流<br>中项目分类的二级标准。</p><pre class="language-java" data-language="java"><code class="language-java">lists<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">hashCode</span><span class="token punctuation">,</span> <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">length</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>按子组收集数据</strong></p><p>groupingBy的第二个参数可以是Collector，所以除了多级分组还有别的用处。</p><p>比如查询某种菜的数量：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Dish<span class="token punctuation">.</span>Type</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">></span></span> typesCount <span class="token operator">=</span> menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">Dish</span><span class="token operator">::</span><span class="token function">getType</span><span class="token punctuation">,</span> <span class="token function">counting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回：&#123;MEAT=3, FISH=2, OTHER=4&#125;</span></code></pre><p><strong>把收集器的结果转换为另一种类型</strong> </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Dish<span class="token punctuation">.</span>Type</span><span class="token punctuation">,</span> <span class="token class-name">Dish</span><span class="token punctuation">></span></span> mostCaloricByType <span class="token operator">=</span> <span class="token class-name">Dish</span><span class="token punctuation">.</span>menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">Dish</span><span class="token operator">::</span><span class="token function">getType</span><span class="token punctuation">,</span>                                <span class="token function">collectingAndThen</span><span class="token punctuation">(</span>                                        <span class="token function">maxBy</span><span class="token punctuation">(</span><span class="token function">comparingInt</span><span class="token punctuation">(</span><span class="token class-name">Dish</span><span class="token operator">::</span><span class="token function">getCalories</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                        <span class="token class-name">Optional</span><span class="token operator">::</span><span class="token function">get</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p>分区是分组的特殊情况：由一个谓词（返回一个布尔值的函数）作为分类函数，它称分区函数。分区函数返回一个布尔值，这意味着得到的分组Map的键类型是Boolean，于是它最多可以分为两组——true是一组，false是一组。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Dish</span><span class="token punctuation">></span><span class="token punctuation">></span></span> partitionedMenu <span class="token operator">=</span>              menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">partitioningBy</span><span class="token punctuation">(</span><span class="token class-name">Dish</span><span class="token operator">::</span><span class="token function">isVegetarian</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="用Optinal取代null"><a href="#用Optinal取代null" class="headerlink" title="用Optinal取代null"></a>用Optinal取代null</h3><p>变量存在时，Optional类只是对类简单封装。变量不存在时，缺失的值会被建模成一个“空” 的Optional对象，由方法<code>Optional.empty()</code>返回。<br><code>Optional.empty()</code>方法是一个静态工厂 方法，它返回Optional类的特定单一实例。：如果你尝试引用一个null，一定会触发NullPointerException，不过使用<code>Optional.empty()</code>就完全没事儿，它是Optional类的一个有效对象，多种场景都能调用，非 常有用。</p><ol><li><p>创建Optional对象</p><ol><li><p>声明一个空的Optional ,可以通过静态工厂方法Optional.empty，创建一个空的Optional 对象： </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Car</span><span class="token punctuation">></span></span> optCar <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>依据一个非空值创建Optional :还可以使用静态工厂方法Optional.of，依据一个非空值创建一个Optional对象： </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Car</span><span class="token punctuation">></span></span> optCar <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>car<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>可接受null的Optional ,使用静态工厂方法Optional.ofNullable，你可以创建一个允许null值的Optional 对象： </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Car</span><span class="token punctuation">></span></span> optCar <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>car<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol></li><li><p>使用map 从 Optional 对象中提取和转换值 </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Insurance</span><span class="token punctuation">></span></span> optInsurance <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>insurance<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> name <span class="token operator">=</span> optInsurance<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Insurance</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>默认行为即解引用的Optional对象</p><ol><li><code>get()</code>是这些方法中最简单但又最不安全的方法。如果变量存在，它直接返回封装的变量 值，否则就抛出一个NoSuchElementException异常。所以，除非你非常确定Optional 变量一定包含值，否则使用这个方法是个相当糟糕的主意。此外，这种方式即便相对于 嵌套式的null检查，也并未体现出多大的改进。</li><li><code>orElse(T other)</code>它允许你在 Optional对象不包含值时提供一个默认值。</li><li><code>orElseGet(Supplier&lt;? extends T&gt; other)</code>是orElse方法的延迟调用版，Supplier 方法只有在Optional对象不含值时才执行调用。如果创建默认值是件耗时费力的工作， 你应该考虑采用这种方式（借此提升程序的性能），或者你需要非常确定某个方法仅在 Optional为空时才进行调用，也可以考虑该方式（这种情况有严格的限制条件）。</li><li><code>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code>和get方法非常类似， 它们遭遇Optional对象为空时都会抛出一个异常，但是使用orElseThrow你可以定制希 望抛出的异常类型。</li><li><code>ifPresent(Consumer&lt;? super T&gt;)</code>让你能在变量值存在时执行一个作为参数传入的 方法，否则就不进行任何操作。 </li></ol></li></ol><h3 id="新的日期和时间API"><a href="#新的日期和时间API" class="headerlink" title="新的日期和时间API"></a>新的日期和时间API</h3><h4 id="LocalDate、LocalTime、Instant、Duration-以及-Period"><a href="#LocalDate、LocalTime、Instant、Duration-以及-Period" class="headerlink" title="LocalDate、LocalTime、Instant、Duration 以及 Period"></a>LocalDate、LocalTime、Instant、Duration 以及 Period</h4><p><strong>LocalDate、LocalTime</strong></p><p>通过静态工厂方法of创建一个实例。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">LocalDate</span> localDate <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2021</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">LocalTime</span> localTime <span class="token operator">=</span> <span class="token class-name">LocalTime</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"21:55:32"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//LocalDate.parse("2021-12-12");</span><span class="token class-name">LocalDateTime</span> localDateTime1 <span class="token operator">=</span> localDate<span class="token punctuation">.</span><span class="token function">atTime</span><span class="token punctuation">(</span>localTime<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//也有：localTime.atDate(date)</span><span class="token class-name">LocalDateTime</span> localDateTime <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">LocalDate</span> localDate1 <span class="token operator">=</span> localDateTime<span class="token punctuation">.</span><span class="token function">toLocalDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//获取LocalDate或LocalTime</span>localDateTime<span class="token punctuation">.</span><span class="token function">getYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//直接读取</span>localDateTime<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">ChronoField</span><span class="token punctuation">.</span>DAY_OF_WEEK<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//使用ChronoField读取值  可以读取到各种需要的值</span></code></pre><p><strong>机器的日期和时间格式：Instant</strong></p><p>你可以通过向静态工厂方法ofEpochSecond传递一个代表秒数的值创建一个该类的实例。</p><p>Instant类也支持静态工厂方法now，它能够帮你获取当前时刻的时间戳</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Instant</span><span class="token punctuation">.</span><span class="token function">ofEpochSecond</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从UNIX元年1970年1月1日，往后12秒，再加上32纳秒，第二个参数可以是负数，意思是减去</span></code></pre><p><strong>定义 Duration 或 Period</strong></p><p>Duration类的静态工厂方法between就是为求两个时间中间差而设计的。可以创建两个LocalTimes对象、两个LocalDateTimes对象，或者两个Instant对象之间的duration。但不能混着创建，比如求LocalDateTimes和Instant对象之间的duration。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Duration</span> d1 <span class="token operator">=</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>time1<span class="token punctuation">,</span> time2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">Duration</span> d1 <span class="token operator">=</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>dateTime1<span class="token punctuation">,</span> dateTime2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">Duration</span> d2 <span class="token operator">=</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>instant1<span class="token punctuation">,</span> instant2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>但Duration不能求两个LocalDate间的时差，如果你需要以年、月或者日的方式对多个时间单位建模，可以使用Period类。使用该类的工厂方法between，你可以使用得到两个LocalDate之间的时长。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Period</span> tenDays <span class="token operator">=</span> <span class="token class-name">Period</span><span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span><span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Duration和Period类都提供了很多非常方便的工厂类，直接创建对应的实例：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Duration</span> threeMinutes <span class="token operator">=</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofMinutes</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Duration</span> threeMinutes <span class="token operator">=</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token class-name">ChronoUnit</span><span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Period</span> tenDays <span class="token operator">=</span> <span class="token class-name">Period</span><span class="token punctuation">.</span><span class="token function">ofDays</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Period</span> threeWeeks <span class="token operator">=</span> <span class="token class-name">Period</span><span class="token punctuation">.</span><span class="token function">ofWeeks</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Period</span> twoYearsSixMonthsOneDay <span class="token operator">=</span> <span class="token class-name">Period</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/image-20210316222100864.png" alt="image-20210316222100864" loading="lazy"></p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/image-20210316222143103.png" alt="image-20210316222143103" loading="lazy"></p><h4 id="操纵、解析和格式化日期"><a href="#操纵、解析和格式化日期" class="headerlink" title="操纵、解析和格式化日期"></a>操纵、解析和格式化日期</h4><p>这些日期对象比如LocalDate以及其内的年月日属性都是final的，也就是说要修改返回的肯定是一个新的对象，保证了线程安全。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">LocalDate</span> date1 <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">LocalDate</span> date2 <span class="token operator">=</span> date1<span class="token punctuation">.</span><span class="token function">withYear</span><span class="token punctuation">(</span><span class="token number">2011</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2011-03-18</span><span class="token class-name">LocalDate</span> date3 <span class="token operator">=</span> date2<span class="token punctuation">.</span><span class="token function">withDayOfMonth</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2011-03-25</span><span class="token class-name">LocalDate</span> date4 <span class="token operator">=</span> date3<span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token class-name">ChronoField</span><span class="token punctuation">.</span>MONTH_OF_YEAR<span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2011-09-25</span><span class="token class-name">LocalDate</span> date5 <span class="token operator">=</span> date1<span class="token punctuation">.</span><span class="token function">plusWeeks</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2014-3-25</span><span class="token class-name">LocalDate</span> date6 <span class="token operator">=</span> date2<span class="token punctuation">.</span><span class="token function">minusYears</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2011-03-25</span><span class="token class-name">LocalDate</span> date7 <span class="token operator">=</span> date3<span class="token punctuation">.</span><span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token class-name">ChronoUnit</span><span class="token punctuation">.</span>MONTHS<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2011-09-25</span></code></pre><p>像LocalDate、LocalTime、LocalDateTime以及Instant这样表示时间点的日期时间类提供了大量通用的方法的总结：</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/image-20210316222644795.png" alt="image-20210316222644795" loading="lazy"></p><p><strong>使用 TemporalAdjuster</strong></p><p>有的时候，你需要进行一些更加复杂的操作，比如，将日期调整到下个周日、下个工作日，或者是本月的最后一天。这时，使用重载版本的with方法，向其传递一个提供了更多定制化选择的TemporalAdjuster对象，更加灵活地处理日期。最常见的用例，日期和时间API已经提供了大量预定义的TemporalAdjuster。可以通过TemporalAdjuster类的静态工厂方法访问它们，如下所示：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">LocalDate</span> date1 <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">LocalDate</span> date2 <span class="token operator">=</span> date1<span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token class-name">TemporalAdjusters</span><span class="token punctuation">.</span><span class="token function">nextOrSame</span><span class="token punctuation">(</span><span class="token class-name">DayOfWeek</span><span class="token punctuation">.</span>SUNDAY<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2014-03-23</span><span class="token class-name">LocalDate</span> date3 <span class="token operator">=</span> date2<span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token class-name">TemporalAdjusters</span><span class="token punctuation">.</span><span class="token function">lastDayOfMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2014-03-31</span></code></pre><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/image-20210316223131490.png" alt="image-20210316223131490" loading="lazy"></p><p>若是没有从表中找到自己需要的方法，那也可以自己定义TemporalAdjuster。</p><p><strong>打印输出及解析日期-时间对象</strong></p><p>处理日期和时间对象时，格式化以及解析日期-时间对象是另一个非常重要的功能。新的<code>java.time.format</code>包就是特别为这个目的而设计的。这个包中，最重要的类是<code>DateTime- Formatter</code>。创建格式器最简单的方法是通过它的静态工厂方法以及常量。像<code>ASIC_ISO_DATE</code>和<code>ISO_LOCAL_DATE</code>这样的常量是<code>DateTimeFormatter</code>类的预定义实例。所有的<code>DateTimeFormatter</code>实例都能用于以一定的格式创建代表特定日期或时间的字符串。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">LocalDate</span> date <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">String</span> s1 <span class="token operator">=</span> date<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span>BASIC_ISO_DATE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//20140318</span><span class="token class-name">String</span> s2 <span class="token operator">=</span> date<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span>ISO_LOCAL_DATE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//2014-03-18</span><span class="token class-name">LocalDate</span> date1 <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"20140318"</span><span class="token punctuation">,</span> <span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span>BASIC_ISO_DATE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">LocalDate</span> date2 <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"2014-03-18"</span><span class="token punctuation">,</span> <span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span>ISO_LOCAL_DATE<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>所有的DateTimeFormatter实例都是线程安全的。所以，你能够以单例模式创建格式器实例，就像DateTimeFormatter所定义的那些常量，并能在多个线程间共享这些实例。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">DateTimeFormatter</span> formatter <span class="token operator">=</span> <span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"dd/MM/yyyy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">LocalDate</span> date1 <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//  18/03/2014</span><span class="token class-name">String</span> formattedDate <span class="token operator">=</span> date1<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>formatter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">LocalDate</span> date2 <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>formattedDate<span class="token punctuation">,</span> formatter<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//特殊格式转LocalDate  2014-03-18</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven实战笔记</title>
      <link href="posts/a0d99dad/"/>
      <url>posts/a0d99dad/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第二章-Maven使用入门"><a href="#第二章-Maven使用入门" class="headerlink" title="第二章 Maven使用入门"></a>第二章 Maven使用入门</h1><h2 id="编写POM"><a href="#编写POM" class="headerlink" title="编写POM"></a>编写POM</h2><p>POM(Project Object Model， 项目对象模型)定义了项目的基本信息，用于描述项目如何构建，声明项目依赖等等。</p><p>实例：</p><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8" ?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0    http://maven.apache.org/maven-v4_0_0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.gzj.testMaven<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>hello-world<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>my maven project<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><p>第一行是XML头，指定了文档版本和编码方式。后面的project是所有pom.xml的根元素，它还声明了一些POM相关的命名空间和xsd元素，可以帮助我们快速编辑POM。</p><p>modelVersion：指定当前POM模型的版本，对于Maven2和Maven3来说，它只能是4.0.0。</p><p>groupId，artifactId，version这三个元素定义了一个项目的基本坐标。</p><ul><li><p>groupId：定义了项目属于那个组，这个组和项目所在的组织或公司存在关联。</p></li><li><p>artifactId：定义了当前项目在组的唯一ID，因为可能有不同的子模块，所以要分配不同的artifactId。</p></li><li><p>version：指定了项目的当前版本。</p></li></ul><p>name：声明一个对用户更友好的项目名称，虽然不必须，但推荐写，方便信息交流。</p><h2 id="编写主代码"><a href="#编写主代码" class="headerlink" title="编写主代码"></a>编写主代码</h2><p>项目主代码和测试代码不同，项目的主代码会被打包，而测试代码只会在运行测试时用到，不会被打包。默认情况下，maven约定项目的主代码位于src/main/java目录。</p><p>代码编写完毕后，使用Maven编译，在项目根目录下运行mvn clean compile。</p><p>clean是告诉maven清除输出目录target/，compile告诉maven编译项目主代码。</p><h2 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h2><p>测试代码位于src/test/java目录。测试一般使用JUnit，需要在pom文件新增一个JUnit依赖。</p><pre class="language-xml" data-language="xml"><code class="language-xml">新增：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><p>dependencies元素下可以包含多个dependency元素以声明项目的依赖。前面我们提到通过groupId，artifactId，version是任何一个maven项目最基本的坐标，JUnit也是，有了这段声明，maven就能自动下载JUnit。</p><p>上述POM代码还有一个值为test的元素scope，代表依赖范围，若依赖范围是test表示该依赖只对测试有效，就是在测试代码用是没有问题，但在主代码用就会编译错误。如果不声明依赖范围，那么默认值就是compile，表示对主代码和测试代码都有效。</p><p>编写完毕后调用Maven执行测试，运行mvn clean test。</p><p>有时maven输出提示我们需要使用 -source 5或更高版本，这时可能是maven核心插件的compiler插件默认支持编译的Java版本低，要改成支持Java5的版本。</p><p>在pom文件添加：</p><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-compiler-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span><span class="token punctuation">></span></span>1.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>source</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span><span class="token punctuation">></span></span>1.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span></code></pre><h2 id="打包和运行"><a href="#打包和运行" class="headerlink" title="打包和运行"></a>打包和运行</h2><p>若没有指定打包类型的话，默认打包类型是jar，可以执行命令mvn clean package进行打包。</p><p>打包完毕后，可以在target/输出目录中看见，名称是根据artifactId-version.jar进行命名的。</p><p>如果想让其他的Maven项目直接引用这个jar，可以把它安装到maven仓库，执行mvn clean install就会把它安装到Maven本地仓库中。</p><p>虽然项目中有的类含有main方法，但默认打包生成的jar不能直接运行，因为带有main方法的类信息不会添加到manifest中(jar文件的<em>META-INF/MANIFEST.MF</em>文件)。</p><p>若要生成可执行的jar文件，需要借助maven-shade-plugin插件：</p><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-shade-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.2.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">></span></span>package<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>shade<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformers</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.ManifestResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mainClass</span><span class="token punctuation">></span></span>com.gzj.testMaven.Main<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mainClass</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformers</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span></code></pre><p>配置mainClass为com.gzj.testMaven.Main，项目打包时就会把信息放到MANIFEST中。执行mvn clean install，构建完成后打开target/目录，可以看到hello-world-1.0-SNAPSHOT.jar和original-hello-world-1.0-SNAPSHOT.jar两个文件，前者是带有Main-Class信息的可运行jar，后者是原始的jar，打开hello-world-1.0-SNAPSHOT.jar的MANIFEST.MF可以看到多了<code>Main-Class: com.gzj.testMaven.Main</code>这一行信息。</p><h2 id="使用Archetype生成项目骨架"><a href="#使用Archetype生成项目骨架" class="headerlink" title="使用Archetype生成项目骨架"></a>使用Archetype生成项目骨架</h2><p>每次构建项目时都要自己创建pom文件和src/main/java等一些固定的包，会让我们感到很繁琐，通过maven archetype可以快速创建项目的骨架。</p><p>输入maven archetype后，会先让我们选择archetype，然后输入项目的groupId、artifactId、version和package，完了后确认就生成成功了。</p><p>默认生成的pom.xml包含一个junit依赖，主代码和测试代码已被创建。</p><h1 id="第三章-坐标和依赖"><a href="#第三章-坐标和依赖" class="headerlink" title="第三章 坐标和依赖"></a>第三章 坐标和依赖</h1><h2 id="何为Maven坐标"><a href="#何为Maven坐标" class="headerlink" title="何为Maven坐标"></a>何为Maven坐标</h2><p>界上任何一个JAR包或者WAR包都可以使用Maven坐标唯一标识，Maven坐标的元素包括groupId、artifactId、version和classifier等。只要我们提供了正确的坐标元素，Maven就能找到对应的JAR包或者WAR包。</p><h2 id="坐标详解"><a href="#坐标详解" class="headerlink" title="坐标详解"></a>坐标详解</h2><p>groupId：定义当前Maven项目隶属的实际项目；我们要明白的是Maven项目和实际项目不一定是一对一的关系。这是由于Maven中模块的概念，因此实际项目往往会被划分成很多模块。groupId和我们在Java中定义顶级包名的规则是一样的，通常与公司或者组织的域名反向一一对应。</p><p>artifactId：该元素定义实际项目中的一个Maven项目（模块），一般推荐的做法是使用实际项目名称作为artifactId的前缀，比如spring-core的前缀是spring一样。</p><p>version：该元素定义Maven项目当前所处的版本。</p><p>packaging：定义Maven项目的打包方式，打包方式会影响到构建的生命周期，jar打包和war打包使用不同的命令。不定义packaging的时候，Maven默认使用jar。</p><p>classifier：该元素帮助定义构建输出的一些附属构件。比如主构件是nexus-indexer-2.0.0.jar，可能使用插件生成nexus-indexer-2.0.0-javadoc.jar，nexus-indexer-2.0.0-sources.jar等附属构件。javadoc和sources就是这两个附属构件的classifier。这样附属构件也有了自己唯一的坐标。</p><p>在项目中，groupId、artifactId、version是必须定义的，packaging是可选的（默认jar），而classifier是不能直接定义的。</p><p>同时，项目构件的文件名是与坐标相对应的，一般是artifactId-version[-classifier].packaging，[-classifier]表示可选。</p><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>Maven在编译项目主代码的时候要使用一套classpath，在编译和执行测试时会使用另外一套classpath，实际运行Maven项目的时候，又会使用一套classpath。</p><p>依赖范围就是控制依赖与这三种classpath的关系，Maven有以下几种依赖范围：</p><ul><li>Compile：编译依赖范围。如果没有指定，就会默认使用该依赖范围。该依赖范围的依赖，对于编译、测试、运行这三种classpath都有效。</li><li>Test：测试依赖范围。使用此依赖范围的Maven依赖，只对测试calsspath有效，在编译主代码或运行项目时无法使用。</li><li>Provided：已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但运行时无效。比如servlet-api，编译测试用，但运行时容器已经提供，不需要Maven再导入。</li><li>Runtime：运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但编译主代码无效。比如JDBC驱动实现，主代码只需要JDK提供的JDBC接口，只有在执行测试或运行实际项目的时候才需要实现上述接口的具体JDBC驱动。</li><li>Ststem：系统依赖范围。该依赖与三种classpath的关系和Provided依赖范围完全一致。但使用System范围的依赖必须通过systemPath元素显式指定依赖文件的路径。此类依赖不是通过Maven仓库解析，往往与本机系统绑定，可能造成构建的不可移植，谨慎使用。systemPath元素可以引用环境变量。</li><li>Import（Maven2.0.9及以上）：导入依赖范围。该依赖范围不会test、compile、runtime的 classpath 产生实际的影响。它的作用是将其他模块定义好的 dependencyManagement 导入当前 Maven 项目 pom 的 dependencyManagement 中。</li></ul><h2 id="传递性依赖"><a href="#传递性依赖" class="headerlink" title="传递性依赖"></a>传递性依赖</h2><h3 id="何为传递性依赖"><a href="#何为传递性依赖" class="headerlink" title="何为传递性依赖"></a>何为传递性依赖</h3><p>例如：A.jar依赖于B.jar，而B.jar依赖于C.jar，那要使A.jar 依赖于C.jar 当且仅当C.jar的范围是compile。</p><p>有了Maven的传递性依赖机制，不用担心引入多余的依赖。 Maven会解析各个直接依赖的POM, 将那些必要的间接依赖，以传递性依赖的形式引入到当前的项目中。</p><h3 id="传递性依赖和依赖范围"><a href="#传递性依赖和依赖范围" class="headerlink" title="传递性依赖和依赖范围"></a>传递性依赖和依赖范围</h3><p>假设A依赖于B，B依赖于C，那么A对于B是第一直接依赖，B对于C是第二直接依赖，A对于C是传递性依赖。第一直接依赖的范围和第二直接依赖的范围决定了传递性依赖的范围。</p><p> 如下图： 最左边一列表示第一直接依赖范围， 最上面一行表示第二直接依赖范围， 中间交叉单元格则表示传递性依赖的范围。</p><table><thead><tr><th></th><th>compile</th><th>test</th><th>provided</th><th>runtime</th></tr></thead><tbody><tr><td>compile</td><td>compile</td><td>—</td><td>—</td><td>runtime</td></tr><tr><td>test</td><td>test</td><td>—</td><td>—</td><td>test</td></tr><tr><td>provided</td><td>provided</td><td>—</td><td>provided</td><td>provided</td></tr><tr><td>runtime</td><td>runtime</td><td>—</td><td>—</td><td>runtime</td></tr></tbody></table><p>通过上表可以发现规律：当第二直接依赖的范围是compile的时候，传递性依赖与第一直接依赖的范围一致； 当第二直接依赖的范围是test的时候，依赖不会得以传递；当第二直接依赖是provided的时候，值传递第一直接依赖范围也为provided的依赖，且传递性依赖范围同样为provided; 当第二依赖的范围是runtime的时候，传递性范围与第一直接依赖的范围一致，但compile例外，此时传递性依赖的范围为runtime。</p><h3 id="依赖调解"><a href="#依赖调解" class="headerlink" title="依赖调解"></a>依赖调解</h3><p>大部分情况下，通过Maven的依赖传递机制，我们只需要关心项目的直接依赖是什么，但有时候，传递性依赖也会造成一些问题。</p><p>比如项目A有这样的依赖关系：A-&gt;B-&gt;C-&gt;X(1.0), A-&gt;D-&gt;X(2.0), X是A的传递性依赖，但是两条依赖路径上有两个版本的X，这时，Maven会进行依赖调解，根据==路径最近者优先==的调解原则，该例中X(1.0)的路径长度为3，而X(2.0)的路径长度为2，因此X(2.0)会被解析使用。</p><p>但这种情况不能解决所有问题，如果路径长度一样的情况下，在Maven2.0.8及之前的版本中，这时不确定的，但从Maven2.0.9版本开始，Maven定义了依赖调解的第二原则：==第一声明者优先==。在依赖路径长度相同的情况下，在POM中依赖声明的顺序决定了谁会被解析使用，顺序最靠前的那个依赖优胜。</p><h3 id="可选依赖"><a href="#可选依赖" class="headerlink" title="可选依赖"></a>可选依赖</h3><p>假设有这样一个依赖关系，项目A依赖于项目B,项目B依赖于项目X和Y, B对于X和Y的依赖都是可选依赖： A-&gt;B, B-&gt;X(可选)，B-&gt;Y(可选)。 根据传递性依赖的定义，如果所有这三个依赖的范围都是compile,那么X, Y就是A的compile范围传递性依赖。然而，由于这里X,Y是可选依赖，依赖将不会得以传递。换句话说，X,Y将不会对A有任何影响。</p><p>可选依赖可以解决如下情况，如果项目B实现了两个特性，一个特性依赖于X，另一个依赖于Y，这两个特性互斥，比如B是一个持久层工具包，支持X和Y数据库，那构建B工具包时需要这两个依赖，但使用时只会用到一个。</p><p>可选依赖配置：</p><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.1.10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>postgresql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>postgresql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>8.4-701.jgbc3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><p>optional：这个元素表示mysql-connector-java和postgresql这两个依赖为可选依赖，它们只会对当前项目B产生影响，当其他项目依赖于B的时候，这两个依赖不会被传递。</p><p>因此，当项目A依赖于项目B的时候，如果其实际使用基于MySQL数据，那么项目A中就需要显示的声明mysql-connetor-java这一依赖，如下：</p><pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.rogueq.mvnbook<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>project-b<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.1.10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><p>但理想情况不应该使用可选依赖，根据单一职责原则，在上述例子中，最好是根据Mysql和PostgreSQL分别创建Maven项目，分配不同artifactId，直接声明JDBC驱动依赖，不使用可选依赖。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatisPlus笔记</title>
      <link href="posts/13667b25/"/>
      <url>posts/13667b25/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>版本：3.4.1</p><h2 id="mybatis-plus的yml常用配置"><a href="#mybatis-plus的yml常用配置" class="headerlink" title="mybatis-plus的yml常用配置"></a>mybatis-plus的yml常用配置</h2><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span>  <span class="token comment"># Mapper.xml 文件位置 Maven 多模块项目的扫描路径需以 classpath*: 开头</span>  <span class="token key atrule">mapperLocations</span><span class="token punctuation">:</span> classpath<span class="token important">*:com/vanhr/**/xml/*Mapper.xml</span><span class="token comment">#  #通过父类（或实现接口）的方式来限定扫描实体</span><span class="token comment">#  typeAliasesSuperType: com.vanhr.user.dao.entity.baseEntity</span><span class="token comment">#  #枚举类 扫描路径 如果配置了该属性，会将路径下的枚举类进行注入，让实体类字段能够简单快捷的使用枚举属性</span><span class="token comment">#  typeEnumsPackage: com.vanhr.user.dao.enums</span><span class="token comment">#  #通过该属性可指定 MyBatis 的执行器，MyBatis 的执行器总共有三种：</span><span class="token comment">#  # ExecutorType.SIMPLE：该执行器类型不做特殊的事情，为每个语句的执行创建一个新的预处理语句（PreparedStatement）</span><span class="token comment">#  # ExecutorType.REUSE：该执行器类型会复用预处理语句（PreparedStatement）</span><span class="token comment">#  # ExecutorType.BATCH：该执行器类型会批量执行所有的更新语句</span><span class="token comment">#  executorType: SIMPLE</span><span class="token comment">#  # 指定外部化 MyBatis Properties 配置，通过该配置可以抽离配置，实现不同环境的配置部署</span><span class="token comment">#  configurationProperties:</span>  <span class="token key atrule">configuration</span><span class="token punctuation">:</span> <span class="token comment"># MyBatis 原生支持的配置</span>    <span class="token key atrule">log-impl</span><span class="token punctuation">:</span> org.apache.ibatis.logging.stdout.StdOutImpl <span class="token comment">#日志输出</span>    <span class="token comment"># 是否开启自动驼峰命名规则（camel case）映射</span>    <span class="token key atrule">mapUnderscoreToCamelCase</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token comment"># 枚举处理类,如果配置了该属性,枚举将统一使用指定处理器进行处理</span>    <span class="token comment">#   org.apache.ibatis.type.EnumTypeHandler : 存储枚举的名称</span>    <span class="token comment">#   org.apache.ibatis.type.EnumOrdinalTypeHandler : 存储枚举的索引</span>    <span class="token comment">#   com.baomidou.mybatisplus.extension.handlers.MybatisEnumTypeHandler : 枚举类需要实现IEnum接口或字段标记@EnumValue注解.(3.1.2以下版本为EnumTypeHandler)</span><span class="token comment">#    defaultEnumTypeHandler: com.baomidou.mybatisplus.extension.handlers.MybatisEnumTypeHandler</span>    <span class="token comment"># 配置JdbcTypeForNull, oracle数据库必须配置</span>    <span class="token key atrule">jdbc-type-for-null</span><span class="token punctuation">:</span> <span class="token null important">null</span>  <span class="token key atrule">global-config</span><span class="token punctuation">:</span> <span class="token comment"># 全局策略配置</span>    <span class="token comment"># 是否控制台 print mybatis-plus 的 LOGO</span>    <span class="token key atrule">banner</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>    <span class="token key atrule">db-config</span><span class="token punctuation">:</span>      <span class="token comment"># id类型</span>      <span class="token key atrule">id-type</span><span class="token punctuation">:</span> auto      <span class="token comment"># 表名是否使用下划线命名，默认数据库表使用下划线命名</span>      <span class="token key atrule">table-underline</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>      <span class="token comment">#是否开启大写命名，默认不开启</span><span class="token comment">#      capital-mode: false</span><span class="token comment">#      #逻辑已删除值,(逻辑删除下有效) 需要注入逻辑策略LogicSqlInjector 以@Bean方式注入</span><span class="token comment">#      logic-not-delete-value: 0</span><span class="token comment">#      #逻辑未删除值,(逻辑删除下有效)</span><span class="token comment">#      logic-delete-value: 1</span></code></pre><h2 id="crud操作"><a href="#crud操作" class="headerlink" title="crud操作"></a>crud操作</h2><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><pre class="language-none"><code class="language-none">@SpringBootTestpublic class CRUDTests &#123;    @Autowired    private UserMapper userMapper;    @Test    public void testInsert()&#123;        User user &#x3D; new User();        user.setName(&quot;Helen&quot;);        user.setAge(18);        user.setEmail(&quot;55317332@qq.com&quot;);        int result &#x3D; userMapper.insert(user);        System.out.println(result); &#x2F;&#x2F;影响的行数        System.out.println(user); &#x2F;&#x2F;id自动回填    &#125;&#125;</code></pre><h4 id="插入时的主键策略"><a href="#插入时的主键策略" class="headerlink" title="插入时的主键策略"></a>插入时的主键策略</h4><p>MP 支持多种主键策略 默认是推特的“雪花算法“ ，也可以设置其他策略。</p><p><strong>IdType</strong></p><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">AUTO</td><td align="center">数据库ID自增</td></tr><tr><td align="center">NONE</td><td align="center">无状态,该类型为未设置主键类型(注解里等于跟随全局,全局里约等于 INPUT)，默认根据雪花算法生成</td></tr><tr><td align="center">INPUT</td><td align="center">insert前自行set主键值</td></tr><tr><td align="center">ASSIGN_ID</td><td align="center">分配ID(主键类型为Number(Long和Integer)或String)(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextId</code>(默认实现类为<code>DefaultIdentifierGenerator</code>雪花算法)</td></tr><tr><td align="center">ASSIGN_UUID</td><td align="center">分配UUID,主键类型为String(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextUUID</code>(默认default方法)</td></tr></tbody></table><p><strong>相关资料：分布式系统唯一ID生成方案汇总：</strong><a href="https://www.cnblogs.com/haoxinyue/p/5208136.html">https://www.cnblogs.com/haoxinyue/p/5208136.html</a></p><p>要想影响所有实体的配置，可以设置全局主键配置</p><pre class="language-none"><code class="language-none">#全局设置主键生成策略mybatis-plus.global-config.db-config.id-type&#x3D;auto</code></pre><h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><h4 id="根据Id更新操作"><a href="#根据Id更新操作" class="headerlink" title="根据Id更新操作"></a>根据Id更新操作</h4><p><strong>注意：</strong>update时生成的sql自动是动态sql：UPDATE user SET age=? WHERE id=? </p><pre class="language-none"><code class="language-none">@Testpublic void testUpdateById()&#123;    User user &#x3D; new User();    user.setId(1L);    user.setAge(28);    int result &#x3D; userMapper.updateById(user);    System.out.println(result);&#125;</code></pre><h4 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h4><p>项目中经常会遇到一些数据，每次都使用相同的方式填充，例如记录的创建时间，更新时间等。</p><p>我们可以使用MyBatis Plus的自动填充功能，完成这些字段的赋值工作：</p><p>首先在实体上添加注解<code>@TableField(fill = FieldFill.INSERT)</code>，然后实现元对象处理器接口，不要在类上忘记添加 @Component 注解。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyMetaObjectHandler</span> <span class="token keyword">implements</span> <span class="token class-name">MetaObjectHandler</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertFill</span><span class="token punctuation">(</span><span class="token class-name">MetaObject</span> metaObject<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//插入操作</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"createTime"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"updateTime"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateFill</span><span class="token punctuation">(</span><span class="token class-name">MetaObject</span> metaObject<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//更新操作</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"updateTime"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>FieldFill类的一些属性：</p><pre class="language-none"><code class="language-none">&#x2F;*** 默认不处理*&#x2F;DEFAULT,&#x2F;*** 插入时填充字段*&#x2F;INSERT,&#x2F;*** 更新时填充字段*&#x2F;UPDATE,&#x2F;*** 插入和更新时填充字段*&#x2F;INSERT_UPDATE</code></pre><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p><strong>OptimisticLockerInnerInterceptor</strong></p><blockquote><p>当要更新一条记录的时候，希望这条记录没有被别人更新<br>乐观锁实现方式：</p><blockquote><ul><li>取出记录时，获取当前version</li><li>更新时，带上这个version</li><li>执行更新时， set version = newVersion where version = oldVersion</li><li>如果version不对，就更新失败</li></ul></blockquote></blockquote><p>首先数据库表要加version字段，然后字段上加上<code>@Version</code>注解，然后元对象处理器接口添加version的insert默认值。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Version</span><span class="token annotation punctuation">@TableField</span><span class="token punctuation">(</span>fill <span class="token operator">=</span> <span class="token class-name">FieldFill</span><span class="token punctuation">.</span>INSERT<span class="token punctuation">)</span><span class="token comment">//也可以设置数据库default值</span><span class="token keyword">private</span> <span class="token class-name">Integer</span> version<span class="token punctuation">;</span><span class="token comment">//version要有初始值，可以使用自动填充</span></code></pre><p>说明:</p><ul><li><strong>支持的数据类型只有:int,Integer,long,Long,Date,Timestamp,LocalDateTime</strong></li><li>整数类型下 <code>newVersion = oldVersion + 1</code></li><li><code>newVersion</code> 会回写到 <code>entity</code> 中</li><li>仅支持 <code>updateById(id)</code> 与 <code>update(entity, wrapper)</code> 方法</li><li><strong>在 <code>update(entity, wrapper)</code> 方法下, <code>wrapper</code> 不能复用!!!</strong></li></ul><p><strong>3.4版本后的配置写法：（如果对多个插件进行配置(本例是乐观锁和分页)，要写在一个方法内）</strong></p><pre class="language-none"><code class="language-none">@Beanpublic MybatisPlusInterceptor mybatisPlusInterceptor() &#123;    MybatisPlusInterceptor interceptor &#x3D; new MybatisPlusInterceptor();    interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); &#x2F;&#x2F; 乐观锁插件    &#x2F;&#x2F; DbType：数据库类型(根据类型获取应使用的分页方言)    interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); &#x2F;&#x2F; 分页插件    return interceptor;&#125;</code></pre><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><h4 id="通过多个id批量查询"><a href="#通过多个id批量查询" class="headerlink" title="通过多个id批量查询"></a><strong>通过多个id批量查询</strong></h4><p>完成了动态sql的foreach的功能</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSelectBatchIds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userMapper<span class="token punctuation">.</span><span class="token function">selectBatchIds</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="简单的条件查询"><a href="#简单的条件查询" class="headerlink" title="简单的条件查询"></a><strong>简单的条件查询</strong></h4><p>通过Wrapper封装查询条件</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSelectByMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//通过lambda</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userMapper<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span><span class="token class-name">Wrappers</span><span class="token punctuation">.</span><span class="token function">lambdaQuery</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">,</span> <span class="token string">"Jone"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getAge</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//不用lambda</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userMapper<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span><span class="token class-name">Wrappers</span><span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"Jone"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>注意：</strong>map中的key对应的是数据库中的列名。例如数据库user_id，实体类是userId，这时map的key需要填写user_id</p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能</p><p><strong>（1）创建配置类</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 新的分页插件,一缓和二缓遵循mybatis的规则,需要设置  * MybatisConfiguration#useDeprecatedExecutor = false  * 避免缓存出现问题(该属性会在旧插件移除后一同移除) */</span> <span class="token annotation punctuation">@Bean</span> <span class="token keyword">public</span> <span class="token class-name">MybatisPlusInterceptor</span> <span class="token function">mybatisPlusInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token class-name">PaginationInnerInterceptor</span> paginationInnerInterceptor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PaginationInnerInterceptor</span><span class="token punctuation">(</span><span class="token class-name">DbType</span><span class="token punctuation">.</span>MYSQL<span class="token punctuation">)</span><span class="token punctuation">;</span>        paginationInnerInterceptor<span class="token punctuation">.</span><span class="token function">setMaxLimit</span><span class="token punctuation">(</span><span class="token number">500L</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//单页分页条数限制</span>        interceptor<span class="token punctuation">.</span><span class="token function">addInnerInterceptor</span><span class="token punctuation">(</span>paginationInnerInterceptor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 分页插件</span>     <span class="token keyword">return</span> interceptor<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">//不知道为什么加这个，但官网示例加了，我也加</span><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">ConfigurationCustomizer</span> <span class="token function">configurationCustomizer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> configuration <span class="token operator">-></span> configuration<span class="token punctuation">.</span><span class="token function">setUseDeprecatedExecutor</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>（2）测试selectPage分页</strong></p><p><strong>测试：</strong>最终通过page对象获取相关数据</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSelectPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> page <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    userMapper<span class="token punctuation">.</span><span class="token function">selectPage</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    page<span class="token punctuation">.</span><span class="token function">getRecords</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>page<span class="token punctuation">.</span><span class="token function">getCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>page<span class="token punctuation">.</span><span class="token function">getPages</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>page<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>page<span class="token punctuation">.</span><span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>page<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>page<span class="token punctuation">.</span><span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>控制台sql语句打印：SELECT id,name,age,email,create_time,update_time FROM user LIMIT 0,5 </p><p><strong>（3）测试selectMapsPage分页：结果集是Map</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSelectMapsPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span><span class="token punctuation">></span></span> page <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span><span class="token punctuation">></span></span> mapIPage <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectMapsPage</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//注意：此行必须使用 mapIPage 获取记录列表，否则会有数据类型转换错误</span>    mapIPage<span class="token punctuation">.</span><span class="token function">getRecords</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>page<span class="token punctuation">.</span><span class="token function">getCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>page<span class="token punctuation">.</span><span class="token function">getPages</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>page<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>page<span class="token punctuation">.</span><span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>page<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>page<span class="token punctuation">.</span><span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><h4 id="根据id删除记录"><a href="#根据id删除记录" class="headerlink" title="根据id删除记录"></a>根据id删除记录</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDeleteById</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">deleteById</span><span class="token punctuation">(</span><span class="token number">8L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDeleteBatchIds</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">deleteBatchIds</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h4><blockquote><p>说明:</p><p>只对自动注入的sql起效:</p><ul><li><p>插入: 不作限制</p></li><li><p>查找: 追加where条件过滤掉已删除数据,且使用 wrapper.entity 生成的where条件会忽略该字段</p><blockquote><p> 使用 QueryWrapper 进行查询时的sql，我们发现前面的<code>deleted=0</code>条件会让后面我们自己加的deleted条件失效</p><p>SELECT * FROM test.user WHERE deleted=0 AND (deleted = ?)</p></blockquote></li><li><p>更新: 追加where条件防止更新到已删除数据,且使用 wrapper.entity 生成的where条件会忽略该字段</p></li><li><p>删除: 转变为 更新</p></li></ul><p>例如:</p><ul><li>删除: <code>update user set deleted=1 where id = 1 and deleted=0</code></li><li>查找: <code>select id,name,deleted from user where deleted=0</code></li></ul><p>字段类型支持说明:</p><ul><li>支持所有数据类型(推荐使用 <code>Integer</code>,<code>Boolean</code>,<code>LocalDateTime</code>)</li><li>如果数据库字段使用<code>datetime</code>,逻辑未删除值和已删除值支持配置为字符串<code>null</code>,另一个值支持配置为函数来获取值如<code>now()</code></li></ul><p>附录:</p><ul><li>如果要恢复删除的数据，可以使用mybatis手写sql来实现，绕过mybatis-plus</li><li>逻辑删除是为了方便数据恢复和保护数据本身价值等等的一种方案，但实际就是删除。</li><li>如果你需要频繁查出来看就不应使用逻辑删除，而是以一个状态去表示。</li></ul></blockquote><p><strong>数据库中添加 deleted字段</strong></p><pre class="language-none"><code class="language-none">ALTER TABLE &#96;user&#96; ADD COLUMN &#96;deleted&#96; boolean</code></pre><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/bc4cbff4-c2b8-45d5-ae8d-53439dd2330c.png" alt="img" loading="lazy"></p><p><strong>实体类添加deleted 字段</strong></p><p>并加上 @TableLogic 注解 和 @TableField(fill = FieldFill.INSERT) 注解</p><pre class="language-none"><code class="language-none">@TableLogic@TableField(fill &#x3D; FieldFill.INSERT)&#x2F;&#x2F;也可以设置数据库default值private Integer deleted;</code></pre><p><strong>元对象处理器接口添加deleted的insert默认值</strong></p><pre class="language-none"><code class="language-none">@Overridepublic void insertFill(MetaObject metaObject) &#123;    this.setFieldValByName(&quot;deleted&quot;, 0, metaObject);&#125;</code></pre><p><strong>application.properties 加入配置</strong></p><p>此为默认值，如果你的默认值和mp默认的一样,该配置可无</p><pre class="language-none"><code class="language-none">mybatis-plus:  global-config:    db-config:      logic-delete-field: flag  # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以不用往flag字段上加@TableLogic注解)      logic-delete-value: 1 # 逻辑已删除值(默认为 1)      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)</code></pre><p><strong>在 MybatisPlusConfig 中注册 Bean</strong></p><pre class="language-none"><code class="language-none">@Beanpublic ISqlInjector sqlInjector() &#123;    return new LogicSqlInjector();&#125;</code></pre><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><blockquote><p> 该功能依赖 <code>p6spy</code> 组件，完美的输出打印 SQL 及执行时长 <code>3.1.0</code> 以上版本</p></blockquote><ul><li>p6spy 依赖引入</li></ul><p>Maven：</p><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>p6spy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>p6spy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>最新版本<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><ul><li>application.yml 配置：</li></ul><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">datasource</span><span class="token punctuation">:</span>    <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.p6spy.engine.spy.P6SpyDriver    <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>p6spy<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>3306/数据库名    <span class="token punctuation">...</span></code></pre><ul><li>spy.properties 配置：</li></ul><pre class="language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#3.2.1以上使用</span><span class="token attr-name">modulelist</span><span class="token punctuation">=</span><span class="token attr-value">com.baomidou.mybatisplus.extension.p6spy.MybatisPlusLogFactory,com.p6spy.engine.outage.P6OutageFactory</span><span class="token comment">#3.2.1以下使用或者不配置</span><span class="token comment">#modulelist=com.p6spy.engine.logging.P6LogFactory,com.p6spy.engine.outage.P6OutageFactory</span><span class="token comment"># 自定义日志打印</span><span class="token attr-name">logMessageFormat</span><span class="token punctuation">=</span><span class="token attr-value">com.baomidou.mybatisplus.extension.p6spy.P6SpyLogger</span><span class="token comment">#日志输出到控制台</span><span class="token attr-name">appender</span><span class="token punctuation">=</span><span class="token attr-value">com.baomidou.mybatisplus.extension.p6spy.StdoutLogger</span><span class="token comment"># 使用日志系统记录 sql</span><span class="token comment">#appender=com.p6spy.engine.spy.appender.Slf4JLogger</span><span class="token comment"># 设置 p6spy driver 代理</span><span class="token attr-name">deregisterdrivers</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token comment"># 取消JDBC URL前缀</span><span class="token attr-name">useprefix</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token comment"># 配置记录 Log 例外,可去掉的结果集有error,info,batch,debug,statement,commit,rollback,result,resultset.</span><span class="token attr-name">excludecategories</span><span class="token punctuation">=</span><span class="token attr-value">info,debug,result,commit,resultset</span><span class="token comment"># 日期格式</span><span class="token attr-name">dateformat</span><span class="token punctuation">=</span><span class="token attr-value">yyyy-MM-dd HH:mm:ss</span><span class="token comment"># 实际驱动可多个</span><span class="token comment">#driverlist=org.h2.Driver</span><span class="token comment"># 是否开启慢SQL记录</span><span class="token attr-name">outagedetection</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token comment"># 慢SQL记录标准 2 秒</span><span class="token attr-name">outagedetectioninterval</span><span class="token punctuation">=</span><span class="token attr-value">2</span></code></pre><blockquote><p>注意！</p><ul><li>driver-class-name 为 p6spy 提供的驱动类</li><li>url 前缀为 jdbc:p6spy 跟着冒号为对应数据库连接地址</li><li>打印出sql为null,在excludecategories增加commit</li><li>批量操作不打印sql,去除excludecategories中的batch</li><li>批量操作打印重复的问题请使用MybatisPlusLogFactory (3.2.1新增）</li><li>该插件有性能损耗，不建议生产环境使用。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> mybatisPlus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git分支</title>
      <link href="posts/7a7ff038/"/>
      <url>posts/7a7ff038/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h2><p>Git 保存的不是文件差异或者变化量，而只是一系列文件快照。</p><p>在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。</p><p>当使用 <code>git commit</code> 新建一个提交对象前，Git 会先计算每一个子目录（本例中就是项目根目录）的校验和，然后在 Git 仓库中将这些目录保存为树（tree）对象。之后 Git 创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此它就可以在将来需要的时候，重现此次快照的内容了。</p><p>使用<code>git commit</code>创建一个提交对象后，仓库中各个对象保存的数据和相互关系如图所示：</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/2015-10-12_561bcb5aaaabe.png" alt="首次提交对象及其树结构." loading="lazy"></p><p>作些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针（译注：即下图中的 parent 对象）。两次提交后，仓库历史会变成 的样子：</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/2015-10-12_561bcb5ac6fec.png" alt="提交对象及其父对象." loading="lazy"></p><p>Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。Git 会使用 master 作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的 master 分支，它在每次提交的时候都会自动向前移动。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/2015-10-12_561bcb5adcb57.png" alt="分支及其提交历史." loading="lazy"></p><p>新建一个 testing 分支，可以使用 <code>git branch</code> 命令：</p><pre class="language-none"><code class="language-none">$ git branch testing</code></pre><p>这会在当前 commit 对象上新建一个分支指针。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/2015-10-12_561bcb5aee442.png" alt="两个指向相同提交历史的分支。" loading="lazy"></p><p>Git通过保存一个名为HEAD的特别指针来知道当前在哪个分支上工作，HEAD是一个指向你正在工作中的本地分支的指针。运行 <code>git branch</code> 命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，所以在这个例子中，我们依然还在 master 分支里工作。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/2015-10-12_561bcb5b0bb09.png" alt="HEAD 指向当前所在的分支." loading="lazy"></p><p>要切换到其他分支，可以执行 <code>git checkout</code> 命令。我们现在转换到新建的 testing 分支：</p><pre class="language-none"><code class="language-none">$ git checkout testing</code></pre><p>这样 HEAD 就指向了 testing 分支。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/2015-10-12_561bcb5b1b5c1.png" alt="HEAD 指向当前所在的分支." loading="lazy"></p><p>如果现在再提交一次，就会变成如下图所示：</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/2015-10-12_561bcb5b31055.png" alt="HEAD 分支随着提交操作自动向前移动." loading="lazy"></p><p>现在testing 分支向前移动了一格，而 master 分支仍然指向原先 <code>git checkout</code> 时所在的 commit 对象。现在我们回到 master 分支看看：</p><pre class="language-none"><code class="language-none">$ git checkout master</code></pre><p>这条命令做了两件事。它把 HEAD 指针移回到 master 分支，并把工作目录中的文件换成了 master 分支所指向的快照内容。</p><p>我们作些修改后再次提交的话，项目的提交历史就会产生分叉。刚才我们创建了一个分支，转换到其中进行了一些工作，然后又回到原来的主分支进行了另外一些工作。这些改变分别孤立在不同的分支里：我们可以在不同分支里反复切换，并在时机成熟时把它们合并到一起。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/2015-10-12_561bcb5b52163.png" alt="项目分叉历史." loading="lazy"></p><p>Git 中的分支实际上仅是一个包含所指对象校验和（40 个字符长度 SHA-1 字串）的文件，所以创建和销毁一个分支就变得非常廉价。</p><h2 id="分支的新建与合并"><a href="#分支的新建与合并" class="headerlink" title="分支的新建与合并"></a>分支的新建与合并</h2><h3 id="分支的新建与切换"><a href="#分支的新建与切换" class="headerlink" title="分支的新建与切换"></a>分支的新建与切换</h3><p>要新建并切换到该分支，运行 <code>git checkout</code> 并加上 <code>-b</code> 参数：</p><pre class="language-none"><code class="language-none">$ git checkout -b iss53Switched to a new branch &quot;iss53&quot;</code></pre><p>这相当于执行下面这两条命令：</p><pre class="language-none"><code class="language-none">$ git branch iss53$ git checkout iss53</code></pre><p>不过在此之前，暂存区或者工作目录里那些还没有提交的修改会和即将检出的分支产生冲突从而阻止 Git 切换分支。切换分支的时候最好保持一个清洁的工作区域。</p><p>分支如果要进行合并可以使用<code>git merge</code> 命令来进行合并：</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/2015-10-12_561bcb5ccb01a.png" alt="基于  分支的紧急问题分支（hotfix branch）。" loading="lazy"></p><pre class="language-none"><code class="language-none">$ git checkout master$ git merge hotfixUpdating 5c2482d..15dcd1cFast-forward qwe.txt | 1 + 1 file changed, 1 insertion(+)</code></pre><p>合并时出现了“Fast forward”的提示。由于当前 <code>master</code> 分支所在的提交对象是要并入的 <code>hotfix</code> 分支的直接上游，Git 只需把 <code>master</code> 分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。</p><p>由于当前 <code>hotfix</code> 分支和 <code>master</code> 都指向相同的提交对象，所以 <code>hotfix</code> 已经完成了历史使命，可以删掉了。使用 <code>git branch</code> 的 <code>-d</code> 选项执行删除操作：</p><pre class="language-none"><code class="language-none">$ git branch -d hotfixDeleted branch hotfix (was 15dcd1c).</code></pre><h3 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h3><p>在问题 #53 相关的工作完成之后，可以合并回 <code>master</code> 分支。实际操作同前面合并 <code>hotfix</code> 分支差不多，只需回到 <code>master</code> 分支，运行 <code>git merge</code> 命令指定要合并进来的分支：</p><pre class="language-none"><code class="language-none">$ git checkout master$ git merge iss53Merge made by the &#39;recursive&#39; strategy. pom.xml | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre><p>这次合并操作的底层实现，并不同于之前 <code>hotfix</code> 的并入方式。因为这次你的开发历史是从更早的地方开始分叉的。由于当前 <code>master</code> 分支所指向的提交对象（C4）并不是 <code>iss53</code> 分支的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。图 3-16 用红框标出了 Git 用于合并的三个提交对象：</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/18333fig0316-tn.png" alt="img" loading="lazy"></p><p>这次，Git 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）（见图 3-17）。这个提交对象比较特殊，它有两个祖先（C4 和 C5）。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/18333fig0317-tn.png" alt="img" loading="lazy"></p><h3 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h3><p>有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（译注：逻辑上说，这种问题只能由人来裁决。）。如果你在解决问题 #53 的过程中修改了 <code>hotfix</code> 中修改的部分，将得到类似下面的结果：</p><pre class="language-none"><code class="language-none">$ git merge iss54Auto-merging qwe.txtCONFLICT (content): Merge conflict in qwe.txtAutomatic merge failed; fix conflicts and then commit the result.</code></pre><p>Git 作了合并，但没有提交，它会停下来等你解决冲突。要看看哪些文件在合并时发生冲突，可以用 <code>git status</code> 查阅:</p><pre class="language-none"><code class="language-none">$ git statusOn branch masterYour branch is ahead of &#39;origin&#x2F;master&#39; by 5 commits.  (use &quot;git push&quot; to publish your local commits)You have unmerged paths.  (fix conflicts and run &quot;git commit&quot;)  (use &quot;git merge --abort&quot; to abort the merge)Unmerged paths:  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)        both modified:   qwe.txtno changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</code></pre><p>在Unmerged paths里列出所有冲突文件。</p><p>打开qwe.txt可以看到：</p><pre class="language-none"><code class="language-none">啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD亲委&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;士大夫撒旦&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss54</code></pre><p>可以看到 <code>=======</code> 隔开的上半部分，是 <code>HEAD</code>（即 <code>master</code> 分支，在运行 <code>merge</code> 命令时所切换到的分支）中的内容，下半部分是在 <code>iss54</code> 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决：</p><pre class="language-none"><code class="language-none">啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊亲委士大夫撒旦</code></pre><p>然后执行git add和git commit完成合并提交。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p><code>git branch</code> 命令不仅仅能创建和删除分支，如果不加任何参数，它会给出当前所有分支的清单：</p><pre class="language-none"><code class="language-none">$ git branch  iss53  iss54* master</code></pre><p>注意看 <code>master</code> 分支前的 <code>*</code> 字符：它表示当前所在的分支。也就是说，如果现在提交更新，<code>master</code> 分支将随着开发进度前移。若要查看各个分支最后一个提交对象的信息，运行 <code>git branch -v</code>：</p><pre class="language-none"><code class="language-none">$ git branch -v  iss53  a87e37d qw  iss54  d121dae qw* master 1ebd4d5 [ahead 7] up</code></pre><p>要从该清单中筛选出你已经（或尚未）与当前分支合并的分支，可以用 <code>--merge</code> 和 <code>--no-merged</code> 选项。比如用 <code>git branch --merge</code> 查看哪些分支已被并入当前分支：</p><pre class="language-none"><code class="language-none">$ git branch --merged  iss53  iss54* master</code></pre><p>一般来说，列表中没有 <code>*</code> 的分支通常都可以用 <code>git branch -d</code> 来删掉。原因很简单，既然已经把它们所包含的工作整合到了其他分支，删掉也不会损失什么。</p><p>另外可以用 <code>git branch --no-merged</code> 查看尚未合并的工作：</p><pre class="language-none"><code class="language-none">$ git branch --no-merged    testing</code></pre><p>它会显示还未合并进来的分支。由于这些分支中还包含着尚未合并进来的工作成果，所以简单地用 <code>git branch -d</code> 删除该分支会提示错误，因为那样做会丢失数据：</p><pre class="language-none"><code class="language-none">$ git branch -d testingerror: The branch &#39;testing&#39; is not fully merged.If you are sure you want to delete it, run &#39;git branch -D testing&#39;.</code></pre><p>不过，如果你确实想要删除该分支上的改动，可以用大写的删除选项 <code>-D</code> 强制执行，就像上面提示信息中给出的那样。</p><h2 id="利用分支进行开发的工作流程"><a href="#利用分支进行开发的工作流程" class="headerlink" title="利用分支进行开发的工作流程"></a>利用分支进行开发的工作流程</h2><h3 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h3><p>许多使用 Git 的开发者都喜欢用这种方式来开展工作，比如仅在 <code>master</code> 分支中保留完全稳定的代码，即已经发布或即将发布的代码。与此同时，他们还有一个名为 <code>develop</code> 或 <code>next</code> 的平行分支，专门用于后续的开发，或仅用于稳定性测试 — 当然并不是说一定要绝对稳定，不过一旦进入某种稳定状态，便可以把它合并到 <code>master</code> 里。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/2015-10-12_561bcb5de1972.png" alt="渐进稳定分支的工作流（“silo”）视图。" loading="lazy"></p><h3 id="特性分支"><a href="#特性分支" class="headerlink" title="特性分支"></a>特性分支</h3><p>在任何规模的项目中都可以使用特性（Topic）分支。一个特性分支是指一个短期的，用来实现单一特性或与其相关工作的分支。</p><p>现在我们来看一个实际的例子。请看图 ，由下往上，起先我们在 <code>master</code> 工作到 C1，然后开始一个新分支 <code>iss91</code> 尝试修复 91 号缺陷，提交到 C6 的时候，又冒出一个解决该问题的新办法，于是从之前 C4 的地方又分出一个分支 <code>iss91v2</code>，干到 C8 的时候，又回到主干 <code>master</code> 中提交了 C9 和 C10，再回到 <code>iss91v2</code> 继续工作，提交 C11，接着，又冒出个不太确定的想法，从 <code>master</code> 的最新提交 C10 处开了个新的分支 <code>dumbidea</code> 做些试验。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/2015-10-12_561bcb5df1ada.png" alt="拥有多个特性分支的提交历史。" loading="lazy"></p><p>现在，假定两件事情：我们最终决定使用第二个解决方案，即 <code>iss91v2</code> 中的办法；另外，我们把 <code>dumbidea</code> 分支拿给同事们看了以后，发现它竟然是个天才之作。所以接下来，我们准备抛弃原来的 <code>iss91</code> 分支（实际上会丢弃 C5 和 C6），直接在主干中并入另外两个分支。最终的提交历史将变成下图这样：</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/2015-10-12_561bcb5e18de5.png" alt="合并了  和  分支之后的提交历史。" loading="lazy"></p><p>请务必牢记这些分支全部都是本地分支，这一点很重要。当你在使用分支及合并的时候，一切都是在你自己的 Git 仓库中进行的 — 完全不涉及与服务器的交互。</p><h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>远程分支（remote branch）是对远程仓库中的分支的索引。它们是一些无法移动的本地分支；只有在 Git 进行网络交互时才会更新。</p><p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。你可以通过 <code>git ls-remote (remote)</code> 来显式地获得远程引用的完整列表，或者通过 <code>git remote show (remote)</code> 获得远程分支的更多信息。然而，一个更常见的做法是利用远程跟踪分支。</p><p>我们用 <code>(远程仓库名)/(分支名)</code> 这样的形式表示远程分支。比如我们想看看上次同 <code>origin</code> 仓库通讯时 <code>master</code> 分支的样子，就应该查看 <code>origin/master</code> 分支。如果你和同伴一起修复某个问题，但他们先推送了一个 <code>iss53</code> 分支到远程仓库，虽然你可能也有一个本地的 <code>iss53</code> 分支，但指向服务器上最新更新的却应该是 <code>origin/iss53</code> 分支。</p><blockquote><h3 id="“origin”-并无特殊含义"><a href="#“origin”-并无特殊含义" class="headerlink" title="“origin” 并无特殊含义"></a>“origin” 并无特殊含义</h3></blockquote><blockquote><p>远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。同时 “master” 是当你运行 <code>git init</code> 时默认的起始分支名字，原因仅仅是它的广泛使用，“origin” 是当你运行 <code>git clone</code> 时默认的远程仓库名字。如果你运行 <code>git clone -o booyah</code>，那么你默认的远程分支名字将会是 <code>booyah/master</code>。</p></blockquote><p>如果你在本地 <code>master</code> 分支做了些改动，与此同时，其他人向 <code>git.ourcompany.com</code> 推送了他们的更新，那么服务器上的 <code>master</code> 分支就会向前推进，而于此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的 <code>origin/master</code> 指针仍然保持原位不会移动。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/2015-10-12_561bcb5f813c8.png" alt="本地与远程的工作可以分叉。" loading="lazy"></p><p>可以运行 <code>git fetch origin</code> 来同步远程服务器上的数据到本地。该命令首先找到 <code>origin</code> 是哪个服务器（本例为 <code>git.ourcompany.com</code>），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把 <code>origin/master</code> 的指针移到它最新的位置上。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/2015-10-12_561bcb5f98f62.png" alt=" 更新你的远程仓库引用。" loading="lazy"></p><h3 id="推送本地分支"><a href="#推送本地分支" class="headerlink" title="推送本地分支"></a>推送本地分支</h3><p>把本地分支推送到远程仓库<code>git push (远程仓库名) (分支名)</code>。</p><p>运行 <code>git push origin serverfix:serverfix</code> ，它的意思是“上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作 <code>awesomebranch</code>，可以用 <code>git push origin serverfix:awesomebranch</code> 来推送数据。</p><p><code>git checkout -b serverfix origin/serverfix</code>是会切换到新建的 <code>serverfix</code> 本地分支，其内容同远程分支 <code>origin/serverfix</code> 一致。</p><h3 id="跟踪远程分支"><a href="#跟踪远程分支" class="headerlink" title="跟踪远程分支"></a>跟踪远程分支</h3><p>在克隆仓库时，Git 通常会自动创建一个名为 <code>master</code> 的分支来跟踪 <code>origin/master</code>。这正是 <code>git push</code> 和 <code>git pull</code> 一开始就能正常工作的原因。当然，你可以随心所欲地设定为其它跟踪分支，比如 <code>origin</code> 上除了 <code>master</code> 之外的其它分支。刚才我们已经看到了这样的一个例子：<code>git checkout -b [分支名] [远程名]/[分支名]</code>。如果你有 1.6.2 以上版本的 Git，还可以用 <code>--track</code> 选项简化：</p><pre class="language-none"><code class="language-none">$ git checkout --track origin&#x2F;serverfix</code></pre><p>要为本地分支设定不同于远程分支的名字，只需在第一个版本的命令里换个名字：</p><pre class="language-none"><code class="language-none">$ git checkout -b sf origin&#x2F;serverfix</code></pre><p>现在你的本地分支 <code>sf</code> 会自动将推送和抓取数据的位置定位到 <code>origin/serverfix</code> 了。</p><p>如果想要查看设置的所有跟踪分支，可以使用 <code>git branch</code> 的 <code>-vv</code> 选项。这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p><pre class="language-none"><code class="language-none">$ git branch -vv* master  df81349 [origin&#x2F;master: ahead 8] as  testing 22add77 qwe</code></pre><p>这里可以看到<code> master</code>分支正在跟踪 <code>origin/master</code>并且 “ahead” 是 8，意味着本地有两个提交还没有推送到服务器上。</p><p>如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。可以像这样做：<code>$ git fetch --all; git branch -vv</code></p><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p><code>git push origin --delete 分支名</code></p><p>在删除远程分支时，同名的本地分支并不会被删除，所以还需要单独删除本地同名分支。</p><h2 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h2><p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code> 以及 <code>rebase</code>。</p><h3 id="变基的基本操作"><a href="#变基的基本操作" class="headerlink" title="变基的基本操作"></a>变基的基本操作</h3><p>假设分支提交历史如下：</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/2015-10-12_561bcb6162ea5.png" alt="分叉的提交历史" loading="lazy"></p><p>如果使用merge命令，它会把两个分支的最新快照C3和C4以及二者共同祖先C2合并，生成一个新的快照并提交。</p><p>其实，还有一种方法：你可以提取在 <code>C4</code> 中引入的补丁和修改，然后在 <code>C3</code> 的基础上再应用一次。在 Git 中，这种操作就叫做 <em>变基</em>。你可以使用 <code>rebase</code> 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p><p>在上面这个例子中，运行：</p><pre class="language-none"><code class="language-none">$ git checkout experiment$ git rebase masterSuccessfully rebased and updated refs&#x2F;heads&#x2F;experiment.</code></pre><p>它的原理是首先找到这两个分支（即当前分支 <code>experiment</code>、变基操作的目标基底分支 <code>master</code>）的最近共同祖先 <code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 <code>C3</code>, 最后以此将之前另存为临时文件的修改依序应用。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/2015-10-12_561bcb6189bbc.png" alt="将  中的修改变基到  上" loading="lazy"></p><p>现在回到 <code>master</code> 分支，进行一次快进合并。</p><pre class="language-none"><code class="language-none">$ git checkout master$ git merge experiment</code></pre><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/2015-10-12_561bcb619d7bf.png" alt="master 分支的快进合并" loading="lazy"></p><h3 id="变基的风险"><a href="#变基的风险" class="headerlink" title="变基的风险"></a>变基的风险</h3><p><strong>不要对在你的仓库外有副本的分支执行变基。</strong></p><p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 <code>git rebase</code> 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础</title>
      <link href="posts/1a60696b/"/>
      <url>posts/1a60696b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="取得项目的Git仓库"><a href="#取得项目的Git仓库" class="headerlink" title="取得项目的Git仓库"></a>取得项目的Git仓库</h2><p>有两种取得 Git 项目仓库的方法。第一种是在现存的目录下，通过导入所有文件来创建新的 Git 仓库。第二种是从已有的 Git 仓库克隆出一个新的镜像仓库来。</p><h3 id="在工作目录中初始化新仓库"><a href="#在工作目录中初始化新仓库" class="headerlink" title="在工作目录中初始化新仓库"></a>在工作目录中初始化新仓库</h3><p>要对现有的某个项目开始用 Git 管理，只需到此项目所在的目录，执行：</p><pre class="language-none"><code class="language-none">$ git init</code></pre><p>初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p><p>如果当前目录下有几个文件想要纳入版本控制，需要先用 <code>git add</code> 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p><pre class="language-none"><code class="language-none">$ git add *.c$ git add README$ git commit -m &#39;initial project version&#39;</code></pre><h3 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h3><p>如果想对某个开源项目出一份力，可以先把该项目的 Git 仓库复制一份出来，这就需要用到 <code>git clone</code> 命令。实际上，即便服务器的磁盘发生故障，用任何一个克隆出来的客户端都可以重建服务器上的仓库，回到当初克隆时的状态。</p><p>克隆仓库的命令格式为 <code>git clone [url]</code>。比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</p><pre class="language-none"><code class="language-none">$ git clone git:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;grit.git</code></pre><p>这会在当前目录下创建一个名为<code>grit</code>的目录，其中包含一个 <code>.git</code> 的目录，用于保存下载下来的所有版本记录，然后从中取出最新版本的文件拷贝。如果希望在克隆的时候，自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p><pre class="language-none"><code class="language-none">$ git clone git:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;grit.git mygrit</code></pre><p>唯一的差别就是，现在新建的目录成了 <code>mygrit</code>，其他的都和上边的一样。</p><p>Git 支持许多数据传输协议。之前的例子使用的是 <code>git://</code> 协议，不过你也可以用 <code>http(s)://</code> 或者 <code>user@server:/path.git</code> 表示的 SSH 传输协议。</p><h2 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h2><p>工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。</p><p>在编辑过某些文件之后，Git 将这些文件标为已修改。我们逐步把这些修改过的文件放到暂存区域，直到最后一次性提交所有这些暂存起来的文件，如此重复。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/2015-10-12_561bcb568ace5.png" alt="Git 下文件生命周期图。" loading="lazy"></p><h3 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h3><p>要确定哪些文件当前处于什么状态，可以用 <code>git status</code> 命令。如果在克隆仓库之后立即执行此命令，会看到类似这样的输出：</p><pre class="language-shell" data-language="shell"><code class="language-shell">$ git statusOn branch masternothing to commit, working tree clean</code></pre><h3 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h3><p>使用命令 <code>git add</code> 开始跟踪一个新文件。</p><p>所以，要跟踪 README 文件，运行：</p><pre class="language-none"><code class="language-none">$ git add README</code></pre><p>此时再运行 <code>git status</code> 命令，会看到 README 文件已被跟踪，并处于暂存状态：</p><pre class="language-shell" data-language="shell"><code class="language-shell">$ git statusOn branch masterYour branch is up to date with &#39;origin&#x2F;master&#39;.Changes to be committed:  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)        modified:   README</code></pre><p>只要在 “Changes to be committed” 这行下面的，就说明是已暂存状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。</p><h3 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h3><p>现在我们修改下之前已跟踪过的文件 <code>README.md</code>，然后再次运行 <code>status</code> 命令，会看到这样的状态报告：</p><pre class="language-shell" data-language="shell"><code class="language-shell">$ git statusOn branch masterYour branch is up to date with &#39;origin&#x2F;master&#39;.Changes not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)        modified:   README.mdno changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</code></pre><p>文件 <code>README.md</code> 出现在 “Changes not staged for commit” 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行 <code>git add</code> 命令（这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等）。现在让我们运行 <code>git add</code> 将<code>README.md</code> 放到暂存区，然后再看看 <code>git status</code> 的输出：</p><pre class="language-none"><code class="language-none">$ git statusOn branch masterYour branch is up to date with &#39;origin&#x2F;master&#39;.Changes to be committed:  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)        modified:   README.md</code></pre><h3 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h3><p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。如果你使用 <code>git status -s</code> 命令或 <code>git status --short</code> 命令，你将得到一种更为紧凑的格式输出。运行 <code>git status -s</code> ，状态报告输出如下：</p><pre class="language-none"><code class="language-none">$ git status -s M READMEMM RakefileA  lib&#x2F;git.rbM  lib&#x2F;simplegit.rb?? LICENSE.txt</code></pre><p>新添加的未跟踪文件前面有 <code>??</code> 标记。</p><p>新添加到暂存区中的文件前面有 <code>A</code> 标记。</p><p>修改过的文件前面有 <code>M</code> 标记。</p><p> <code>M</code> 有两个可以出现的位置，出现在右边的 <code>M</code> 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 <code>M</code> 表示该文件被修改了并放入了暂存区。</p><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件模式。来看一个实际的例子：</p><pre class="language-none"><code class="language-none">$ cat .gitignore# Compiled class file*.class</code></pre><p>第一行告诉 Git 忽略所有以 <code>.class</code> 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的，我们用不着跟踪它们的版本。要养成一开始就设置好 <code>.gitignore</code> 文件的习惯，以免将来误提交这类无用的文件。</p><p>文件 <code>.gitignore</code> 的格式规范如下：</p><ul><li>所有空行或者以注释符号 <code>＃</code> 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配。</li><li>匹配模式最后跟反斜杠（<code>/</code>）说明要忽略的是目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。</li></ul><p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。使用两个星号（<code>*</code>) 表示匹配任意中间目录，比如<code>a/**/z</code> 可以匹配 <code>a/z</code>, <code>a/b/z</code> 或 <code>a/b/c/z</code>等。</p><p>我们再看一个 <code>.gitignore</code> 文件的例子：</p><pre class="language-shell" data-language="shell"><code class="language-shell"># 此为注释 – 将被 Git 忽略# 忽略所有 .a 结尾的文件*.a# 但 lib.a 除外!lib.a# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir&#x2F;TODO&#x2F;TODO# 忽略 build&#x2F; 目录下的所有文件build&#x2F;# 会忽略 doc&#x2F;notes.txt 但不包括 doc&#x2F;server&#x2F;arch.txtdoc&#x2F;*.txt</code></pre><h3 id="查看已暂存和未暂存的更新"><a href="#查看已暂存和未暂存的更新" class="headerlink" title="查看已暂存和未暂存的更新"></a>查看已暂存和未暂存的更新</h3><p>实际上 <code>git status</code> 的显示比较简单，仅仅是列出了修改过的文件，如果要查看具体修改了什么地方，可以用 <code>git diff</code> 命令。<code>git diff</code> 会使用文件补丁的格式显示具体添加和删除的行。</p><p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 <code>git diff</code>：</p><pre class="language-none"><code class="language-none">$ git diffdiff --git a&#x2F;README.md b&#x2F;README.mdindex e69de29..f2ba8f8 100644--- a&#x2F;README.md+++ b&#x2F;README.md@@ -0,0 +1 @@+abc\ No newline at end of file</code></pre><p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。</p><p>若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 <code>git diff --cached</code> 命令。（Git 1.6.1 及更高版本还允许使用 <code>git diff --staged</code>，效果是相同的，但更好记些。）来看看实际的效果：</p><pre class="language-none"><code class="language-none">$ git diff --stageddiff --git a&#x2F;README.md b&#x2F;README.mdindex e69de29..f2ba8f8 100644--- a&#x2F;README.md+++ b&#x2F;README.md@@ -0,0 +1 @@+abc\ No newline at end of file</code></pre><h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><p>每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了，然后再运行提交命令 <code>git commit</code>。</p><p>这种方式会启动文本编辑器以便输入本次提交的说明。另外也可以用 -m 参数后跟提交说明的方式，在一行命令中提交更新。</p><pre class="language-none"><code class="language-none">$ git commit[master ee80182] test 1 file changed, 1 insertion(+)</code></pre><p>可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（ee80182），以及在本次提交中，有多少文件修订过，多少行添改和删改过。</p><p>提交时记录的是放在暂存区域的快照，任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p><h3 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h3><p>使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤：</p><pre class="language-shell" data-language="shell"><code class="language-shell">$ git commit -a -m &quot;test&quot;[master 70da55d] test 1 file changed, 2 insertions(+), 1 deletion(-)</code></pre><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><p>如果删除之前已经放到暂存区域后又修改了的话，则必须要用强制删除选项 <code>-f</code>（译注：即 force 的首字母），以防误删除文件后丢失修改的内容。</p><pre class="language-shell" data-language="shell"><code class="language-shell">$ git rm qwe.txterror: the following file has staged content different from both thefile and the HEAD:    qwe.txt(use -f to force removal)Mr.Gzj@DESKTOP-GNL5LT6 MINGW64 &#x2F;d&#x2F;gitProject&#x2F;offer (master)$ git rm -f qwe.txtrm &#39;qwe.txt&#39;</code></pre><p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆 <code>.a</code> 编译文件，不小心纳入仓库后，要移除跟踪但不删除文件，以便稍后在 <code>.gitignore</code> 文件中补上，用 <code>--cached</code> 选项即可：</p><pre class="language-none"><code class="language-none">$ git rm --cached readme.txt</code></pre><p>后面可以列出文件或者目录的名字，也可以使用 glob 模式。比方说：</p><pre class="language-none"><code class="language-none">$ git rm log&#x2F;\*.log</code></pre><p>注意到星号 <code>*</code> 之前的反斜杠 <code>\</code>，因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开（译注：实际上不加反斜杠也可以运行，只不过按照 shell 扩展的话，仅仅删除指定目录下的文件而不会递归匹配。上面的例子本来就指定了目录，所以效果等同，但下面的例子就会用递归方式匹配，所以必须加反斜杠。）。此命令删除所有 <code>log/</code> 目录下扩展名为 <code>.log</code> 的文件。类似的比如：</p><pre class="language-none"><code class="language-none">$ git rm \*~</code></pre><p>会递归删除当前目录及其子目录中所有 <code>~</code> 结尾的文件。</p><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>Git 并不跟踪文件移动操作。如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。</p><p>要在 Git 中对文件改名，可以这么做：</p><pre class="language-none"><code class="language-none">$ git mv file_from file_to</code></pre><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><p>在提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，可以使用 <code>git log</code> 命令查看。</p><pre class="language-shell" data-language="shell"><code class="language-shell">$ git logcommit 015436195b0a7e55123792425fb8213249d0b07d (HEAD -&gt; master)Author: gzj1999 &lt;1045643052@qq.com&gt;Date:   Sat Jul 18 11:10:21 2020 +0800    修改删除订单commit b578cd1a0a917e5b975917d3f95c5ce692f6538fMerge: ab86b7a 4a5964fAuthor: gzj1999 &lt;1045643052@qq.com&gt;Date:   Fri Jul 17 22:04:48 2020 +0800</code></pre><p>默认不用任何参数的话，<code>git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。每次更新都有一个 SHA-1 校验和、作者的名字和电子邮件地址、提交时间，最后缩进一个段落显示提交说明。</p><p>我们常用 <code>-p</code> 选项展开显示每次提交的内容差异，用 <code>-2</code> 则仅显示最近的两次更新：</p><pre class="language-none"><code class="language-none">$ git log -p -2commit 015436195b0a7e55123792425fb8213249d0b07d (HEAD -&gt; master)Author: gzj1999 &lt;1045643052@qq.com&gt;Date:   Sat Jul 18 11:10:21 2020 +0800    修改删除订单diff --git a&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;clothes&#x2F;controller&#x2F;OrderController.java b&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;clothes&#x2F;controller&#x2F;OrderController.javaindex 87295b1..d0f4c77 100644--- a&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;clothes&#x2F;controller&#x2F;OrderController.java+++ b&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;clothes&#x2F;controller&#x2F;OrderController.java@@ -92,10 +92,14 @@ public class OrderController &#123;             return new Response(&quot;400&quot;, &quot;没有此订单！&quot;);         &#125;</code></pre><p>在做代码审查，或者要快速浏览其他协作者提交的更新都作了哪些改动时，就可以用这个选项。此外，还有许多摘要选项可以用，比如 <code>--stat</code>，仅显示简要的增改行数统计：</p><pre class="language-none"><code class="language-none">$ git log --statcommit 015436195b0a7e55123792425fb8213249d0b07d (HEAD -&gt; master)Author: gzj1999 &lt;1045643052@qq.com&gt;Date:   Sat Jul 18 11:10:21 2020 +0800    修改删除订单 src&#x2F;main&#x2F;java&#x2F;com&#x2F;clothes&#x2F;controller&#x2F;OrderController.java   | 4 ++++ src&#x2F;main&#x2F;java&#x2F;com&#x2F;clothes&#x2F;service&#x2F;UserService.java          | 7 +++++++ src&#x2F;main&#x2F;java&#x2F;com&#x2F;clothes&#x2F;service&#x2F;impl&#x2F;UserServiceImpl.java | 7 +++++++ 3 files changed, 18 insertions(+)</code></pre><p>还有个常用的 <code>--pretty</code> 选项，可以指定使用完全不同于默认格式的方式展示提交历史。比如用 <code>oneline</code> 将每个提交放在一行显示，这在提交数很大时非常有用。</p><p>一些其他常用的选项及其释义:</p><pre class="language-none"><code class="language-none">选项 说明    -p 按补丁格式显示每个更新之间的差异。    --stat 显示每次更新的文件修改统计信息。    --shortstat 只显示 --stat 中最后的行数修改添加移除统计。    --name-only 仅在提交信息后显示已修改的文件清单。    --name-status 显示新增、修改、删除的文件清单。    --abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。    --relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。    --graph 显示 ASCII 图形表示的分支合并历史。    --pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</code></pre><p>当 oneline 或 format 与另一个 <code>log</code> 选项 <code>--graph</code> 结合使用时尤其有用。这个选项添加了一些ASCII字符串来形象地展示你的分支、合并历史：</p><pre class="language-none"><code class="language-none">$ git log --pretty&#x3D;format:&quot;%h %s&quot; --graph*   1ebd4d5 up|\| * d121dae qw* | a87e37d qw|&#x2F;*   6c3f1d7 Merge branch &#39;iss53&#39;|\| * 2519576 l* | c7badcf up</code></pre><h3 id="限制输出长度"><a href="#限制输出长度" class="headerlink" title="限制输出长度"></a>限制输出长度</h3><p> <code>-&lt;n&gt;</code> 选项，其中的 <code>n</code> 可以是任何自然数，表示仅显示最近的若干条提交。不过实践中我们是不太用这个选项的，Git 在输出所有提交时会自动调用分页程序（less），要看更早的更新只需翻到下页即可。</p><p>另外还有按照时间作限制的选项，比如 <code>--since</code> 和 <code>--until</code>。下面的命令列出所有最近两周内的提交：</p><pre class="language-none"><code class="language-none">$ git log --since&#x3D;2.weeks</code></pre><p>你可以给出各种时间格式，比如说具体的某一天（“2008-01-15”），或者是多久以前（“2 years 1 day 3 minutes ago”）。</p><p>另一个真正实用的<code>git log</code>选项是路径(path)，如果只关心某些文件或者目录的历史提交，可以在 <code>git log</code> 选项的最后指定它们的路径。因为是放在最后位置上的选项，所以用两个短划线（<code>--</code>）隔开之前的选项和后面限定的路径名。</p><p>其他常用的类似选项。</p><pre class="language-none"><code class="language-none">选项 说明-(n) 仅显示最近的 n 条提交--since, --after 仅显示指定时间之后的提交。--until, --before 仅显示指定时间之前的提交。--author 仅显示指定作者相关的提交。--committer 仅显示指定提交者相关的提交。</code></pre><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><h3 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h3><p>有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以使用 <code>--amend</code> 选项重新提交：</p><pre class="language-shell" data-language="shell"><code class="language-shell">$ git commit --amend #也可以 git commit --amend -m &quot;&quot;</code></pre><p>此命令将使用当前的暂存区域快照提交。如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样。</p><h3 id="取消已经暂存的文件"><a href="#取消已经暂存的文件" class="headerlink" title="取消已经暂存的文件"></a>取消已经暂存的文件</h3><p>有两个修改过的文件，我们想要分开提交，但不小心用 <code>git add .</code> 全加到了暂存区域。可以使用<code>git reset HEAD &lt;file&gt;...</code>的方式取消暂存。</p><ul><li><code>git reset -–hard</code>：<strong>彻底回退到某个版本</strong>，本地的源码也会变为上一个版本的内容，撤销的commit中所包含的更改被冲掉。</li></ul><h3 id="取消对文件的修改"><a href="#取消对文件的修改" class="headerlink" title="取消对文件的修改"></a>取消对文件的修改</h3><p><code>git checkout -- &lt;file&gt;...</code>命令可以使文件恢复到修改前的版本，这条命令有些危险，所有对文件的修改都没有了，因为我们刚刚把之前版本的文件复制过来重写了此文件。所以在用这条命令前，请务必确定真的不再需要保留刚才的修改。</p><h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><p>远程仓库是指托管在网络上的项目仓库，可能会有好多个，其中有些你只能读，另外有些可以写。同他人协作开发某个项目时，需要管理这些远程仓库，以便推送或拉取数据，分享各自的工作进展。管理远程仓库的工作，包括添加远程库，移除废弃的远程库，管理各式远程库分支，定义是否跟踪这些分支，等等。</p><h3 id="查看当前的远程库"><a href="#查看当前的远程库" class="headerlink" title="查看当前的远程库"></a>查看当前的远程库</h3><p>要查看当前配置有哪些远程仓库，可以用 <code>git remote</code> 命令，它会列出每个远程库的简短名字。在克隆完某个项目后，至少可以看到一个名为 origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库：</p><pre class="language-none"><code class="language-none">$ git remoteorigin</code></pre><p>也可以加上 <code>-v</code> 选项（译注：此为 <code>--verbose</code> 的简写，取首字母），显示对应的克隆地址：</p><pre class="language-none"><code class="language-none">$ git remote -vorigin  https:&#x2F;&#x2F;gitee.com&#x2F;gzj1999&#x2F;test.git (fetch)origin  https:&#x2F;&#x2F;gitee.com&#x2F;gzj1999&#x2F;test.git (push)</code></pre><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>有时候可能在GitHub建一个仓库，Gitee建一个仓库。</p><p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行 <code>git remote add [shortname] [url]</code>：</p><pre class="language-none"><code class="language-none">$ git remote add pb git@gitee.com:gzj1999&#x2F;testgzj.git</code></pre><p>现在可以用字符串 <code>pb</code> 指代对应的仓库地址了。比如说，要抓取所有 Paul 有的，但本地仓库没有的信息，可以运行 <code>git fetch pb</code>：</p><pre class="language-none"><code class="language-none">$ git fetch pbwarning: no common commitsremote: Enumerating objects: 3, done.remote: Counting objects: 100% (3&#x2F;3), done.remote: Compressing objects: 100% (2&#x2F;2), done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3&#x2F;3), 948 bytes | 4.00 KiB&#x2F;s, done.From gitee.com:gzj1999&#x2F;testgzj * [new branch]      master     -&gt; pb&#x2F;master</code></pre><p>现在，testgzj的主干分支（master）已经完全可以在本地访问了，对应的名字是 <code>pb/master</code>。</p><h3 id="从远程仓库抓取数据"><a href="#从远程仓库抓取数据" class="headerlink" title="从远程仓库抓取数据"></a>从远程仓库抓取数据</h3><p>正如之前所看到的，可以用下面的命令从远程仓库抓取数据到本地：</p><pre class="language-none"><code class="language-none">$ git fetch [remote-name]</code></pre><p>此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。运行完成后，你就可以在本地访问该远程仓库中的所有分支，将其中某个分支合并到本地，或者只是取出某个分支，一探究竟。</p><p>如果是克隆了一个仓库，此命令会自动将远程仓库归于 origin 名下。所以，<code>git fetch origin</code> 会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）。有一点很重要，需要记住，<strong>fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。</strong></p><h3 id="推送数据到远程仓库"><a href="#推送数据到远程仓库" class="headerlink" title="推送数据到远程仓库"></a>推送数据到远程仓库</h3><p>将本地仓库中的数据推送到远程仓库。实现这个任务的命令很简单： <code>git push [remote-name] [branch-name]</code>。如果要把本地的 master 分支推送到 <code>origin</code> 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令：</p><pre class="language-none"><code class="language-none">$ git push origin master</code></pre><p>只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。</p><h3 id="使用git的squash减少commit记录"><a href="#使用git的squash减少commit记录" class="headerlink" title="使用git的squash减少commit记录"></a>使用git的squash减少commit记录</h3><p>假如git log如下：</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/e7cd7b899e510fb35476621c2881b291d0430c00.png" alt="img" loading="lazy"></p><p>现在，我们希望将最后三个commit压缩为一个，这样push的时候也不至于太多无用的commit，可以使用<code>git rebase -i HEAD~3</code>来修改，这时候我们会发现进入编辑界面，并且显示内容如下：</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/908fa0ec08fa513d73252bd4cddf2fffb3fbd960.png" alt="img" loading="lazy"></p><p>这个界面是让我们告诉git该如何处理每个commit。这里我们想保留f392171这个commit，所以我们需要做的就是将以下两个commit合并到第一个上，我们将编辑界面的内容改成这样即可：</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/63d0f703918fa0ec7d9f01cbd62523ea3f6ddbd7.png" alt="img" loading="lazy"></p><p>ok了，接下来esc，:wq保存即可了。</p><p>注意：不要合并已经push的commit。</p><h3 id="查看远程仓库信息"><a href="#查看远程仓库信息" class="headerlink" title="查看远程仓库信息"></a>查看远程仓库信息</h3><p>我们可以通过命令 <code>git remote show [remote-name]</code> 查看某个远程仓库的详细信息，比如要看所克隆的 <code>origin</code> 仓库，可以运行：</p><pre class="language-none"><code class="language-none">$ git remote show origin* remote origin  Fetch URL: https:&#x2F;&#x2F;gitee.com&#x2F;gzj1999&#x2F;test.git  Push  URL: https:&#x2F;&#x2F;gitee.com&#x2F;gzj1999&#x2F;test.git  HEAD branch: master  Remote branches:    feature&#x2F;sss                      new (next fetch will store in remotes&#x2F;origin)    master                           tracked    refs&#x2F;remotes&#x2F;origin&#x2F;feature&#x2F;test stale (use &#39;git remote prune&#39; to remove)  Local branch configured for &#39;git pull&#39;:    master merges with remote master  Local ref configured for &#39;git push&#39;:    master pushes to master (up to date)</code></pre><p>它显示了有哪些远端分支还没有同步到本地（译注：feature/sss 分支），哪些已同步到本地的远端分支在远端服务器上已被删除（译注：refs/remotes/origin/feature/test分支），Local branch configured for ‘git pull’意思是git pull默认拉取remote master分支，Local ref configured for ‘git push’:意思是默认push到master。</p><h3 id="远程仓库的删除和重命名"><a href="#远程仓库的删除和重命名" class="headerlink" title="远程仓库的删除和重命名"></a>远程仓库的删除和重命名</h3><p>Git 中可以用 <code>git remote rename</code> 命令修改某个远程仓库在本地的简称，比如想把 <code>pb</code> 改成 <code>paul</code>，可以这么运行：</p><pre class="language-none"><code class="language-none">$ git remote rename pb phub$ git remoteoriginphub</code></pre><p>注意，对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 <code>pb/master</code> 分支现在成了 <code>phub/master</code>。</p><p>碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 <code>git remote rm</code> 命令：</p><pre class="language-none"><code class="language-none">$ git remote rm phub$ git remoteorigin</code></pre><h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p>Git 可以对某一时间点上的版本打上标签。人们在发布某个软件版本（比如 v1.0 等等）的时候，经常这么做。</p><h3 id="列显已有的标签"><a href="#列显已有的标签" class="headerlink" title="列显已有的标签"></a>列显已有的标签</h3><p>（下面用的 Git 自身项目仓库）列出现有标签的命令非常简单，直接运行 <code>git tag</code> 即可：</p><pre class="language-none"><code class="language-none">$ git taggitgui-0.10.0gitgui-0.10.1</code></pre><p>显示的标签按字母顺序排列，所以标签的先后并不表示重要程度的轻重。</p><p>我们可以用特定的搜索模式列出符合条件的标签。如果你只对 1.4.2 系列的版本感兴趣，可以运行下面的命令：</p><pre class="language-none"><code class="language-none">$ git tag -l v2.9.*v2.9.0v2.9.0-rc0v2.9.0-rc1v2.9.0-rc2v2.9.1v2.9.2v2.9.3v2.9.4v2.9.5</code></pre><h3 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h3><p>Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。</p><h4 id="含附注的标签"><a href="#含附注的标签" class="headerlink" title="含附注的标签"></a>含附注的标签</h4><p>创建一个含附注类型的标签非常简单，用 <code>-a</code> （译注：取 <code>annotated</code> 的首字母）指定标签名字即可：</p><pre class="language-none"><code class="language-none">$ git tag -a v1.4 -m &#39;my version 1.4&#39;$ git tagv0.1v1.3v1.4</code></pre><p>而 <code>-m</code> 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中。如果没有给出该选项，Git 会启动文本编辑软件供你输入标签说明。</p><p>可以使用 <code>git show</code> 命令查看相应标签的版本信息，并连同显示打标签时的提交对象。</p><h4 id="签署标签"><a href="#签署标签" class="headerlink" title="签署标签"></a>签署标签</h4><p>如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 <code>-a</code> 改为 <code>-s</code> （译注： 取 <code>signed</code> 的首字母）即可：</p><pre class="language-none"><code class="language-none">$ git tag -s v1.5 -m &#39;my signed 1.5 tag&#39;You need a passphrase to unlock the secret key foruser: &quot;Scott Chacon &lt;schacon@gee-mail.com&gt;&quot;1024-bit DSA key, ID F721C45A, created 2009-02-09</code></pre><h4 id="轻量级标签"><a href="#轻量级标签" class="headerlink" title="轻量级标签"></a>轻量级标签</h4><p>轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签，一个 <code>-a</code>，<code>-s</code> 或 <code>-m</code> 选项都不用，直接给出标签名字即可：</p><pre class="language-none"><code class="language-none">$ git tag v1.4-lw$ git tagv0.1v1.3v1.4v1.4-lw</code></pre><h4 id="验证标签"><a href="#验证标签" class="headerlink" title="验证标签"></a>验证标签</h4><p>可以使用 <code>git tag -v [tag-name]</code> （译注：取 <code>verify</code> 的首字母）的方式验证已经签署的标签。此命令会调用 GPG 来验证签名，所以你需要有签署者的公钥，存放在 keyring 中，才能验证：</p><pre class="language-none"><code class="language-none">$ git tag -v v1.4.2.1</code></pre><h3 id="后期加注标签"><a href="#后期加注标签" class="headerlink" title="后期加注标签"></a>后期加注标签</h3><p>你甚至可以在后期对早先的某次提交加注标签。比如在下面展示的提交历史中：</p><pre class="language-none"><code class="language-none">$ git log --pretty&#x3D;onelinea11c575af93aacd1eb019fa00c46cfdd55415314 (origin&#x2F;feature&#x2F;test) update qwe.txt.dd186697004a318be67fdafb6577dfda16a077e8 ceshis72adbf074a6037d61e0c28cf6e4de542d1b7e7d1 qwecd2830cfbf553e77c1889ab3163e37ad31f10970 test</code></pre><p>我们忘了在提交 “ceshis” 后为此项目打上版本号 v1.2，没关系，现在也能做。只要在打标签的时候跟上对应提交对象的校验和（或前几位字符）即可：</p><pre class="language-none"><code class="language-none">$ git tag -a v1.1 dd186697$ git tagv1.1</code></pre><h3 id="分享标签"><a href="#分享标签" class="headerlink" title="分享标签"></a>分享标签</h3><p>默认情况下，<code>git push</code> 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 <code>git push origin [tagname]</code> 即可：</p><pre class="language-none"><code class="language-none">$ git push origin v1.1</code></pre><p>如果要一次推送所有本地新增的标签上去，可以使用 <code>--tags</code> 选项：</p><pre class="language-none"><code class="language-none">$ git push origin --tags</code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>起步git</title>
      <link href="posts/80f36c51/"/>
      <url>posts/80f36c51/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="关于版本控制"><a href="#关于版本控制" class="headerlink" title="关于版本控制"></a>关于版本控制</h2><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p><h3 id="本地版本控制"><a href="#本地版本控制" class="headerlink" title="本地版本控制"></a>本地版本控制</h3><p>采用某种简单的数据库来记录文件的历次更新差异。</p><h3 id="集中化的版本控制系统"><a href="#集中化的版本控制系统" class="headerlink" title="集中化的版本控制系统"></a>集中化的版本控制系统</h3><p>为了让不同系统上的开发者协同工作，集中化版本控制系统(CVCS)应运而生。这类系统都有一个单一的集中管理的服务器，保存所有的文件的修订版本，协同工作的人们都通过客户端连接到这台服务器，取出最新的文件或提交更新。</p><p>这种方式可以在一定限度上看到项目中的其他人在做什么。管理员也可以轻松掌握每个开发者的权限。但如果中央服务器故障的话，就无法提交更新，而且如果没备份，就有丢失数据的危险。</p><h3 id="分布式的版本控制系统"><a href="#分布式的版本控制系统" class="headerlink" title="分布式的版本控制系统"></a>分布式的版本控制系统</h3><p>比如Git等，客户端并不只提取最新版本的文件快照，而是把代码仓库完全的镜像下来。这样，任何一处协同工作的服务器发生故障，事后都可以用任意一个镜像出来的本地仓库恢复。</p><h2 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h2><h3 id="直接记录快照，而非差异比较"><a href="#直接记录快照，而非差异比较" class="headerlink" title="直接记录快照，而非差异比较"></a>直接记录快照，而非差异比较</h3><p>Git 和其他版本控制系统的主要差别在于，Git 只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异。这类系统（CVS，Subversion，Perforce，Bazaar 等等）每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容。</p><p>Git 并不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。</p><h3 id="近乎所有操作的都是本地执行"><a href="#近乎所有操作的都是本地执行" class="headerlink" title="近乎所有操作的都是本地执行"></a>近乎所有操作的都是本地执行</h3><p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。但如果用 CVCS 的话，差不多所有操作都需要连接网络。因为 Git 在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快。</p><h3 id="时刻保持数据完整性"><a href="#时刻保持数据完整性" class="headerlink" title="时刻保持数据完整性"></a>时刻保持数据完整性</h3><p>在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。</p><h3 id="文件的三种状态"><a href="#文件的三种状态" class="headerlink" title="文件的三种状态"></a>文件的三种状态</h3><p>对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。</p><ul><li>已修改表示修改了文件，但还没保存到数据库中。</li><li>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li><li>已提交表示数据已经安全地保存在本地数据库中。</li></ul><p>这会让我们的 Git 项目拥有三个阶段：工作区、暂存区以及 Git 目录。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/areas.png" alt="工作区、暂存区以及 Git 目录。" loading="lazy"></p><center>工作目录，暂存区域，以及Git仓库</center><p>工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p><p>暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。</p><p>Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。</p><p>基本的 Git 工作流程如下：</p><ol><li>在工作区中修改文件。</li><li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li><li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</li></ol><h2 id="初次运行Git前的配置"><a href="#初次运行Git前的配置" class="headerlink" title="初次运行Git前的配置"></a>初次运行Git前的配置</h2><p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p><ol><li><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 <code>git config</code> 时带上 <code>--system</code> 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）</li><li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户。 你可以传递 <code>--global</code> 选项让 Git 读写此文件，这会对你系统上 <strong>所有</strong> 的仓库生效。</li><li>当前使用仓库的 Git 目录中的 <code>config</code> 文件（即 <code>.git/config</code>）：针对该仓库。 你可以传递 <code>--local</code> 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。）</li></ol><p>每一个级别会覆盖上一级别的配置，所以 <code>.git/config</code> 的配置变量会覆盖 <code>/etc/gitconfig</code> 中的配置变量。</p><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>第一个要配置的是你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：</p><pre class="language-shell" data-language="shell"><code class="language-shell">$ git config --global user.name &quot;名字&quot;$ git config --global user.email 邮箱</code></pre><p>如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置。</p><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><p>接下来要设置的是默认使用的文本编辑器。Git 需要你输入一些额外消息的时候，会自动调用一个外部文本编辑器给你用。默认会使用操作系统指定的默认编辑器，一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：</p><pre class="language-shell" data-language="shell"><code class="language-shell">$ git config --global core.editor emacs</code></pre><h3 id="差异分析工具"><a href="#差异分析工具" class="headerlink" title="差异分析工具"></a>差异分析工具</h3><p>还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：</p><pre class="language-shell" data-language="shell"><code class="language-shell">$ git config --global merge.tool vimdiff</code></pre><p>Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。</p><h3 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h3><p>要检查已有的配置信息，可以使用 <code>git config --list</code> 命令：</p><pre class="language-shell" data-language="shell"><code class="language-shell">$ git config --listdiff.astextplain.textconv&#x3D;astextplainfilter.lfs.clean&#x3D;git-lfs clean -- %ffilter.lfs.smudge&#x3D;git-lfs smudge -- %ffilter.lfs.process&#x3D;git-lfs filter-processfilter.lfs.required&#x3D;truehttp.sslbackend&#x3D;opensslhttp.sslcainfo&#x3D;E:&#x2F;Git&#x2F;mingw64&#x2F;ssl&#x2F;certs&#x2F;ca-bundle.crtcore.autocrlf&#x3D;truecore.fscache&#x3D;truecore.symlinks&#x3D;falsecore.editor&#x3D;&quot;E:\\Notepad++\\notepad++.exe&quot; -multiInst -notabbar -nosession -noPluginpull.rebase&#x3D;falsecredential.helper&#x3D;manageruser.name&#x3D;zzugzjuser.email&#x3D;1045643052@qq.comfilter.lfs.clean&#x3D;git-lfs clean -- %ffilter.lfs.smudge&#x3D;git-lfs smudge -- %fshellfilter.lfs.process&#x3D;git-lfs filter-processfilter.lfs.required&#x3D;truecredential.helper&#x3D;manager</code></pre><p>有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 <code>/etc/gitconfig</code> 和 <code>~/.gitconfig</code>），不过最终 Git 实际采用的是最后一个。</p><p>也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：</p><pre class="language-shell" data-language="shell"><code class="language-shell">$ git config user.namezzugzj</code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第13章 线程安全与锁优化</title>
      <link href="posts/149dbda3/"/>
      <url>posts/149dbda3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在软件业发展的初期，程序编写都是以算法为核心的，程序员会把数据和过程分别作为独立的部分来考虑，数据代表问题空间中的客体，程序代码则用于处理这些数据，这种思维方式直接站在计算机的角度去抽象问题和解决问题，称为面向过程的编程思想。与此相对的是，面向对象的编程思想是站在现实世界的角度去抽象和解决问题，它把数据和行为都看做是对象的一部分，这样可以让程序员能以符合现实世界的思维方式来编写和组织程序。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。</p><h3 id="Java语言中的线程安全"><a href="#Java语言中的线程安全" class="headerlink" title="Java语言中的线程安全"></a>Java语言中的线程安全</h3><p>线程安全，限定于多个线程之间存在共享数据访问这个前提，因为如果一段代码根本不会与其他线程共享数据，那么从线程安全的角度来看，程序是串行执行还是多线程执行对它来说是完全没有区别的。</p><p>按照线程安全的 “安全程度” 由强至弱来排序，可以将 Java 语言中各个操作共享的数据分为以下 5 类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p><h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><p>在 Java 语言中，不可变（Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要采取任何的线程安全保障措施。</p><p>Java 语言中，如果共享数据是一个基本数据类型，那么只要在定义时使用 final 关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行，比如 String 类的对象，它是一个典型的不可变对象，我们调用它的 substring()、replace() 和 concat() 这些方法都不会影响它原来的值，只会返回一个新的构造的字符串对象。</p><h4 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h4><p>绝对的线程安全完全满足 Brian Goetz 给出的线程安全的定义，这个定义其实是很严格的，一个类要达到 “不管运行是环境如何，调用者都不需要任何额外的同步措施” 通常需要付出很大的，甚至有时候是不切实际的代价。在 Java API 中标注自己是线程安全的类，大多数都不是绝对的线程安全。比如vector，它的方法都是synchronized修饰的，但如果多个方法一起用时，还是会有线程安全问题。</p><h4 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h4><p>相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p><h4 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h4><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。</p><h4 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h4><p>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。</p><p>常见的线程对立的操作有 System.setIn()、System.setOut() 和 System.runFinalizerosOnExit() 等。</p><h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><h4 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h4><p>互斥同步是一种最常见也是最主要的并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用。</p><p>在Java中，最基本的互斥同步手段就说synchronized关键字，是一种块结构同步语法。synchronized 关键字经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码都需要一个 reference 类型的参数来指明要锁定和解锁的对象。如果 Java 程序中的 synchronized 明确指定了对象参数，那就是这个对象的 reference；如果没有明确指定，那就根据 synchronized 修饰的是实例方法还是类方法，去取对应的对象实例或 Class 对象来作为锁对象。</p><p>根据虚拟机规范的要求，在执行 monitorenter 指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加 1，相应的，在执行 monitorexit 指令时将锁计数器减 1，当计数器为 0 时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，知道对象锁被另外一个线程释放为止。</p><p>在虚拟机规范对 monitorenter 和 monitorexit 的行为描述中，有两点是需要特别注意的。</p><ul><li>synchronized 同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。</li><li>同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。不能像处理某些数据库的锁一样，强制已获取锁的线程释放锁。</li></ul><p>除了 synchronized 之外，我们还可以使用 java.util.concurrent包中的重入锁(ReentrantLock)来实现同步，在基本用法上，ReentrantLock 与 synchronized 很相似，他们都具备一样的线程重入特性，只是代码写法上有点区别，一个表现为 API 层面的互斥锁(lock() 和 unlock() 方法配合 try/finally 语句块来完成)，另一个表现为原生语法层面的互斥锁。不过，相比 synchronized，ReentrantLock 增加了一些高级功能：</p><ul><li>等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。</li><li>公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。</li><li>锁绑定多个条件：是指一个 ReentrantLock 对象可以同时绑定多个 Condition 对象，而在 synchronized 中，锁对象的 wait() 和 notify() 或 notifyAll() 方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁，而 ReentrantLock 则无须这样做，只需要多次调用 newCondition() 方法即可。</li></ul><p>jdk1.5时，Lock的性能优于synchronized，JDK 1.6 发布之后，人们就发现 synchronized 与 ReentrantLock 的性能基本上是完全持平了。synchronized是Java语法层面的同步，足够清晰，简单。Lock应保证在finally块中释放锁。长远看，Java虚拟机更容易针对synchronized进行优化，因为Java虚拟机可以在线程和对象的元数据中记录synchronized中锁的相关信息，而使用Lock，Java虚拟机很难知道具体那些锁对象是由特定线程掌控的。</p><h4 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h4><p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization）。</p><p>从处理问题的方式上来说，互斥同步属于一种悲观的并发策略，无论共享数据是否真的会出现竞争，它都要进行加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。随着硬件指令集的发展，我们有了另外一个选择：基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，知道成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization）。</p><p>硬件保证一个从语法上看起来需要多次操作的行为只通过一条处理器指令就能完成，这类指令常用的有：</p><ul><li>测试并设置（Test-and-Set）。</li><li>获取并增加（Fetch-and-Increment）。</li><li>交换（Swap）。</li><li>比较并交换（Compare-and Swap，下文成 CAS）。</li><li>加载连接 / 条件存储（Load-Linked / Store-Conditional，下文称 LL/SC）。</li></ul><p>CAS 指令需要有 3 个操作数，分别是内存位置（在 Java 中可以简单理解为变量的内存地址，用 V 表示）、旧的预期值（用 A 表示）和新值（用 B 表示）。CAS 指令执行时，当且仅当 V 符合旧值预期值 A 时，处理器用新值 B 更新 V 的值，否则它就不执行更新，但是无论是否更新了 V 的值，都会返回 V 的旧值，上述的处理过程是一个原子操作。</p><p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然为 A 值，那我们就能说它没有被其他线程改变过了吗？如果在这段期间它的值曾经被改成了 B，后来又被改回 A，那 CAS 操作就会误认为它从来没有被改变过。这个漏洞称为 CAS 操作的 “ABA” 问题。J.U.C 包为了解决这个问题，提供了一个带有标记的原子引用类 “AtomicStampedReference”，它可以通过控制变量值的版本来保证 CAS 的正确性。不过目前来说这个类比较 “鸡肋”，大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p><h4 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h4><p><strong>可重入代码：</strong>可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回之后，原来的程序不会出现任何的错误。</p><p>可重入代码有一些公共的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数传入、不调用非可重入的方法等。简而言之：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。</p><p><strong>线程本地存储：</strong>如果一段代码所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，即是无同步也能做到避免数据争用。</p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>HotSpot 虚拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，如适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁膨胀（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）等。</p><h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><p>共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程 “稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</p><p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的时间由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如 100 个循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p> 锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判定在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把他们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</p><p>大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁是 JDK 1.6 之中加入的新型锁机制，它名字中的 “轻量级” 是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就称为 “重量级” 锁。</p><p>要理解轻量级锁，以及后面会讲到的偏向锁的原理和运作过程，必须从 HotSpot 虚拟机的对象（对象头部分）的内存布局开始介绍。HotSpot 虚拟机的对象头（Object Header）分为两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC 分代年龄（Generational GC Age）等，这部分数据是长度在 32 位和 64 位的虚拟机中分别为 32 bit 和 64 bit，官方称它为 “Mark Word”，它是实现轻量级锁和偏向锁的关键。另外一部分用于存储指向方法区对象类型数据的指针，如果是数组对象的话，还会有一个额外的部分用于存储数组长度。</p><p>对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Work 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如，在 32 位的 HotSpot 虚拟机中对象未被锁定的状态下，Mark Word 的 32bit 空间中的 25bit 用于存储对象哈希码（HashCode），4bit 用于存储对象分代年龄，2bit 用于存储锁标志位，1bit 固定为 0，在其他状态（轻量级锁定、重量级锁定、GC 标记、可偏向）下对象的存储内容见下表。</p><p><img src="https://i.loli.net/2020/05/20/7kTIqEiSYAgCfoc.png" alt="image-20200520164847713.png" loading="lazy"></p><p>简单地介绍了对象的内存布局后，我们把话题返回到轻量级锁的执行过程上。在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为 “01” 状态）虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝（官方把这份拷贝加上了一个 Displaced 前缀，即 Displaced Mark Word），这时候线程堆栈与对象头的状态如图所示。</p><p><img src="https://i.loli.net/2020/05/20/zt3Vm4NgQAowTnj.png" alt="image-20200520165426050" loading="lazy"></p><p>然后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位 （Mark Word 的最后 2bit）将转变为 “00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如图所示。</p><img src="https://i.loli.net/2020/05/20/ulMwXaG86IqKeCN.png" alt="image-20200520165508349.png" style="zoom:50%;" / loading="lazy"><p>如果这个更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果只说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象以及被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，所标志的状态变为 “10”，Mark Word 中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。</p><p>上面描述的是轻量级锁的加锁过程，它的解锁过程也是通过 CAS 操作来进行的，如果对象的 Mark Word 仍然指向着线程的锁记录，那就用 CAS 操作把对象当前的 Mark Word 和线程中复制的 Displaced Mark Word 替换回来，如果替换成功，整个同步过程就完成了。如果替换失败，说明有其他线程尝试过获取该锁，那就要释放锁的同时，唤醒被挂起的线程。</p><p>轻量级锁能提升程序同步性能的依据是 “对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了 CAS 操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁也是 JDK 1.6 中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不做了。</p><p>当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如加锁、解锁及对Mark Word的Update等）。</p><p>当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向（Revoke Bias）后恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就如上面介绍的轻量级锁那样执行。偏向锁、轻量级锁的状态转化及对象Mark Word的关系如图所示。<br><img src="https://i.loli.net/2020/05/20/9wDARWEOJipsqSP.png" loading="lazy"></p><p>偏向锁可以提高带有同步但无竞争的程序性能。它同样是一个带有效益权衡（Trade Off）性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数 -XX:-UseBiasedLocking 来禁止偏向锁优化反而可以提升性能。</p>]]></content>
      
      
      <categories>
          
          <category> 深入理解Java虚拟机读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第12章 Java内存模型与线程</title>
      <link href="posts/dcd6417a/"/>
      <url>posts/dcd6417a/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>由于计算机在运行时，大部分时间都花在了磁盘I/O、网络通信或者数据库访问上，处理器在大部分时间都处于等待其他资源的空闲状态，让计算机同时处理几项任务就说最容易想到，也是很有效的压榨手段。</p><p>衡量一个服务性能的好坏，每秒事务处理数(Transaction Per Second，TPS)是重要指标之一，它代表着一秒内服务端平均能响应的请请求总数，TPS值和并发能力有很密切的关系。</p><h2 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h2><p>现代计算机系统都有一层或多层的高速缓存来作为内存和处理器之间的缓冲，将运算需要使用的数据复制到缓存中，让计算快速进行，运算结束后从缓存同步到内存，这样处理器就不用等待缓慢的内存读写了。</p><p>但这样有了一个新的问题：缓存一致性。在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，这种系统叫共享内存多核系统。</p><p><img src="https://i.loli.net/2020/05/18/jakwtmyhWT3BOGF.png" alt="image-20200518223313896" loading="lazy"></p><p>除了增加高速缓存外，为了使处理器内部的运算单元尽量被充分使用，处理器可能对输入的代码进行乱序执行优化，处理器会将计算结果重组，保证该结果与顺序执行的结果一致，因此如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性不能靠代码的先后顺序来保证。与处理器的乱序优化类似，Java虚拟机的即时编译器也有指令重排序优化。</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p>Java内存模型的主要目的是定义程序中个中变量的访问规则，即关注在虚拟机中吧变量值存储到内存和从内存取出变量值的底层细节。这里说的变量包括实例字段、静态字段和构成数组对象的元素，但不包括局部变量和方法参数，因为后者是线程私有的，不存在竞争问题。</p><p>Java内存模型规定了所有变量都存储在主内存中。每条线程还有自己的工作内存，它保存了被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p><p><img src="https://i.loli.net/2020/05/19/I76PQuXMJmLHdEe.png" alt="image-20200519115204571" loading="lazy"></p><h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>关于一个变量如何从主内存拷贝到工作内存又如何从工作内存同步回主内存这一类的实现细节，Java内存模型定义了以下8种操作。Java虚拟机实现时必须保证下面的操作都是原子的：</p><ul><li>lock(锁定)：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li><li>unlock(解锁)：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read(读取)：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use(使用)：作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时会执行这个操作。</li><li>assign(赋值)：作用于工作内存的变量，它会把一个执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store(存储)：作用于工作内存的变量，它把工作内存中的一个变量的值传送给主内存中，以便随后的write操作使用。</li><li>write(写入)：作用于主内存的变量，它把store操作从工作内存得到的变量的值放入主内存的变量中。</li></ul><p>如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序执行store和write操作。Java内存模型要求上述操作按顺序执行，但不要钱连续执行，也就是read和load操作间可以有别的指令。如对变量a、b进行访问时，一种可能出现的顺序就是read a、read b、load b、load a。</p><p>Java内存模型还规定了在执行上述8中基本操作时必须满足的规则：</p><ul><li>不允许read和load、store和write操作之一单独出现，即不允许加载或同步工作到一半。</li><li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后，必须把改变化同步回主内存。</li><li>不允许一个线程无原因地（无assign操作）把数据从工作内存同步到主内存中。</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未初始化(load或assign)的变量。</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次lock之后必须要执行相同次数的unlock操作，变量才会解锁。</li><li>如果对一个对象进行lock操作，那会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li><li>如果一个变量事先没有被lock，就不允许对它进行unlock操作，也不允许去unlock一个被其他线程锁住的变量。</li><li>对一个变量执行unlock操作之前，必须将此变量同步回主内存中（执行store、write）。</li></ul><p>有如上8种内存访问操作以及规则限定，再加上对volatile的一些特殊规定，就已经完全确定了java程序中哪些内存访问操作是在并发下安全的。</p><h3 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h3><p>关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制。</p><p>当一个变量被定义为volatile后，它将具备两个特性：第一个就是保证此变量对所有线程的可见性，就是指一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量需要通过主内存完成线程间的传递；第二个就是禁止指令重排序优化，重排序优化是机器级的操作，也就是硬件级别的操作。重排序会打乱代码顺序执行，但会保证在执行过程中所有依赖赋值结果的地方都能获取到正确的结果，因此在一个线程的方法执行过程中无法感知到重排的操作影响，这也是“线程内表现为串行”的由来。</p><p><img src="https://i.loli.net/2020/05/19/wcyqszaFiJu9lh5.png" alt="image-20200519182215684" loading="lazy"></p><p>编译后，这段代码对instance变量赋值部分如下图所示：</p><p><img src="https://i.loli.net/2020/05/19/4QG79OV8FLRpYoJ.png" alt="image-20200519182250093.png" loading="lazy"></p><p>其实，有volatile修饰的变量，赋值后(mov %eax, 0x150(%esi))多执行了一个”lock addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障：指令重排序时，不能把后面的指令重排序到内存屏障之前。</p><p>另外，java内存模型对volatile变量有三条特殊规则：</p><ul><li><p>每次使用变量之前都必须先从主内存刷新最新的值，用于保证能看见其它线程对变量的修改；</p></li><li><p>每次对变量修改后都必须立刻同步到主内存中，用于保证其它线程可以看到自己的修改；</p></li><li><p>两个变量都是volatile的，将数据同步到内存的时候，先读的先写；</p></li></ul><p>性能上，volatile同步机制的性能优于锁，读操作上性能消耗和普通变量没什么区别，但写操作可能慢一些，因为它需要在本地代码插入许多内存屏障指令来保证处理器不发生乱序执行。</p><h3 id="针对long和double型变量的特殊规则"><a href="#针对long和double型变量的特殊规则" class="headerlink" title="针对long和double型变量的特殊规则"></a>针对long和double型变量的特殊规则</h3><p>Java内存模型要求lock、unlock、read、load、assign、use、store、write都具有原子性，但对于64位的数据类型(long和double)，定义了比较宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作进行，即允许虚拟机实现自行选择是否要保证64位数据类型的load、store、read、write操作的原子性。</p><h3 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h3><p><strong>原子性</strong></p><p>我们大致可以认为基本数据类型的访问读写具备原子性的(long、double除外，无需该在意)。</p><p>如果应用场景需要更大范围的原子性保证，Java内存模型还提供了lock、unlock操作来满足这个需求。虽然虚拟机没有把这两个操作直接开放给用户，但是提供了更高层次的字节码指令monitorenter和monitorexit，这两个字节码指令反映到Java代码中就是同步块。synchronized，因此同步块中的操作具备原子性的。</p><p><strong>可见性</strong></p><p>指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。volatile保证了多线程操作时变量的可见性，普通变量则不能保证这一点。</p><p>除了volatile外，Java还有两个关键字能实现可见性：synchronized和final。</p><p>同步块的可见性是因为：对一个变量执行unlock前，必须先把此变量同步回主内存中。final的可见性是：被final修饰的字段在构造器中一旦初始化完成，那么在其他线程中就能看到final字段的值。</p><p><strong>有序性</strong></p><p>如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是”线程内表现为串行的语义”，后半句是”指令重排序”和”工作内存与主内存同步延迟”。</p><p>Java提供volatile和synchronized关键字来保证线程之间操作的有序性，volatile本身包含了禁止指令重排序优化的语义，而synchronized是因为”一个变量在同一时刻只允许一条线程对其进行lock操作”。</p><h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>如果Java内存模型的有序性只靠volatile和synchronized完成，那么有一些操作会很繁琐，所以，Java中有一个”先行发生”的原则。</p><p>先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，也就是说发生操作B之前，操作A产生的影响能被操作B观察到，”影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p><p>Java内存模型中的一些内置的先行发生关系：</p><ul><li>程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。</li><li>管程锁定规则：一个unlock操作先行发生与后面对同一个锁的lock操作。</li><li>volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量对读操作。</li><li>线程启动规则：Thread对象对start()方法先行发生于此线程的每一个动作。</li><li>线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止。</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li><li>对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。</li><li>传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A就先行发生于操作C。</li></ul><h2 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h2><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源(内存地址、文件I/O等)，又可以独立调度(线程是CPU调度的基本单位)。</p><p>实现线程主要有3种方式：</p><p>1.使用内核线程实现</p><p>内核线程(Kernel-Level Thread，KLT)就是直接由操作系统内核(Kernel)支持的线程，这种线程由内核完成线程切换，内核通过操纵调度器对线程进行调度，并负责将心线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核叫做多线程内核。</p><p>程序一般不会直接使用内核线程，而去使用内核线程的一种高级接口——轻量级进程(Light Weight Process，LWP)，轻量级进程就是我们所说的”线程”，每个轻量级进程都由一个内核线程支持，轻量级进程与内核线程之间1:1的关系称为一对一的线程模型。</p><p>由于内核线程的支持，每个轻量级进程都称为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作，但是轻量级进程具有它的局限性：由于基于内核线程实现的，所以各种线程操作(创建、析构、同步)都需要进行系统调用。而系统调用的代价相对较高，需要在用户态(User Mode)和内核态(Kernel Mode)中来回切换；再一个就是每个轻量级进程都需要一个内核线程的支持，因此轻量级进程要消耗一定的内核资源(如内核线程的栈空间)，因此一个系统支持轻量进程的数量是有限的。</p><p>2.使用用户线程实现</p><p>广义上说，一个线程只要不是内核线程，就可以认为是用户线程(User Thread，UT)。所以，这么看的话，轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核上的，许多操作都要进行系统调用，效率收到限制。</p><p>狭义上的用户线程指完全建立在用户空间的线程库上，用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核帮助。这种线程不需要切换到内核态，因此操作可以非常快速且低耗，支持规模更大的线程数。</p><p>用户线程优势在于不需要系统内核支援，劣势也是在于没有系统内核支援。线程的创建、切换和调度都是需要考虑的问题，由于操作系统只把处理器资源分配到进程，如”阻塞如何处理”、”多处理器系统中如何将线程映射到其他处理器上”这类问题解决异常困难。现在使用用户线程的程序越来越少了，Java、Ruby等都曾使用过，但最后都放弃了。</p><p>3.使用用户线程+轻量级进程混合实现</p><p>这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且支持大规模的用户线程并发；操作系统提供支持的轻量级进程作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用通过轻量级进程线程完成，大大降低了整个进程被完全阻塞的风险。</p><p>4.Java线程的实现</p><p>操作系统支持怎样的线程模型，很大程度上会影响上面 Java虚拟机的线程是怎样映射的，这一点在不同平台上很难达成一致，因此《Java虚拟机规范》中没有限定Java线程需要使用那种线程模型来实现。</p><h3 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h3><p>线程调度是系统为线程分配处理器使用权的过程，调度主要方式有两种，分别是协同式线程调度和抢占式线程调度。</p><p>协同式调度的多线程系统</p><ul><li><p>线程的执行时间由线程本身控制，线程把自己的工作执行完后，主动通知系统切换到另一个线程上。由于线程把自己的事情做完后才会进行线程切换，所以没什么线程同步的问题。</p><p>缺点：线程执行时间不可由控制。如果一个线程有问题，一直不告知系统进行线程切换，那么程序就一直阻塞在那。</p></li></ul><p>抢占式调度的多线程系统</p><ul><li><p>每个线程由系统分配执行时间，线程的切换不由线程本身决定(Java中，Thread.yield()方法可以让出执行时间，但要获取执行时间，线程本身是没有办法的)。</p><p>这种实现方式下，线程的执行时间是系统可控的 ，也不会由一个线程导致整个进程阻塞的问题，Java的线程调度就是抢占式调度。</p></li></ul><p>Java中虽然线程调度是系统完成的，但是我们可以使系统给某些进程多分配一些时间，另外的线程少分配一些。这项操作通过设置线程优先级来完成：Java中一共有10个级别的线程优先级，在两个线程同时Ready状态时，优先级越高的线程越容易被系统选择执行。</p><p>但线程优先级不稳定，优先级可能被系统自行改变，当系统发现一个线程执行很频繁时，可能会越过线程优先级去为他分配执行时间，从而减少线程频繁切换带来的性能消耗。</p><h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>Java语言定义了6种线程状态，在任意一个时间点，一个线程有且只有其中一种状态：</p><ul><li><p>新建(New)：创建后尚未启动的线程处于这种状态。</p></li><li><p>运行(Runable)：Runable包括了操作系统线程状态中的Running和Ready。(也就是处于此状态的线程可能正在执行，也可能正在等待着CPU为它分配时间执行)。</p></li><li><p>无限期等待(Waiting)：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显示唤醒。以下方法会让线程进入无限期的等待：</p><ul><li>没有设置Timeout参数的Object.wait()方法</li><li>没有设置Timeout参数的Thread.join()方法</li><li>LockSupport.park()方法</li></ul></li><li><p>限期等待(Timed Waiting)：处于这种状态的线程也不会被分配CPU时间，在一定时间后它们由系统自动唤醒。以下方法让线程进入限期等待：</p><ul><li>Thread.sleep()</li><li>设置了Timeout参数的Object.wait()方法</li><li>设置了Timeout参数的Thread.join()方法</li><li>LockSupport.parkNanos()</li><li>LockSupport.parkUntil()</li></ul></li><li><p>阻塞(Blocked)：线程被阻塞。”阻塞状态”与”等待状态”的区别是：”阻塞状态”在等待着获取一个排它锁，这个时间将在另一个线程放弃这个锁的时候发生；”等待状态”是等待一段时间或唤醒的动作发生。</p></li><li><p>结束(Terminated)：已终止线程的状态，线程结束执行。</p></li></ul><p><img src="https://i.loli.net/2020/05/19/5zG7eBvQkTgNfMJ.png" alt="image-20200519212052995" loading="lazy"></p><h3 id="Java与协程"><a href="#Java与协程" class="headerlink" title="Java与协程"></a>Java与协程</h3><p>内核线程调度成本比较高昂，因为要进行响应中断，保护和恢复执行现场。当中断发生，线程A切换到线程B前，操作系统首先要把线程A的上下文数据妥善保护好，然后把寄存器、内存分页等恢复到线程B挂起时候的状态，这样线程B被重新激活后才能仿佛没有被挂起过。</p><p>协程的主要优势是轻量，无论有栈协程还是无栈协程，都比传统内核线程轻量的多。不设置-Xss或-XX:ThreadStackSize，则在64位Linux上HotSpot的线程栈容量是1MB，但一个协程的栈通常在几百字节到几KB之间。</p><p>但在Java语言上，比如HotSpot虚拟机，Java调用栈和本地调用栈是做在一起的，在协程中调用本地方法的话，切换协程可能影响整个线程，在这里，以后将会有一种叫纤程的东西来解决。Loom以后将会实现。</p>]]></content>
      
      
      <categories>
          
          <category> 深入理解Java虚拟机读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第10章 前端编译与优化</title>
      <link href="posts/17958411/"/>
      <url>posts/17958411/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前端编译器   把*.java文件转变成*.class文件，如JDK的Javac、Eclipse JDT的增量式编译器(ECJ)。</p><p>即时编译器（JIT，Just In Time Compiler），运行期把字节码转变成本地机器码，如HotSpot的C1、C2编译器。</p><p>提前编译器（AOT，Ahead Of Time Compiler），直接把程序编译成与目标机器指令集相关二进制代码，如JDK的Jaotc、GNU Compiler for the Java（GCJ）。</p><h2 id="Javac编译器"><a href="#Javac编译器" class="headerlink" title="Javac编译器"></a>Javac编译器</h2><h3 id="Javac的源码以及调试"><a href="#Javac的源码以及调试" class="headerlink" title="Javac的源码以及调试"></a>Javac的源码以及调试</h3><p>分析源码是了解一项技术的实现内幕最彻底的手段，Javac编译器不像HotSpot虚拟机那样使用C++语言（包含少量C语言）实现，它本身就是一个由Java语言编写的程序，这为纯Java的程序员了解它的编译过程带来了很大的便利。</p><p>从Javac代码的总体结构来看，编译过程大致可以分为1个准备过程和3个处理过程，它们分别如下所示。</p><ol><li>准备过程：初始化插入式注解处理器。</li><li>解析与填充符号表过程，包括<ul><li>词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树。</li><li>填充符号表。产生符号地址和符号信息。</li></ul></li><li>插入式注解处理器的注解处理过程：插入式注解处理器的执行阶段。</li><li>分析与字节码生成过程，包括：<ul><li>标注检查。对语法的静态信息进行检查。</li><li>数据流及控制流分析。对程序动态运行过程进行检查。</li><li>解语法糖。将简化代码编写的语法糖还原为原有的形式。</li><li>字节码生成。将前面各个步骤所生成的信息转化成字节码。</li></ul></li></ol><p>上述3个处理过程里，执行插入式注解时又可能会产生新的符号，如果有新的符号产生，就必须转回到之前的解析、填充符号表的过程中重新处理这些新符号，从总体来看，三者之间的关系与交互顺序如图10-4所示。</p><p><img src="https://i.loli.net/2020/07/03/W1QYc962OAHaiJU.png" alt="image-20200703203430603.png" loading="lazy"></p><h3 id="解析与填充符号表"><a href="#解析与填充符号表" class="headerlink" title="解析与填充符号表"></a>解析与填充符号表</h3><h4 id="词法、语法分析"><a href="#词法、语法分析" class="headerlink" title="词法、语法分析"></a>词法、语法分析</h4><p>词法分析</p><p>将源码中的字符流转变为标记（Token）集合的过程。关键字、变量名、运算符等都可作为标记。比如下面一行代码：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> a <span class="token operator">=</span> b <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span></code></pre><p>在字符流中，关键字 int 由三个字符组成，但它是一个独立的标记，不可再分。</p><p>该过程有点类似“分词”的过程。虽然这些代码我们一眼就能认出来，但编译器要逐个分析过之后才能知道。</p><p>语法分析</p><p>根据上面的标记序列构造抽象语法树的过程。</p><blockquote><p>抽象语法树（Abstract Syntax Tree，AST）是一种用来描述程序代码语法结构的树形表示方法，每个节点都代表程序代码中的一个语法结构（Syntax Construct），比如包、类型、修饰符等。</p></blockquote><p>通俗来讲，词法分析就是对源码文件做分词，语法分析就是检查源码文件是否符合 Java 语法。</p><h4 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h4><p>符号表（Symbol Table）是一种数据结构，它由一组符号地址和符号信息组成（类似“键-值”对的形式）。</p><p>符号由抽象类 com.sun.tools.javac.code.Symbol 表示，Symbol 类有多种扩展类型的符号，比如 ClassSymbol 表示类、MethodSymbol 表示方法等。</p><p>符号表记录的信息在编译的不同阶段都要用到，如：</p><ul><li><p>用于语义检查和产生中间代码；</p></li><li><p>在目标代码生成阶段，符号表是对符号名进行地址分配的依据。</p></li></ul><p>这个阶段主要是根据上一步生成的抽象语法树列表完成符号填充，返回填充了类中所有符号的抽象语法树列表。</p><h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3><p>JDK 5 提供了注解（Annotations）支持，JDK 6 提供了“插入式注解处理器”，可以在「编译期」对代码中的特定注解进行处理，从而影响前端编译器的工作过程。比如Lombok。</p><h3 id="语义分析与字节码生成"><a href="#语义分析与字节码生成" class="headerlink" title="语义分析与字节码生成"></a>语义分析与字节码生成</h3><p>抽象语法树能表示一个结构正确的源程序，却无法保证语义是否符合逻辑。</p><p>而语义分析就对语法正确的源程序结合上下文进行相关性质的检查（类型检查、控制流检查等）。比如：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> b <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">// 这样赋值显然是错误的</span><span class="token comment">// 但在语法上是没问题的，这个错误是在语义分析时检查的</span><span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span></code></pre><p>Javac 在编译过程中，语义分析过程可分为标注检查和数据及控制流分析两个步骤。</p><h4 id="标注检查"><a href="#标注检查" class="headerlink" title="标注检查"></a>标注检查</h4><p>检查内容：变量使用前是否已被声明、变量与赋值之间的数据类型是否匹配等。</p><p>常量折叠</p><p>该过程中，还会进行一个常量折叠（Constant Folding）的代码优化。</p><p>比如，我们在代码中定义如下：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span></code></pre><p>在抽象语法树上仍能看到字面量 “1”、”2” 和操作符 “+”，但经过常量折叠优化后，在语法树上将会被标注为 “3”。</p><h4 id="数据及控制流分析"><a href="#数据及控制流分析" class="headerlink" title="数据及控制流分析"></a>数据及控制流分析</h4><p>主要检查内容：</p><ul><li><p>局部变量使用前是否赋值</p></li><li><p>方法的每条路径是否有返回值</p></li><li><p>受检查异常是否被正确处理等</p></li></ul><h4 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h4><blockquote><p>语法糖（Syntactic Sugar）：也称糖衣语法，指的是在计算机语言中添加某种语法，该语法对语言的编译结果和功能并没有实际影响，却能更方便程序猿使用该语言。</p></blockquote><p>PS: 就是让我们写代码更舒服的语法，像吃了糖一样甜。</p><p>Java 中常见的语法糖有泛型、变长参数、自动装箱拆箱等。</p><p>JVM 其实并不支持这些语法，它们在编译阶段要被还原成原始的基础语法结构。该过程就称为解语法糖（打回原形）。</p><h4 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h4><p>Javac 编译过程的最后一个阶段。主要是把前面各个步骤生成的信息转换为字节码指令写入磁盘中。</p><p>此外，编译器还进行了少量的代码添加和转换工作。比如实例构造器&lt;init&gt;() 和类构造器&lt;clinit&gt;() 方法就是在这个阶段被添加到语法树的。这里的实例构造器并不等同于默认构造函数，如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、可访问性与当前类型一致的默认构造函数，这个工作在填充符号表阶段中就已经完成。</p><p>&lt;init&gt;()和&lt;clinit&gt;()这两个构造器的产生实际上是一种代码收敛的过程，编译器会把语句块（对于实例构造器而言是“{}”块，对于类构造器而言是“static{}”块）、变量初始化（实例变量和类变量）、调用父类的实例构造器等操作收敛到&lt;init&gt;()和&lt;clinit&gt;()方法之中，并且保证无论源码中出现的顺序如何，都一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行，上面所述的动作由Gen::normalizeDefs()方法来实现。除了生成构造器以外，还有其他的一些代码替换工作用于优化程序某些逻辑的实现方式，如把字符串的加操作替换为StringBuffer或StringBuilder（取决于目标代码的版本是否大于或等于JDK 5）的append()操作，等等。</p><h2 id="Java语法糖的味道"><a href="#Java语法糖的味道" class="headerlink" title="Java语法糖的味道"></a>Java语法糖的味道</h2><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型这个概念大家应该都不陌生，Java 是从 5.0 开始支持泛型的。</p><p>由于历史原因，Java 使用的是“类型擦除式泛型（Type Erasure Generics）”，也就是泛型只会在源码中存在，编译后的字节码文件中，全部泛型会被替换为原先的裸类型（Raw Type）。</p><p>因此，在运行期间 List&lt;String&gt; 和 List&lt;Integer&gt; 其实是同一个类型。例如：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> l1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        l1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> l2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        l2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>经编译器擦除类型后：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">GenericTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> var0<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 原先的泛型都没了</span>        <span class="token class-name">ArrayList</span> var1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        var1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ArrayList</span> var2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        var2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>类型擦除是有缺点的，比如：由于类型擦除，会将泛型的类型转为 Object，但是 int、long 等原始数据类型无法与 Object 互转，这就导致了泛型不能支持原始数据类型。进而引起了使用包装类（Integer、Long 等）带来的拆箱、装箱问题。</p><p>运行期无法获取泛型信息。</p><h3 id="自动装箱、拆箱与遍历"><a href="#自动装箱、拆箱与遍历" class="headerlink" title="自动装箱、拆箱与遍历"></a>自动装箱、拆箱与遍历</h3><p>遍历代码示例</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>反编译版本 1：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">GenericTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 使用了迭代器 Iterator 遍历</span>        <span class="token class-name">Iterator</span> var2 <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>var2<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>var2<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>反编译版本 2：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 创建一个数组</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> list<span class="token punctuation">)</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>不同的反编译器得出的结果可能有所不同，这里找了两个版本对比分析。</p><p>从上面两个版本的反编译结果可以看出：Arrays.asList() 方法其实创建了一个数组，而增强 for 循环实际调用了迭代器 Iterator。</p><p>自动拆装箱代码示例</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token class-name">Integer</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token class-name">Integer</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token class-name">Integer</span> d <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token class-name">Integer</span> e <span class="token operator">=</span> <span class="token number">321</span><span class="token punctuation">;</span>        <span class="token class-name">Integer</span> f <span class="token operator">=</span> <span class="token number">321</span><span class="token punctuation">;</span>        <span class="token class-name">Long</span> g <span class="token operator">=</span> <span class="token number">3L</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e <span class="token operator">==</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>g <span class="token operator">==</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>g<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>类似代码估计大家都见过，毕竟有些面试题就喜欢这么搞，这些语句的输出结果是什么呢？</p><p>我们先看反编译后的代码：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Integer</span> b <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Integer</span> c <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Integer</span> d <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Integer</span> e <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">321</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Integer</span> f <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">321</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Long</span> g <span class="token operator">=</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">3L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>c <span class="token operator">==</span> d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// t</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">==</span> f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// f</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> a<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// t</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// t</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>g<span class="token punctuation">.</span><span class="token function">longValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// t</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>g<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// f</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>可以看到，编译器对上述代码做了自动拆装箱的操作。其中值得注意的是：</p><p>包装类的 “==” 运算不遇到算术运算时，不会自动拆箱。</p><p>equals() 方法不会处理数据转型。</p><p>此外，还有个值得玩味的地方：为何 c==d 是 true、而 e==f 是 false 呢？似乎也是个考点。</p><p>这就要查看 Integer 类的 valueOf() 方法的源码了：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>high<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">IntegerCache</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Integer</span> cache<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// high value may be configured by property</span>        <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> integerCacheHighPropValue <span class="token operator">=</span>                sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>VM<span class="token punctuation">.</span><span class="token function">getSavedProperty</span><span class="token punctuation">(</span><span class="token string">"java.lang.Integer.IntegerCache.high"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>integerCacheHighPropValue <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>integerCacheHighPropValue<span class="token punctuation">)</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// Maximum array size is Integer.MAX_VALUE</span>                h <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">-</span>low<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span><span class="token punctuation">(</span> <span class="token class-name">NumberFormatException</span> nfe<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// If the property cannot be parsed into an int, ignore it.</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        high <span class="token operator">=</span> h<span class="token punctuation">;</span>        cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>            cache<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span>        <span class="token keyword">assert</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>high <span class="token operator">>=</span> <span class="token number">127</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>可以看到 Integer 内部使用了缓存 IntegerCache：其最小值为 -128，最大值默认是 127。因此，[-128, 127] 范围内的数字都会直接从缓存获取。</p><p>而且，该缓存的最大值是可以修改的，可以使用如下 VM 参数将其修改为 500：</p><p>-XX:AutoBoxCacheMax=500<br>增加该参数后，上述 e==f 也是 true 了。</p><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>Java语言可以进行条件编译，方法就是使用条件为常量的if语句。如下代码所示，该代码中的if语句不同于其他Java代码，它在编译阶段就会被“运行”，生成的字节码之中只包括“System.out.println(“block 1”)；”一条语句，并不会包含if语句及另外一个分子中的“System.out.println(“block 2”)；”</p><pre class="language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String<span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        System<span class="token punctuation">.</span><span class="token keyword">out</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"block 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        System<span class="token punctuation">.</span><span class="token keyword">out</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"block 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>该代码编译后Class文件的反编译结果：</p><pre class="language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String<span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>System<span class="token punctuation">.</span><span class="token keyword">out</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"block 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 深入理解Java虚拟机读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第11章 后端编译与优化</title>
      <link href="posts/4ba4e2fe/"/>
      <url>posts/4ba4e2fe/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="即时编译器"><a href="#即时编译器" class="headerlink" title="即时编译器"></a>即时编译器</h2><p>当虚拟机发现某个方法或代码块运行的特别频繁，就会把这些代码认定为热点代码，运行时虚拟机会把这些代码编译成本地机器码，并进行代码优化，运行时完成这个任务的后端编译器被称为即时编译器。</p><h3 id="解释器和编译器"><a href="#解释器和编译器" class="headerlink" title="解释器和编译器"></a>解释器和编译器</h3><p>当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，直接运行。当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地机器码，这样可以减少解释器的中间损耗，获得更高的执行效率。</p><p>HotSpot虚拟机内置了两个（或三个）即时编译器，其中两个编译器存在已久，分别是客户端编译器和服务端编译器，或者是C1和C2编译器。</p><p>即时编译器编译本地代码需要占用程序运行时间，通常编译出优化程度越来的代码，所花费的时间越长。想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行阶段的速度也有所影响。</p><p>分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其中包括：</p><ul><li>第0层：程序纯解释执行，并且解释器不开启性能监控功能（Profiling）。</li><li>第1层：使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启性能监控功能。</li><li>第2层：仍然使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能。</li><li>第3层：仍然使用客户端编译器执行，开启全部性能监控，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。</li><li>第4层：使用服务端编译器将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。</li></ul><h3 id="编译对象和触发条件"><a href="#编译对象和触发条件" class="headerlink" title="编译对象和触发条件"></a>编译对象和触发条件</h3><p>热点代码主要有两类，包括：</p><ul><li>被多次调用的方法</li><li>被多次执行的循环体</li></ul><p>要知道某段代码是不是热点代码，是不是需要触发即时编译，这个行为称为“热点探测”（Hot Spot Code Detection），其实进行热点探测并不一定要知道方法具体被调用了多少次，目前主流的热点探测判定方式有两种，分别是：</p><ul><li>基于采样的热点探测（Sample Based HotSpot Code Detection）。采用这种方法的虚拟机会周期性地检查各个线程的调用栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。基于采样的热点探测的好处是实现简单高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可），缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li><li>基于计数器的热点探测（Counter Based HotSpot Code Detection）。采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”。这种统计方法实现起来要麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。但是它的统计结果相对来说更加精确严谨。</li></ul><p>HotSpot采用的是第二种的探测方式，为了实现热点计数，HotSpot为每个方法准备了 两类计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter，“回边”的意思 就是指在循环边界往回跳转）。当虚拟机运行参数确定的前提下，这两个计数器都有一个明确的阈值，计数器阈值一旦溢出，就会触发即时编译。</p><h2 id="提前编译器"><a href="#提前编译器" class="headerlink" title="提前编译器"></a>提前编译器</h2><p>对提前编译的研究主要有下面两条分支。</p><h3 id="静态翻译"><a href="#静态翻译" class="headerlink" title="静态翻译"></a>静态翻译</h3><p>第一条就是在程序运行之前，把程序代码“翻译”成机器码。</p><p>JIT 编译器的主要缺点在于：它是在「运行期」进行编译的。这就不可避免地要占用应用程序的运行资源（CPU、内存等），进而影响程序的执行性能。</p><p>而这种提前编译就是把这个编译阶段放到程序的「运行期」之前，这样就可以不占用应用程序的资源。</p><h3 id="即时编译缓存"><a href="#即时编译缓存" class="headerlink" title="即时编译缓存"></a>即时编译缓存</h3><p>这个其实就是把 JIT 编译器要做的编译工作先做好，并保存下来，当触发 JIT 编译时，直接调用这里的代码就好了。本质上就是给 JIT 编译做缓存。</p><p>这种方式也被称为动态提前编译（Dynamic AOT）或者即时编译缓存（JIT Caching）。</p><h3 id="即时编译-amp-提前编译"><a href="#即时编译-amp-提前编译" class="headerlink" title="即时编译&amp;提前编译"></a>即时编译&amp;提前编译</h3><p>从上面对提前编译器的分析来看，似乎提前编译比 JIT 编译运行效率更高。那它就没缺点了吗？当然不是，否则还要 JIT 编译器干嘛。</p><p>相比提前编译器，JIT 编译器的优势在哪里呢？</p><ul><li>性能分析制导优化</li></ul><p>解释器或客户端编译器在运行的过程中，会不断收集性能监控信息（方法版本选择、条件判断等），这些信息可以帮助 JIT 编译器对代码进行集中优化。</p><p>这一点在静态分析时是很难做到的。</p><ul><li>激进预测性优化</li></ul><p>也就是 JIT 编译器可以进行一些稍微“激进”的优化行为，即便这些行为失败了，也有解释器可以“兜底”。而静态优化就做不到了。</p><p>此外，提前编译还会破坏 Java 平台中立性、产生字节膨胀等问题。</p><h2 id="编译器优化技术"><a href="#编译器优化技术" class="headerlink" title="编译器优化技术"></a>编译器优化技术</h2><p>最重要的优化技术之一：方法内联。 </p><p>最前沿的优化技术之一：逃逸分析。 </p><p>语言无关的经典优化技术之一：公共子表达式消除。 </p><p>语言相关的经典优化技术之一：数组边界检查消除。 </p><h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><p>方法内联编译器最重要的优化手段，业内戏称为“优化之母”。是其他优化手段的基础。</p><p>方法内联的优化行为理解起来是没有任何困难的，不过就是把目标方法的代码原封不动地“复制”到发起调用的方法之中，避免发生真实的方法调用。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testInline</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token function">foo</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>例子里testInline()方法的内部全部是无用的代码，但如果不做内联，后续即使进行了无用代码消除的优化。</p><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>逃逸分析（Escape Analysis）是目前Java虚拟机中比较前沿的优化技术，它与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术。</p><p>逃逸分析的基本原理是：分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种称为方法逃逸；甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸；从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。</p><p>如果能证明一个对象不会逃逸到方法或线程之外（换句话说是别的方法或线程无法通过任何途径访问到这个对象），或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可能为这个对象实例采取不同程度的优化：</p><ul><li><p>栈上分配（Stack Allocations）：在Java虚拟机中，虚拟机的垃圾收集子系统会回收堆中不再使用的对象，但回收动作无论是标记筛选出可回收对象，还是回收和整理内存，都需要耗费大量资源。如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。栈上分配可以支持方法逃逸，但不能支持线程逃逸。 </p></li><li><p>标量替换（Scalar Replacement）：</p><ul><li>标量：无法再分解为更小数据的数据，例如 JVM 中的原始数据类型（int、long、reference 等）。</li><li>聚合量：可以继续分解的数据，例如 Java 中的对象。</li></ul><p>标量替换，就是根据实际访问情况，将一个对象“拆解”开，把用到的成员变量恢复为原始类型来访问。</p><p>简单来说，就是把聚合量替换为标量。</p><p>若一个对象不会逃逸出「方法」，且可以被拆散，那么程序真正执行时就可能不去创建这个对象，而是直接创建它的若干个被该方法使用的成员变量代替。</p><p>将对象拆分后，除了可以让对象的成员变量在栈上分配和读写之外，还可以为后续进一步的优化手段创建条件。标量替换不允许对象逃逸出方法范围内。</p></li><li><p>同步消除（Synchronization Elimination）：线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以安全地消除掉。 </p></li></ul><h3 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h3><p>如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为公共子表达式。对于这种表达式，没有必要花时间再对它重新进行计算，只需要直接用前面计算过的表达式结果代替E。</p><p>若有如下代码：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">t1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token punctuation">(</span>c <span class="token operator">*</span> b<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">12</span> <span class="token operator">+</span> a <span class="token operator">+</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b <span class="token operator">*</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> d<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>Javac 编译后生成的字节码如下：</p><pre class="language-bash" data-language="bash"><code class="language-bash">public int t2<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    descriptor: <span class="token punctuation">(</span><span class="token punctuation">)</span>I    flags: ACC_PUBLIC    Code:      <span class="token assign-left variable">stack</span><span class="token operator">=</span><span class="token number">4</span>, <span class="token assign-left variable">locals</span><span class="token operator">=</span><span class="token number">5</span>, <span class="token assign-left variable">args_size</span><span class="token operator">=</span><span class="token number">1</span>         <span class="token comment"># ...</span>         <span class="token number">6</span>: iload_3         <span class="token number">7</span>: iload_2         <span class="token number">8</span>: imul                <span class="token comment"># 计算 b*c</span>         <span class="token number">9</span>: bipush        <span class="token number">12</span>        <span class="token number">11</span>: imul                <span class="token comment"># 计算 (c * b) * 12</span>        <span class="token number">12</span>: iload_1        <span class="token number">13</span>: iadd                <span class="token comment"># 计算 (c * b) * 12 + a</span>        <span class="token number">14</span>: iload_1        <span class="token number">15</span>: iload_2        <span class="token number">16</span>: iload_3        <span class="token number">17</span>: imul                <span class="token comment"># 计算 b*c</span>        <span class="token number">18</span>: iadd                <span class="token comment"># 计算 (a + b * c)</span>        <span class="token number">19</span>: iadd                <span class="token comment"># 计算 (c * b) * 12 + a + (a + b * c)</span>        <span class="token number">20</span>: istore        <span class="token number">4</span>        <span class="token number">22</span>: iload         <span class="token number">4</span>        <span class="token number">24</span>: ireturn        <span class="token comment"># ...</span></code></pre><p>Javac 编译器并未做任何优化。</p><p>这段代码进入即时编译器后，将进行如下优化：</p><p>编译器检测到 c * b 与 b * c 是一样的表达式，且在计算期间 b 和 c 的值不变，因此：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token class-name">E</span> <span class="token operator">*</span> <span class="token number">12</span> <span class="token operator">+</span> a <span class="token operator">+</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token class-name">E</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>此时，编译器还可能进行代数化简（Algebraic Simplification），如下：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token class-name">E</span> <span class="token operator">*</span> <span class="token number">13</span> <span class="token operator">+</span> a <span class="token operator">+</span> a<span class="token punctuation">;</span></code></pre><p>这样计算起来就可以节省一些时间。</p><h3 id="数组边界检查消除"><a href="#数组边界检查消除" class="headerlink" title="数组边界检查消除"></a>数组边界检查消除</h3><p>假如有一个数组 array，当我们访问数组下标在 [0, array.length) 范围之外的元素时，就会抛出ArrayIndexOutOfBoundsException异常，也就是数组越界了，把这个数组边界检查的例子放在更高的视角来看，大量的安全检查使编写Java程序比编写C和C++程序容易了很多，但也造成了许多额外的开销，如果不处理好它们，就很可能成为一项“Java语言天生就比较慢”的原罪。</p><p>为了消除这些隐式开销，除了如数组边界检查优化这种尽可能把运行期检查提前到编译期完成的思路之外，还有一种避开的处理思路——隐式异常处理，Java中空指针检查和算术运算中除数为零的检查都采用了这种方案。</p>]]></content>
      
      
      <categories>
          
          <category> 深入理解Java虚拟机读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第8章 虚拟机字节码执行引擎</title>
      <link href="posts/bd008043/"/>
      <url>posts/bd008043/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>执行引擎是Java虚拟机核心的组成部分之一。虚拟机执行引擎是由软件自行实现的，可以执行那些不被硬件直接支持的指令集格式。</p><h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>Java虚拟机以方法为最基本的执行单元，栈帧是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息。</p><p>一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。</p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表是一组变量值的存储空间，存放方法参数和方法内部定义的局部变量。局部变量表的容量以变量槽（Variable Slot）为最小单位。一个Slot可以存放一个32位以内（boolean、byte、char、short、int、float、reference和returnAddress）的数据类型，reference类型表示一个对象实例的引用，returnAddress已经很少见了，可以忽略。</p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/myXArgNB1WKhE6a.png" alt="image-20200514224901767" style="zoom: 67%;" / loading="lazy"><p><strong>对于64位的数据类型（Java语言中明确的64位数据类型只有long和double），虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。</strong></p><p><strong>虚拟机通过索引定位的方式使用局部变量表</strong>，索引值的范围从0开始至局部变量表最大的Slot数量。访问的是32位数据类型的变量，索引n就代表了使用第n个Slot,如果是64位数据类型，就代表会同时使用n和n+1这两个Slot。</p><p>当方法调用时，Java虚拟机使用局部变量表完成参数值到参数列表的传递过程，即实参到形参的传递。执行的是实例方法的话，局部变量表第0位索引变量槽默认是传递这个方法所属对象实例的引用，可以通过this访问。</p><p><strong>为了节省栈帧空间，局部变量表的Slot可以重用</strong>，方法体中定义的变量，其作用域并不一定会覆盖整个方法体。如果当前字节码PC计数器的值超出了某个变量的作用域，那么这个变量的Slot就可以交给其他变量使用。这样的设计会带来一些额外的副作用，比如：在某些情况下，Slot的复用会直接影响到系统的收集行为。</p><p>局部变量并不像类变量那样会有一个“准备阶段”。也就是说局部变量不会被默认赋零值，这也就是为什么局部变量需要显式赋值后才能被使用的原因。</p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈也常被称为操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也是在编译时期就写入到方法表的 Code 属性的 max_stacks 数据项中。操作数栈的每一个元素可以是可以是任意 Java 数据类型，包括 long 和 double，32 位数据类型所占的栈容量为 1，64 位数据类型所占的栈容量为 2。</p><p>在一个方法刚开始执行的时候，操作数栈是空的，随着方法的执行，会有各种字节码往操作数栈中写入和提取内容，也就是出栈/入栈操作。</p><p>在概念模型中，一个活动线程中两个栈帧是相互独立的。但大多数虚拟机实现都会做一些优化处理：让下一个栈帧的部分操作数栈与上一个栈帧的部分局部变量表重叠在一起，这样的好处是方法调用时可以共享一部分数据，而无须进行额外的参数复制传递。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/VWYvN4OKhpR1udx.png" alt="image-20200525145128509.png" loading="lazy"></p><h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的<strong>动态连接</strong>；</p><p>字节码中方法调用指令是以常量池中的指向方法的符号引用为参数的，有一部分符号引用会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为 <strong>静态解析</strong>，另外一部分在每次的运行期间转化为直接引用，这部分称为<strong>动态连接</strong>。</p><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>当一个方法被执行后，有两种方式退出这个方法：</p><ul><li>第一种是执行引擎遇到任意一个方法返回的字节码指令，这种退出方法的方式称为<strong>正常完成出口（Normal Method Invocation Completion）</strong>。</li><li>另外一种是在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理（即本方法异常处理表中没有匹配的异常处理器），就会导致方法退出，这种退出方式称为<strong>异常完成出口（Abrupt Method Invocation Completion）</strong>。<br>注意：这种退出方式不会给上层调用者产生任何返回值。</li></ul><p><strong>无论采用何种退出方式，在方法退出后，都需要返回到方法被调用的位置，程序才能继续执行</strong>，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。</p><p>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用阶段的目的：<strong>确定被调用方法的版本（哪一个方法），不涉及方法内部的具体运行过程</strong>，在程序运行时，进行方法调用是最普遍、最频繁的操作。</p><p><strong>一切方法调用在Class文件里存储的都只是符号引用，这是需要在类加载期间或者是运行期间，才能确定为方法在实际 运行时内存布局中的入口地址（相当于之前说的直接引用）</strong>。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>“编译期可知，运行期不可变”的方法（静态方法和私有方法），在类加载的解析阶段，会将其符号引用转化为直接引用（入口地址）。这类方法的调用称为“<strong>解析（Resolution）</strong>”。</p><p>在Java虚拟机中提供了5条方法调用字节码指令：</p><ul><li><strong>invokestatic</strong> : 调用静态方法</li><li><strong>invokespecial</strong>:调用实例构造器方法、私有方法、父类方法</li><li><strong>invokevirtual</strong>:调用所有的虚方法</li><li><strong>invokeinterface</strong>:调用接口方法，会在运行时在确定一个实现此接口的对象</li><li><strong>invokedynamic</strong>:先在运行时动态解析出点限定符所引用的方法，然后再执行该方法，在此之前的4条调用命令的分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li></ul><h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p><strong>分派调用过程将会揭示多态性特征的一些最基本的体现，如“重载”和“重写”在Java虚拟中是如何实现的。</strong></p><h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><p>所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派。静态分派发生在编译阶段。最典型应用表现是方法重载。</p><p>静态分派最典型的应用就是方法重载。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticResolution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Human</span> human <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Human</span> woman <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">StaticResolution</span> sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticResolution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sr<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span>human<span class="token punctuation">)</span><span class="token punctuation">;</span>        sr<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span>woman<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Man</span> g<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello, gentleman!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Human</span> h<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello, guy!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Woman</span> h<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello, lady!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Man</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Woman</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>运行结果：</p><p>Human guy</p><p>Human guy</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Human</span> man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>其中的Human称为变量的<strong>静态类型（Static Type）</strong>,Man称为变量的<strong>实际类型（Actual Type）</strong>。<br><strong>两者的区别是</strong>：静态类型在编译器可知，而实际类型到运行期才确定下来。<br>在重载时通过参数的静态类型而不是实际类型作为判定依据，因此，在编译阶段，Javac编译器会根据参数的静态类型决定使用哪个重载版本。所以选择了sayhello(Human)作为调用目标，并把这个方法的符号引用写到main()方法里的两条invokevirtual指令的参数中。</p><h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><p>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。最典型的应用就是方法重写。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicDispatch</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Human</span> man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Human</span> woman <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        man<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        woman<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        man<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"human say hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Man</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"man say hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Woman</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"woman say hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>运行结果：</p><p>man</p><p>woman</p><p>woman</p><p>使用 javap 命令得到上面 main() 方法的字节码如下所示：</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/uVb9rtjgaXDiZEB.png" alt="image-20200525220014127.png" loading="lazy"></p><p>17和21行分别通过invokevirtual指令进行方法调用，注释显示参数和指令都一样，但结果不同，这就要从指令本身入手。  </p><p>invokevirtual指令运行时的解析过程大致分为以下步骤：</p><p>（1）找到操作数栈顶的第一个元素所指向对象的<strong>实际类型</strong>C。</p><p>（2）然后在C中查找与常量池中描述符和简单名称都相符的方法，如果找到，则进行权限验证，如果通过验证则返回这个方法的直接引用，否则抛出java.lang.AbstractMethodError异常。</p><p>（3）否则，按照继承关系自下而上对C的父类进行第二步的查找和验证。</p><p>（4）如果没有找到则抛出java.lang.AbstractMethodError异常。</p><p>在上述 invokespecial 查找方法的过程中，最重要的就是第一步，根据对象的引用确定对象的实际类型，这个方法重写的本质。如上所述，在运行期内，根据对象的实际类型确定方法执行版本的分派过程叫做动态分派。</p><p>多态性的根源在于虚方法调用指令invokevirtual的执行逻辑，那这个指令只对方法有效，对字段无效，字段不使用这条指令。比如下面代码：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FieldHasNoPolymorphic</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Father</span> gay <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>gay<span class="token punctuation">.</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> money <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            money <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>            <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I an Father, i have $"</span> <span class="token operator">+</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> money <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            money <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>            <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I an Son, i have $"</span> <span class="token operator">+</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>输出<span class="token class-name">I</span> an <span class="token class-name">Son</span><span class="token punctuation">,</span> i have $<span class="token number">0</span><span class="token class-name">I</span> an <span class="token class-name">Son</span><span class="token punctuation">,</span> i have $<span class="token number">5</span><span class="token number">3</span></code></pre><p>在Son类创建时，首先隐式调用Father的构造函数，而Father的构造函数中对showMeTheMoney的调用是一次虚方法调用，实际执行的是Son::showMeTheMoney()方法。这时候虽然父类的money初始化为3，但Son::showMeTheMoney()访问的是子类的money字段，所以结果是0。</p><h4 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h4><p>方法的接收者、方法的参数都可以称为方法的宗量。根据分派基于多少种宗量，可以将分派划分为单分派和多分派。<strong>单分派是根据一个宗量对目标方法进行选择的，多分派是根据多于一个的宗量对目标方法进行选择的。</strong></p><p>Java在进行静态分派时，选择目标方法要依据两点：一是变量的静态类型是哪个类型，二是方法参数是什么类型。因为要根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型。</p><p>运行时阶段的动态分派过程，由于编译器已经确定了目标方法的签名（包括方法参数），运行时虚拟机只需要确定方法的接收者的实际类型，就可以分派。因为是根据一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型。</p><p>注：到JDK12时，Java语言还是静态多分派、动态单分派的语言，未来有可能支持动态多分派。</p><h4 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h4><p>虚拟机中的动态分派是十分频繁的动作，并且是在运行时在类方法元数据中进行搜索的，因此基于性能的考虑，虚拟机会采用各种优化手段优化动态分派的过程，最常见的”稳定优化”的手段就是为类在方法区中建立一个虚方法表，使用虚方法表索引来代替元数据以提高性能。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/MSjGKB4ir63bICA.png" alt="image-20200526082142831.png" loading="lazy"></p><p>上图就是一个虚方法表，Father、Son、Object 三个类在方法区中都有一个自己的虚方法表，如果子类中实现了父类的方法，那么在子类的虚方法表中该方法就指向子类实现的该方法的入口地址，如果子类中没有重写父类中的方法，那么在子类的虚方法表中，该方法的索引就指向父类的虚方法表中的方法的入口地址。有两点需要注意：</p><ul><li>为了程序实现上的方便，一个具有相同签名的方法，在子类的方法表和父类的方法表中应该具有相同的索引，这样在类型变化的时候，只需要改变查找方法的虚方法表即可。</li><li>虚方法表是在类加载的连接阶段实现的，类的变量初始化完成之后，就会初始化该类的虚方法表。</li></ul><h2 id="动态类型语言的支持"><a href="#动态类型语言的支持" class="headerlink" title="动态类型语言的支持"></a>动态类型语言的支持</h2><p>JDK新增加了invokedynamic指令来是实现“动态类型语言”。</p><p><strong>静态语言和动态语言的区别：</strong></p><ul><li><strong>静态语言（强类型语言）</strong>：<br>静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型。<br>例如：C++、Java、Delphi、C#等。</li><li><strong>动态语言（弱类型语言）</strong> ：<br>动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。<br>例如PHP/ASP/Ruby/Python/Perl/ABAP/SQL/JavaScript/Unix Shell等等。</li><li><strong>强类型定义语言</strong> ：<br>强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。</li><li><strong>弱类型定义语言</strong> ：<br>数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。</li></ul><h2 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h2><h3 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h3><p>Java语言经常被人们定位为 <strong>“解释执行”语言</strong>，在Java初生的JDK1.0时代，这种定义还比较准确的，但当主流的虚拟机中都包含了即时编译后，Class文件中的代码到底会被解释执行还是编译执行，就成了只有虚拟机自己才能准确判断的事情。再后来，Java也发展出来了直接生成本地代码的编译器[如何GCJ（GNU Compiler for the Java）]，而C/C++也出现了通过解释器执行的版本（如CINT），这时候再笼统的说“解释执行”，对于整个Java语言来说就成了几乎没有任何意义的概念，<strong>只有确定了谈论对象是某种具体的Java实现版本和执行引擎运行模式时，谈解释执行还是编译执行才会比较确切</strong>。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/X2DgeO4mlxnp1fw.png" alt="image-20200526092549199.png" loading="lazy"></p><p>Java语言中，javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程，因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机内部，所以Java程序的编译就是半独立实现的，</p><h3 id="基于栈的指令集和基于寄存器的指令集"><a href="#基于栈的指令集和基于寄存器的指令集" class="headerlink" title="基于栈的指令集和基于寄存器的指令集"></a>基于栈的指令集和基于寄存器的指令集</h3><p>Java编译器输出的指令流，基本上是一种<strong>基于栈的指令集架构（Instruction Set Architecture，ISA）</strong>，<strong>依赖操作数栈进行工作</strong>。与之相对应的另一套常用的指令集架构是<strong>基于寄存器的指令集</strong>， <strong>依赖寄存器进行工作</strong>。</p><p>那么，<strong>基于栈的指令集和基于寄存器的指令集这两者有什么不同呢？</strong></p><p>举个简单例子，分别使用这两种指令计算1+1的结果，<strong>基于栈的指令集会是这个样子：</strong><br>iconst_1</p><p>iconst_1</p><p>iadd</p><p>istore_0</p><p>两条iconst_1指令连续把两个常量1压入栈后，iadd指令把栈顶的两个值出栈、相加，然后将结果放回栈顶，最后istore_0把栈顶的值放到局部变量表中的第0个Slot中。</p><p><strong>如果基于寄存器的指令集，那程序可能会是这个样子：</strong></p><p>mov eax, 1</p><p>add eax, 1</p><p>mov指令把EAX寄存器的值设置为1，然后add指令再把这个值加1，将结果就保存在EAX寄存器里面。</p><p>基于栈的指令的特点</p><ul><li>可移植：寄存器由硬件决定，限制较大，但是虚拟机可以在不同硬件条件的机器上执行</li><li>代码相对更加紧凑：字节码中每个字节就对应一条指令，而多地址指令集中还需要存放参数</li><li>编译器实现更加简单</li><li>基于栈的指令缺点就是执行速度慢，因为虚拟机中操作数栈是在内存中实现的，频繁的栈访问也就意味着频繁的访问内存，内存的访问还是要比直接操作寄存器要慢的</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节中，我们分析了虚拟机在执行代码时，如何找到正确的方法、如何执行方法内的字节码，以及执行代码时涉及的内存结构。</p>]]></content>
      
      
      <categories>
          
          <category> 深入理解Java虚拟机读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础重难点</title>
      <link href="posts/2ba62a63/"/>
      <url>posts/2ba62a63/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1、值传递和引用传递"><a href="#1、值传递和引用传递" class="headerlink" title="1、值传递和引用传递"></a>1、值传递和引用传递</h4><p><strong>传值的方式传引用</strong>。 或者说<strong>传值的方式传地址</strong>。<br>你这个问题其实很简单。要搞清楚这个问题，要明白：堆 和 栈。引用是保存在栈上，对象是保存在堆中。引用指向堆上的对象，也就是说引用的值为对象在栈上的内存地址。那么你修改引用时改的是引用的值，也就是让引用指向其它对象。那么应该怎么修改堆上的对象呢？首先你得访问到堆上的对象吧？如何访问到它呢？在C/C++中是通过指针运算符 *p 来访问到指针p指向的堆上的对象的，然后再修改它。那么Java中没有指针运算符，那么怎么办呢？Java中是通过点操作符，也就是 list.add中的那个点，表示先访问到list这个引用指向的对象，然后让该对象调用 add 方法，从而修改了list指向的堆上的对象。所以当你单独修改 list = xxx;时你修改的是引用，让list引用指向其它对象，而没有修改 list 引用指向的对象，因为你根本就没有访问到堆上的对象，你怎么修改它呢？<br>所以：要修改堆上的对象，你要先访问到它，不然你就不能修改它。访问堆上的对象的方法就是 . 点操作符。</p><h4 id="2、同步、异步、阻塞、非阻塞"><a href="#2、同步、异步、阻塞、非阻塞" class="headerlink" title="2、同步、异步、阻塞、非阻塞"></a>2、同步、异步、阻塞、非阻塞</h4><p>同步和异步关注的是<strong>消息通信机制</strong> (synchronous communication/ asynchronous communication)。</p><p>所谓同步，就是在发出一个<strong>调用</strong>时，在没有得到结果之前，该<strong>调用</strong>就不返回。但是一旦调用返回，就得到返回值了。</p><p>换句话说，就是由<strong>调用者</strong>主动等待这个<strong>调用</strong>的结果。</p><p>而异步则是相反，<strong>调用在发出之后，这个调用就直接返回了，所以没有返回结果</strong>。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<strong>调用</strong>发出后，<strong>被调用者</strong>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p><p>阻塞和非阻塞关注的是<strong>程序在等待调用结果（消息，返回值）时的状态.</strong></p><p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><h4 id="3、概括的解释下线程的几种可用状态"><a href="#3、概括的解释下线程的几种可用状态" class="headerlink" title="3、概括的解释下线程的几种可用状态"></a>3、概括的解释下线程的几种可用状态</h4><ol><li><p>新建( new )：新创建了一个线程对象。</p></li><li><p>可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。</p></li><li><p>运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。</p></li><li><p>阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：</p><p>(一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。</p><p>(二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。</p><p>(三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。</p></li><li><p>死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p></li></ol><p><img src="http://uploadfiles.nowcoder.com/images/20151217/149974_1450349079825_4697A22AC611680A692472687DEC1CFD" alt="img" loading="lazy"></p><h4 id="4、多线程产生死锁需要四个条件"><a href="#4、多线程产生死锁需要四个条件" class="headerlink" title="4、多线程产生死锁需要四个条件"></a>4、多线程产生死锁需要四个条件</h4><p>互斥条件：一个资源每次只能被一个进程使用。</p><p>保持和请求条件：一个进程因请求资源而阻塞时，对已获得资源保持不放。</p><p>不可剥夺：进程已获得资源，在未使用完成前，不能被剥夺。</p><p>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p><h4 id="5、快速失败-fail-fast-和安全失败-fail-safe-的区别"><a href="#5、快速失败-fail-fast-和安全失败-fail-safe-的区别" class="headerlink" title="5、快速失败(fail-fast)和安全失败(fail-safe)的区别"></a>5、快速失败(fail-fast)和安全失败(fail-safe)的区别</h4><p><strong>一、快速失败（fail—fast）</strong></p><p>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出 Concurrent Modification Exception。</p><p><strong>原理：</strong>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p><strong>注意：</strong>这里异常的抛出条件是检测到 <strong>modCount != expectedmodCount</strong> 这个条件。如果集合发生变化时修改 modCount 值刚好又设置为了 expectedmodCount 值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的 bug。</p><p><strong>场景：</strong>java.util 包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</p><p><strong>二、安全失败（fail—safe）</strong></p><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p><p><strong>原理：</strong>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发 Concurrent Modification Exception。</p><p><strong>缺点：</strong>基于拷贝内容的优点是避免了 Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><p><strong>场景：</strong>java.util.concurrent 包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p><h4 id="6、Comparable和Comparator接口"><a href="#6、Comparable和Comparator接口" class="headerlink" title="6、Comparable和Comparator接口"></a>6、Comparable和Comparator接口</h4><p>Comparable &amp; Comparator 都是用来实现集合中元素的比较、排序的，只是 Comparable 是在集合内部定义的方法实现的排序，Comparator 是在集合外部实现的排序，所以如想实现排序，就需要在集合外定义 Comparator 接口的方法或在集合内实现 Comparable 接口的方法。</p><p> Comparator位于包java.util下，而Comparable位于包 java.lang下 ，Comparable 是一个对象本身就已经支持自比较所需要实现的接口（如 String、Integer 自己就可以完成比较大小操作，已经实现了Comparable接口） 自定义的类要在加入list容器中后能够排序，可以实现Comparable接口，在用Collections类的sort方法排序时，如果不指定Comparator，那么就以自然顺序排序， 这里的自然顺序就是实现Comparable接口设定的排序方式。</p><p> 而 Comparator 是一个专用的比较器，当这个对象不支持自比较或者自比较函数不能满足你的要求时，你可以写一个比较器来完成两个对象之间大小的比较。 可以说一个是自已完成比较，一个是外部程序实现比较的差别而已。 用 Comparator 是策略模式（strategy design pattern），就是不改变对象自身，而用一个策略对象（strategy object）来改变它的行为。 比如：你想对整数采用绝对值大小来排序，Integer 是不符合要求的，你不需要去修改 Integer 类（实际上你也不能这么做）去改变它的排序行为，只要使用一个实现了 Comparator 接口的对象来实现控制它的排序就行了。</p><p><strong>两者的比较</strong></p><p>comparable接口：</p><ul><li>优点：对于单元素集合可以实现直接排序 </li><li>缺点：对于多元素排序，排序依据是固定不可更改的。（元素内部只能实现一次compareTo方法）</li></ul><p>comparator接口：</p><ul><li>元素的排序依据时刻变的，所以可以通过定义多个外部类的方式来实现不同的排序。使用时按照需求选取。</li><li>创建外部类的代价太大。</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//在内部实现comparable接口，指定排序依据</span><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> age<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> name<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Student</span> stu<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>stu<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//定义成升序</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//在外部实现comparator接口，构建自己的排序实现类，指定排序依据</span><span class="token keyword">class</span> <span class="token class-name">StudentSortWithAge</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Student</span> o1<span class="token punctuation">,</span> <span class="token class-name">Student</span> o2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>o1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> o2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="7、JVM方法区"><a href="#7、JVM方法区" class="headerlink" title="7、JVM方法区"></a>7、JVM方法区</h4><p>方法区（线程共享）用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。JDK1.7把它当成永久代来进行垃圾回收，但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出<code>OutOfMemoryError</code>异常。为了更容易管理方法区，hotspot从 <code>JDK 1.8</code> 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，Class对象、静态变量和字符串常量池等放入堆中。元数据并不是类的Class对象，Class对象是加载的最终产品，静态变量位于 Class对象内，而类的方法代码，变量名，方法名，访问权限，返回值等元数据都是在方法区的。</p><p>JDK 1.8 同 JDK 1.7 比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是hotspot对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。</p><p>字符串常量池从永久代划到Java堆：由于字符串常量池具备动态性，在程序运行过程中会有大量的字符串常量在运行时常量池里产生，此时如果放在永久代，则无法恰当的设定永久代的大小，容易出现性能问题和内存溢出。</p><p>运行时常量池依旧还是在方法区里</p><p><strong>为什么移除永久代？</strong></p><ol><li><strong>方法区大小难以设定，容易发生内存溢出</strong>。永久代会存放Class的相关信息，一般这些信息在编译期间就能确定大小。但是如果是在一些需要动态生成大量Class的应用中，如：Spring的动态代理、大量的JSP页面或动态生成JSP页面等，由于方法区的大小在一开始就要分配好，因此就能难确定大小，容易出现内存溢出</li><li><strong>GC复杂且效率低</strong>。方法区存储了类的元数据信息和各种常量，它的内存回收目标理应当是对这些类型的卸载和常量的回收。但由于这些数据被类的实例引用，卸载条件变得复杂且严格，回收不当会导致堆中的类实例失去元数据信息和常量信息。因此，回收方法区内存不是一件简单高效的事情。</li><li><strong>促进HotSpot JVM与JRockit VM的融合</strong>。JRockit没有方法区，移除永久代可以促进HotSpot JVM与JRockit VM的融合。</li></ol><p><strong>什么是元空间（Metaspace），为什么引入元空间</strong></p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小<strong>仅受本地内存限制</strong>。</p><p>元空间的特点：</p><ol><li>每个加载器有专门的存储空间。</li><li>不会单独回收某个类。</li><li>元空间里的对象的位置是固定的。</li><li>如果发现某个加载器不再存活了，会把相关的空间整个回收。</li></ol><h4 id="8、何时full-gc"><a href="#8、何时full-gc" class="headerlink" title="8、何时full gc"></a>8、何时full gc</h4><p>只有参考作用，不同收集器实现不同。</p><ol><li>System.gc() 方法的调用<br>此方法的调用是建议 JVM 进行 Full GC，注意这<strong>只是建议而非一定</strong>，但在很多情况下它会触发 Full GC，从而增加 Full GC 的频率。通常情况下我们只需要让虚拟机自己去管理内存即可，我们可以通过 -XX:+ DisableExplicitGC 来禁止调用 System.gc()。</li><li>CMS GC 时出现 promotion failed 和 concurrent mode failure<br>promotion failed，就是上文所说的担保失败，而 concurrent mode failure 是在执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足造成的。</li><li>统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间</li></ol><h4 id="9、内存分配与回收策略"><a href="#9、内存分配与回收策略" class="headerlink" title="9、内存分配与回收策略"></a>9、内存分配与回收策略</h4><p>Java默认新生代老年代比例：1：2</p><p><img src="http://images.cnitblog.com/blog/587773/201409/061921034534396.png" alt="1" loading="lazy"></p><ol><li><p>对象优先在 Eden 分配</p><p>大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p></li><li><p>大对象直接进入老年代</p><p>大对象是指需要大量连续内存空间的 Java 对象，如很长的字符串或数据。</p><p>一个大对象能够存入 Eden 区的概率比较小，发生分配担保的概率比较大，而分配担保需要涉及大量的复制，就会造成效率低下。</p><p>虚拟机提供了一个 -XX:PretenureSizeThreshold 参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制。</p></li><li><p>长期存活的对象将进入老年代</p><p>JVM 给每个对象定义了一个对象年龄计数器。当新生代发生一次 Minor GC 后，存活下来的对象年龄 +1，当年龄超过一定值时，就将超过该值的所有对象转移到老年代中去。</p><p>使用 -XXMaxTenuringThreshold 设置新生代的最大年龄，只要超过该参数的新生代对象都会被转移到老年代中去。</p></li><li><p>动态对象年龄判定</p><p>如果当前新生代的 Survivor 中，相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄 &gt;= 该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。</p></li><li><p>空间分配担保</p><p>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。通过清除老年代中废弃数据来扩大老年代空闲空间，以便给新生代作担保。</p></li></ol><h4 id="10、为什么HashMap在链表长度为8时才转红黑树，不直接用红黑树"><a href="#10、为什么HashMap在链表长度为8时才转红黑树，不直接用红黑树" class="headerlink" title="10、为什么HashMap在链表长度为8时才转红黑树，不直接用红黑树"></a>10、为什么HashMap在链表长度为8时才转红黑树，不直接用红黑树</h4><p>基于时间和空间的权衡，大部分桶的链表长度在负载因子的影响下都会小于8，极少数才会大于8，而链表节点Node所用空间小于树节点TreeNode，所以在链表长度大于8才转红黑树。</p><h4 id="11、MySQL索引的作用"><a href="#11、MySQL索引的作用" class="headerlink" title="11、MySQL索引的作用"></a>11、MySQL索引的作用</h4><p>（1）快速取数据；<br>（2）保证数据记录的唯一性；<br>（3）实现表与表之间的参照完整性；<br>（4）在使用ORDER by、group by子句进行数据检索时，利用索引可以减少排序和分组的时间。</p><h4 id="12、为什么ConcurrentHashMap的读操作不需要加锁？"><a href="#12、为什么ConcurrentHashMap的读操作不需要加锁？" class="headerlink" title="12、为什么ConcurrentHashMap的读操作不需要加锁？"></a>12、为什么ConcurrentHashMap的读操作不需要加锁？</h4><p>get操作源码：</p><ol><li>首先计算hash值，定位到该table索引位置，如果是首节点符合就返回</li><li>如果遇到扩容的时候，会调用标志正在扩容节点ForwardingNode的find方法，查找该节点，匹配就返回</li><li>以上都不符合的话，就往下遍历节点，匹配就返回，否则最后就返回null</li></ol><pre class="language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;会发现源码中没有一处加了锁public V get(Object key) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;    int h &#x3D; spread(key.hashCode()); &#x2F;&#x2F;计算hash    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;        (e &#x3D; tabAt(tab, (n - 1) &amp; h)) !&#x3D; null) &#123;&#x2F;&#x2F;读取首节点的Node元素        if ((eh &#x3D; e.hash) &#x3D;&#x3D; h) &#123; &#x2F;&#x2F;如果该节点就是首节点就返回            if ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek)))                return e.val;        &#125;        &#x2F;&#x2F;hash值为负值表示正在扩容，这个时候查的是ForwardingNode的find方法来定位到nextTable来        &#x2F;&#x2F;eh&#x3D;-1，说明该节点是一个ForwardingNode，正在迁移，此时调用ForwardingNode的find方法去nextTable里找。        &#x2F;&#x2F;eh&#x3D;-2，说明该节点是一个TreeBin，此时调用TreeBin的find方法遍历红黑树，由于红黑树有可能正在旋转变色，所以find里会有读写锁。        &#x2F;&#x2F;eh&gt;&#x3D;0，说明该节点下挂的是一个链表，直接遍历该链表即可。        else if (eh &lt; 0)            return (p &#x3D; e.find(h, key)) !&#x3D; null ? p.val : null;        while ((e &#x3D; e.next) !&#x3D; null) &#123;&#x2F;&#x2F;既不是首节点也不是ForwardingNode，那就往下遍历            if (e.hash &#x3D;&#x3D; h &amp;&amp;                ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))))                return e.val;        &#125;    &#125;    return null;&#125;</code></pre><p>get操作可以无锁是由于Node的元素val和指针next是用volatile修饰的，在多线程环境下线程A修改结点的val或者新增节点的时候是对线程B可见的。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>    <span class="token comment">//可以看到这些都用了volatile修饰</span>    <span class="token keyword">volatile</span> <span class="token class-name">V</span> val<span class="token punctuation">;</span>    <span class="token keyword">volatile</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="13、关于一致性"><a href="#13、关于一致性" class="headerlink" title="13、关于一致性"></a>13、关于一致性</h4><h5 id="分布式数据一致性（数据多份副本一致性）"><a href="#分布式数据一致性（数据多份副本一致性）" class="headerlink" title="分布式数据一致性（数据多份副本一致性）"></a>分布式数据一致性（数据多份副本一致性）</h5><p>数据的一致性和系统的性能是每个分布式系统都需要考虑和权衡的问题。一致性的级别如下：<br><strong>1.强一致性</strong><br>这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大<br><strong>2.弱一致性</strong><br>这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不久承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态<br><strong>3、最终一致性</strong><br>最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型</p><h5 id="一致性hash"><a href="#一致性hash" class="headerlink" title="一致性hash"></a>一致性hash</h5><p>通过环的方式来分配数据。</p><h5 id="cap理论的一致性"><a href="#cap理论的一致性" class="headerlink" title="cap理论的一致性"></a>cap理论的一致性</h5><p><strong>Consistency(一致性)</strong></p><ul><li>通过某个节点的写操作结果对后面通过其他节点的读操作可见</li><li>如果更新数据后，并发访问情况下可立即感知该更新，称为强一致性</li><li>如果允许之后部分或者全部感知不到该更新，称为弱一致性</li><li>若在之后的一段时间（通常该时间不固定）后，一定可以感知该更新，称为最终一致性</li></ul><p><strong>Availability（可用性）</strong></p><ul><li>任何一个没有发生故障的节点必须在有限时间内返回合理的结果</li></ul><p><strong>Partition tolerance（分区容忍性）</strong></p><ul><li>部分节点宕机或者无法与其他节点通信时，各分区还可保持分布式系统的功能。</li></ul><h5 id="ACID里的一致性"><a href="#ACID里的一致性" class="headerlink" title="ACID里的一致性"></a>ACID里的一致性</h5><p>在ACID的上下文中，<strong>一致性</strong>是指数据库在应用程序的特定概念中处于“良好状态”。</p><p>ACID一致性的概念是，<strong>对数据的一组特定约束必须始终成立</strong>。即<strong>不变量（invariants）</strong>。例如，在会计系统中，所有账户整体上必须借贷相抵。如果一个事务开始于一个满足这些不变量的有效数据库，且在事务处理期间的任何写入操作都保持这种有效性，那么可以确定，不变量总是满足的。</p><p>但是，一致性的这种概念取决于应用程序对不变量的观念，应用程序负责正确定义它的事务，并保持一致性。这并不是数据库可以保证的事情：如果你写入违反不变量的脏数据，数据库也无法阻止你。 （一些特定类型的不变量可以由数据库检查，例如外键约束或唯一约束，但是一般来说，是应用程序来定义什么样的数据是有效的，什么样是无效的。—— 数据库只管存储。）</p><p>原子性，隔离性和持久性是数据库的属性，而一致性（在ACID意义上）是应用程序的属性。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。因此，字母C不属于ACID[^i]。</p><p>[^i]: 乔·海勒斯坦（Joe Hellerstein）指出，在论Härder与Reuter的论文中，“ACID中的C”是被“扔进去凑缩写单词的”【7】，而且那时候大家都不怎么在乎一致性。</p><h4 id="14、MySQL如何解决幻读？"><a href="#14、MySQL如何解决幻读？" class="headerlink" title="14、MySQL如何解决幻读？"></a>14、MySQL如何解决幻读？</h4><p>SELECT查询分为快照读和实时读，快照读通过MVCC（并发多版本控制）来解决幻读问题，实时读通过行锁来解决幻读问题。</p><h5 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h5><h6 id="快照读是什么？"><a href="#快照读是什么？" class="headerlink" title="快照读是什么？"></a>快照读是什么？</h6><p>因为MySQL默认的隔离级别是<strong>可重复读</strong>，这种隔离级别下，我们普通的SELECT语句都是快照读，也就是在一个事务内，多次执行SELECT语句，查询到的数据都是事务开始时那个状态的数据（这样就不会受其他事务修改数据的影响），这样就解决了幻读的问题。</p><h6 id="那么innodb是怎么解决快照读的幻读问题的？"><a href="#那么innodb是怎么解决快照读的幻读问题的？" class="headerlink" title="那么innodb是怎么解决快照读的幻读问题的？"></a>那么innodb是怎么解决快照读的幻读问题的？</h6><p>快照读就是每一行数据中额外保存两个隐藏的列，插入这个数据行时的版本号，删除这个数据行时的版本号（可能为空），滚动指针(指向undo log中用于事务回滚的日志记录)。</p><p>事务在对数据修改后，进行保存时，如果数据行的当前版本号与事务开始取得数据的版本号一致就保存成功，否则保存失败。</p><p>当我们不显式使用BEGIN来开启事务时，我们执行的每一条语句就是一个事务，每次开始事务时，会对系统版本号+1作为当前事务的ID。</p><p><strong>插入操作</strong></p><p>插入一行数据时，将事务的ID作为数据行的创建版本号。</p><p><strong>删除操作</strong></p><p>执行删除操作时，会将原数据行的删除版本号设置为当前事务的ID，然后根据原数据行生成一条INSERT语句，写入undo log，用于事务执行失败时回滚。delete操作实际上不会直接删除，而是将delete对象打上delete flag，标记为删除，最终的删除操作是purge线程完成的。但是会将数据行的删除版本号设置为当前的事务的ID，这样后面的事务B即便查到这行数据由于事务B的ID&gt;删除版本号，也会忽略这条数据。</p><p><strong>更新操作</strong></p><p>更新时可以简单的认为是先将旧数据删除，然后插入一条新数据。</p><p>所以执行更新操作时，其实是会将原数据行的删除版本号设置为当前事务的ID，生成一条INSERT语句，写入undo log，用于事务执行失败时回滚。插入一条新的数据，将事务的ID作为数据行的的创建版本号。</p><p><strong>查询操作</strong></p><p>数据行要被查询出来必须满足两个条件，</p><ul><li>数据行删除版本号为空或者&gt;当前事务版本号的数据（否则数据已经被标记删除了)</li><li>创建版本号&lt;=当前事务版本号的数据（否则数据是后面的事务创建出来的）</li></ul><p>简单来说，就是查询时，</p><ul><li>如果该行数据没有被加行锁中的X锁（也就是没有其他事务对这行数据进行修改），那么直接读取数据（前提是数据的版本号&lt;=当前事务版本号的数据,不然不会放到查询结果集里面）。</li><li>该行数据被加了行锁X锁（也就是现在有其他事务对这行数据进行修改），那么读数据的事务不会进行等待，而是回去undo log端里面读之前版本的数据（这里存储的数据本身是用于回滚的），在<strong>可重复读</strong>的隔离级别下，从undo log中读取的数据总是事务开始时的快照数据(也就是版本号小于当前事务ID的数据)，在<strong>提交读</strong>的隔离级别下，从undo log中读取的总是最新的快照数据。</li></ul><h6 id="补充资料：undo-log段是什么？"><a href="#补充资料：undo-log段是什么？" class="headerlink" title="补充资料：undo log段是什么？"></a>补充资料：undo log段是什么？</h6><p>undo_log是一种逻辑日志，是旧数据的备份。有两个作用，用于事务回滚和为MVCC提供老版本的数据。</p><p><strong>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。</strong></p><p><strong>用于事务回滚</strong></p><p>当事务执行失败，回退时，会读取这行数据的滚动指针(指向undo log中用于事务回滚的日志记录)，就可以在undo log中找到相应的逻辑记录，读取到相应的回滚语句，执行进行回滚。</p><p><strong>为MVCC提供老版本的数据</strong></p><p>当读取的某一行被其他事务锁定时（也就是有其他事务正在改这行数据），它可以从undo log中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户进行快照读。在<strong>可重复读</strong>的隔离级别下，从undo log中读取的数据总是事务开始时的快照数据(也就是版本号小于当前事务ID的数据)，在<strong>提交读</strong>的隔离级别下，从undo log中读取的总是最新的快照数据（也就是比正在修改这行数据的事务ID修改前的数据。）。</p><h5 id="实时读"><a href="#实时读" class="headerlink" title="实时读"></a>实时读</h5><h6 id="实时读是什么？"><a href="#实时读是什么？" class="headerlink" title="实时读是什么？"></a><strong>实时读是什么？</strong></h6><p>如果说快照读总是读取事务开始时那个状态的数据，实时读就是查询时总是执行这个查询时数据库中的数据。</p><p>一般使用以下这两种查询语句进行查询时就是实时读。</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span> 在查询时会先申请X锁<span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token operator">IN</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span> 在查询时会先申请S锁</code></pre><p><strong>那么innodb是怎么解决实时读的幻读问题的？</strong></p><p>如果我们不在一开始将将隔离级别设置为<strong>提交读</strong>，其实是不会产生幻读问题的，因为MySQL的默认隔离级别是<strong>可重复读</strong>，在这种情况下，我们执行第一次 SELECT…FOR UPDATE查询语句是，其实是会先申请行锁，因为一开始数据库就只有a:4一行数据，那么加锁区间其实是</p><pre class="language-text" data-language="text"><code class="language-text">(负无穷，4](4,正无穷)</code></pre><p>我们查询条件是a&gt;2，上面两个加锁区间都会可能有数据满足条件，所以会申请行锁中的next-key lock，是会对上面这两个区间都加锁，这样其他事务不能往这两个区间插入数据，事务B会执行插入时会一直等待获取锁，直到事务A提交，释放行锁，事务B才有可能申请到锁，然后进行插入。这样就解决了幻读问题。</p><p><strong>贴一个《设计数据密集型应用》的段落，讲的不错：</strong></p><p>与读取提交的隔离类似，快照隔离的实现通常使用写锁来防止脏写，这意味着进行写入的事务会阻止另一个事务修改同一个对象。但是读取不需要任何锁定。从性能的角度来看，快照隔离的一个关键原则是：<strong>读不阻塞写，写不阻塞读</strong>。这允许数据库在处理一致性快照上的长时间查询时，可以正常地同时处理写入操作。且两者间没有任何锁定争用。</p><p>数据库必须可能保留一个对象的几个不同的提交版本，因为各种正在进行的事务可能需要看到数据库在不同的时间点的状态。因为它并排维护着多个版本的对象，所以这种技术被称为<strong>多版本并发控制（MVCC, multi-version concurrency control）</strong>。</p><p>如果一个数据库只需要提供<strong>读已提交</strong>的隔离级别，而不提供<strong>快照隔离</strong>，那么保留一个对象的两个版本就足够了：提交的版本和被覆盖但尚未提交的版本。支持快照隔离的存储引擎通常也使用MVCC来实现<strong>读已提交</strong>隔离级别。一种典型的方法是<strong>读已提交</strong>为每个查询使用单独的快照，而<strong>快照隔离</strong>对整个事务使用相同的快照。</p><p><a href="">图7-7</a>说明了如何在PostgreSQL中实现基于MVCC的快照隔离【31】（其他实现类似）。当一个事务开始时，它被赋予一个唯一的，永远增长[^vii]的事务ID（<code>txid</code>）。每当事务向数据库写入任何内容时，它所写入的数据都会被标记上写入者的事务ID。</p><p>[^vii]: 事实上，事务ID是32位整数，所以大约会在40亿次事务之后溢出。 PostgreSQL的Vacuum过程会清理老旧的事务ID，确保事务ID溢出（回卷）不会影响到数据。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/fig7-7.png" loading="lazy"></p><p><strong>图7-7 使用多版本对象实现快照隔离</strong></p><p>表中的每一行都有一个 <code>created_by</code> 字段，其中包含将该行插入到表中的的事务ID。此外，每行都有一个 <code>deleted_by</code> 字段，最初是空的。如果某个事务删除了一行，那么该行实际上并未从数据库中删除，而是通过将 <code>deleted_by</code> 字段设置为请求删除的事务的ID来标记为删除。在稍后的时间，当确定没有事务可以再访问已删除的数据时，数据库中的垃圾收集过程会将所有带有删除标记的行移除，并释放其空间。[^译注ii]</p><p>[^译注ii]: 在PostgreSQL中，<code>created_by</code> 的实际名称为<code>xmin</code>，<code>deleted_by</code> 的实际名称为<code>xmax</code></p><p><code>UPDATE</code> 操作在内部翻译为 <code>DELETE</code> 和 <code>INSERT</code> 。例如，在<a href="">图7-7</a>中，事务13 从账户2 中扣除100美元，将余额从500美元改为400美元。实际上包含两条账户2 的记录：余额为 $500 的行被标记为<strong>被事务13删除</strong>，余额为 $400 的行<strong>由事务13创建</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第7章 虚拟机类加载机制</title>
      <link href="posts/3f8112b9/"/>
      <url>posts/3f8112b9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程称为虚拟机的类加载机制。</p><p>Java语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让Java语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但却为了Java应用提供了极高的扩展性和灵活性。</p><p>两个约定：</p><ul><li>实际情况中，每个Class文件都有代表着Java语言中的一个类或接口的可能，后文中直接对“类型”的描述都同时蕴含着类和接口的可能性。</li><li>本章提到的Class文件也并非特指某个具体存在于具体磁盘中的文件，而是一串二进制字节流，无论其以何种形式存在，包括但不限于磁盘文件、网络、数据库、内存和动态生成等。</li></ul><h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)七个阶段，其中验证、准备、解析三个部分统称为连接(Linking)。</p><center>类的生命周期</center><p><img src="https://i.loli.net/2020/05/15/rxjaVKXoR7g3PhT.png" alt="image-20200515152606704.png" loading="lazy"></p><p>类型的加载过程必须按加载、验证、准备、初始化和卸载这五个阶段<strong>开始</strong>(这些阶段通常是互相交叉的混合运行，在一个阶段执行的过程中调用另一个阶段)，但解析阶段不一定：它在某些情况下可以在初始化阶段后再开始，这是为了支持Java语言的运行时绑定特性。</p><p>《Java虚拟机规范》严格规定了六种情况必须立即对类进行初始化（加载等步骤在此前开始）：</p><ol><li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，若类型没有进行初始化，则要先触发其初始化阶段。生成这四条指令的场景有：<ul><li>使用new关键字实例化对象。</li><li>读取或设置一个类型的静态字段的时候(被final修饰、在编译期就把结果放入常量池的静态类型除外)。</li><li>调用一个类型的静态方法的时候。</li></ul></li><li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果没有类型进行初始化，则需要先触发其初始化。</li><li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户指定一个要运行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。</li><li>当使用JDK7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li><li>当一个接口中定义了JDK8新加入的默认方法(被default关键字修饰的接口方法)时，如果有这个接口的实现类发生了初始化，那该接口就要在其之前被初始化。</li></ol><p>这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NotInitialization</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">SubClass</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"superclass"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"subclass"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>这段代码运行后，只会输出”superclass“。对于静态字段， 只有直接定义这个字段的类才会被初始化，子类引用父类的静态字段，只会触发父类的初始化而子类不会初始化。子类是否加载和验证，取决于虚拟机实现。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NotInitialization</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SuperClass</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sca <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperClass</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>运行发现什么也没输出，说明没有初始化SuperClass，但这段代码<strong>触发了另一个名为[LSuperClass类的初始化，它是虚拟机自动生成的，直接继承Object的子类，创建动作由字节码指令newarray触发。</strong></p><p>这个类代表一个元素类型为SuperClass的一维数组，数组应有的属性和方法(用户可直接使用的只有被public修饰的length属性和clone()方法)都在这个类里。Java对数组访问比较安全，很大程度上因为这个类包装了数组元素的访问。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ConstClass</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"constclass"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> HELLOWORLF <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NotInitialization</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ConstClass</span><span class="token punctuation">.</span>HELLOWORLF<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>输出“hello world”，因为虽然在Java源码中确实引用了ConstClass类的HELLOWORLD，但其实编译阶段通过常量传播优化，已经将此常量的值“hello world”存储在NotInitialization类的常量池中，以后NotInitialization对常量HELLOWORLD的引用，实际上都是对自身常量池的引用，这两个类在编译成class文件后就没有任何联系了。</p><center>反编译后的类</center><p><img src="https://i.loli.net/2020/05/15/UqOW52icpQBDjSG.png" alt="image-20200515193845010" loading="lazy"></p><p>接口的加载过程与类加载稍有不同，接口不能用static{}语句块，但编译器仍然会为接口生成&lt;clinit&gt;()类构造器，用于初始化接口定义的成员变量，但接口与类不同的地方是，接口在初始化时，不要求其父接口全部完成初始化，只有真正使用到父接口时，才会初始化。</p><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载阶段是整个类加载过程的一个阶段，在加载阶段，虚拟机需要完成三件事情：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ul><p>相对于类加载过程的其他阶段，非数组类型的加载阶段是开发人员可控性最强的阶段。加载阶段既可以使用Java虚拟机里内置的引导类加载器完成，也可以使用用户自定义的类加载器去完成。</p><p>数组类则不同，数组类本身不通过类加载器创建，它是由Java虚拟机在内存中动态构造出来的。数组类与类加载器有密切关系，因为数组的元素最终还要类加载器来完成加载。一个数组类(简称C)的创建过程遵循以下规则：</p><ul><li>如果数组的组件类型是引用类型，那就递归采用本节定义的加载过程去加载这个组件类型，数组C将被标识在<strong>加载该组件类型的类加载器</strong>的类名称空间上。</li><li>如果数组的组件类型不是引用类型，Java虚拟机将会把数组C标记为与引导类加载器关联。</li><li>数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问。</li></ul><p>加载结束后，Java虚拟机外部的二进制字节流就按照虚拟机设定的格式存储在方法区中了。类型数据妥善安置在方法区后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中类型数据的外部接口。</p><p>加载阶段与连接阶段的部分动作(如一部分字节码文件格式的验证动作)是交叉进行的。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流包含的信息符合《Java虚拟机规范》的约束，确保这些信息被当作代码运行后不会危害虚拟机自身的安全。</p><p>Java语言相对安全，纯粹的Java代码无法做到将对象转型为未实现的类型或访问数组边界外的区域，但使用字节码是可以实现的，所以验证字节码是Java虚拟机保护自身的一项必要措施。</p><p>验证阶段很重要，这个阶段是否严谨，直接决定了Java虚拟机能否承受恶意代码的攻击。</p><p>验证阶段大致分为以下四个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证：</p><h5 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h5><p>验证字节流是否符合Class文件格式的规范，并能被当前版本虚拟机处理。比如：是否以0xCAFEBABE开头，主次版本号是否在当前虚拟机接受范围内。只有通过这个阶段验证后，字节流才允许进入Java虚拟机内存的方法区进行存储，后面三个验证阶段都是基于方法区的存储结构上进行的，不会再读取、操作字节流了。</p><h5 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h5><p>第二阶段是对字节码描述的信息进行语义分析，保证其描述的信息符合《Java语言规范》的要求。比如验证是否有父类，父类是否继承了不允许被继承的类等等。</p><h5 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h5><p>第三阶段是整个验证过程最复杂的一个阶段。主要目的是通过数据流的分析和控制流分析，确定程序语义是合法的、符合逻辑的。对元数据信息的数据类型校验完毕后，就要对类的方法体(Class文件的Code属性)进行校验分析。由于数据流分析和控制流分析的复杂性，为了避免执行时间消耗在字节码验证阶段 ，在jdk6后的javac编译器和Java虚拟机里进行了联合优化，把尽可能多的校验辅助措施挪到javac编译器里进行。</p><h5 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h5><p>最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化在解析阶段发生。符号引用验证可以看作是对类自身以外(常量池的各种符号引用)的各类信息进行匹配性校验，比如校验符号引用中通过字符串描述的全限定名能否找到指定的类等等。</p><p>验证阶段对于虚拟机的类加载机制来说，是非常重要，但不是必须执行的阶段。只要通过验证，其后就对程序运行期没有影响了。如果代码被反复使用和验证过，那么就可以考虑使用-Xverify:none参数来关闭大部分的验证措施，缩短虚拟机类加载时间。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为定义的变量(即静态变量，被static修饰的变量)分配内存并设置类变量初始值的阶段。</p><p>在准备阶段，进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p><p>另外，这里说的初始值“通常情况”下是数据结构的零值，比如一个类变量定义为<code>public static int value = 123; </code>，那么变量value在准备阶段后的初始值为0而不是123，因为这时尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器&lt;clinit&gt;()方法中，所以把value赋值为123的动作要到类的初始化阶段才会被执行。</p><center>基本数据类型的零值</center><table><thead><tr><th>数据类型</th><th>零值</th><th>数据类型</th><th>零值</th></tr></thead><tbody><tr><td>int</td><td>0</td><td>boolean</td><td>false</td></tr><tr><td>long</td><td>0L</td><td>float</td><td>0.0f</td></tr><tr><td>short</td><td>(short)0</td><td>double</td><td>0.0d</td></tr><tr><td>char</td><td>‘\u0000’</td><td>reference</td><td>null</td></tr><tr><td>byte</td><td>(byte)0</td><td></td><td></td></tr></tbody></table><p>上面提到”通常情况“是零值，那就有特殊情况，比如类字段的字段属性表存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值，比如<code>public static final int value = 123;</code>编译时javac将会为value生成ConstantValue属性，虚拟机就会根据ConstantValue的设置将value赋值为123。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。</p><ul><li>符号引用：符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量。符号引用与虚拟机的内存布局无关，引用的目标不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，但他们所能接收的符号引用必须是一致的。</li><li>直接引用：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄，直接引用和虚拟机实现的内存布局直接相关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。</li></ul><p>《Java虚拟机规范》中没有定义解析阶段发生的时间，只要求在执行某些用于操作符号引用的字节码指令前，先对它们所使用的符号引用进行解析。对方法或者字段的访问，也会在解析阶段对它们的可访问性(public、private等)进行检查。</p><p>对同一个符号引用进行多次解析请求是很常见的，除invokedynamic外，虚拟机实现可以对第一次解析的结果进行缓存，比如运行时直接引用常量池的记录，并把常量标识为已解析状态，避免重复解析。不过对于invokedynamic指令，就不会这样了，invokedynamic指令的目的本来就是用于动态语言支持，它对应的引用称为“动态调用点限定符”，这里动态的含义是指必须等到程序实际运行这条指令时，解析动作才执行。其他的可能刚刚完成加载阶段，就提前解析。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类的初始化阶段是类加载过程最后一个步骤。直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权交给应用程序。</p><p>进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，才开始初始化类变量和其他资源。初始化阶段就是执行类构造器&lt;clinit&gt;()方法的过程。&lt;clinit&gt;()并不是程序员在Java代码中直接编写的方法，它是javac编译器的自动生成物。</p><ul><li>&lt;clinit&gt;() 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问。</li><li>&lt;clinit&gt;()方法与类的构造函数(即在虚拟机视角中的实例构造器&lt;init&gt;()方法)不同，它不需要显式的调用父类构造器，Java虚拟机会保证在子类的&lt;clinit&gt;()方法执行前，父类的&lt;clinit&gt;()方法已经执行完毕。因此在Java虚拟机中第一个执行的&lt;clinit&gt;()方法的类型肯定是java.lang.Object。</li><li>由于父类的&lt;clinit&gt;()先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作。</li><li>&lt;clinit&gt;()方法对于类或接口来说不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成&lt;clinit&gt;()方法。</li><li>接口不能有静态语句块，但有变量初始化的赋值操作，所以也有&lt;clinit&gt;()方法。但接口执行&lt;clinit&gt;()时不用先执行父接口的&lt;clinit&gt;()方法。父接口定义的变量被使用时，父接口才被初始化。</li><li>Java虚拟机保证一个类的&lt;clinit&gt;()在多线程环境被正确的加锁同步。</li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="类和类加载器"><a href="#类和类加载器" class="headerlink" title="类和类加载器"></a>类和类加载器</h4><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都有一个独立的类名称空间。比较两个类是否相等(比如equals()、isInstance()、instanceof等)，只有这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，这两个类必不相等。</p><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>在虚拟机角度看，只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，这个加载器使用C++实现，是虚拟机自身一部分；另一个是其他所有类的加载器，这些类加载器由Java实现，继承自Object。</p><p>在开发人员角度看，类加载器就应当划分的更细致一些。自JDK1.2来，Java一直保持这三层类加载器、双亲委派的类加载架构。</p><ul><li>启动类加载器：这个类加载器负责加载存放在<JAVA_HOME>\lib目录，或被-Xbootclasspath指定的路径，而且是Java虚拟机能够识别的(按照文件名识别，如rt.jar、tools.jar等)类库加载到虚拟机内存。</li><li>扩展类加载器(Extension Class Loader)：这个类加载器是在类sun.misc.Launcher$ExtClassLoader中实现的，负责加载jre/lib/ext的类库。允许用户将具有通用性的类库放置在ext目录里以扩展JavaSE的功能。</li><li>应用程序类加载器(Application Class Loader)：也叫系统类加载器，负责加载用户类路径下的所有类库，开发者统一也可以直接在代码中使用这个类加载器。</li></ul><p>JDK9之前的Java应用都是这三类加载器互相配合完成加载的，用户还可以加入自定义的类加载器，如增加除了磁盘位置外的Class文件来源，或通过类加载器实现类的隔离、重载等功能。</p><p><img src="https://i.loli.net/2020/05/16/s7uhBr8VdmKQEtg.png" alt="image-20200516220011082.png" loading="lazy"></p><p>双亲委派模型除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。这里的父子关系是用组合关系来复用。</p><p>工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会自己尝试完成加载。</p><p>好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，无论哪个加载器要加载这个类，都要先让最顶端的加载器去尝试加载这个类，因此Object类在各种类加载器环境中能保证是同一个类。</p><h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><p>第一次破坏：</p><p>由于双亲委派模型是在JDK1.2之后才被引入的，而类加载器和抽象类java.lang.ClassLoader则在JDK1.0时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。JDK1.2之后的ClassLoader添加了一个新的findClass方法，建议用户自定义类加载器时使用findClass方法，按loadClass的逻辑，如果父类加载失败，就会自动调用自己的findClass方法来完成加载，这样既不影响用户按自己的意愿加载类，又可以保证新的类加载器符合双亲委派规则。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//首先检查类是否被加载过。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//父类加载器无法加载</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//若父类加载器无法加载时，再调用本身的findClass来进行类加载</span>            c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> c<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>第二次破坏：</p><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的同一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API，但世事往往没有绝对的完美。</p><p>原生的JDBC中Driver驱动本身只是一个接口，并没有具体的实现，具体的实现是由不同数据库类型去实现的。例如，MySQL的mysql-connector-*.jar中的Driver类具体实现的。 原生的JDBC中的类是放在rt.jar包的，是由启动类加载器进行类加载的，在JDBC中的Driver类中需要动态去加载不同数据库类型的Driver类，而mysql-connector-*.jar中的Driver类是用户自己写的代码，那启动类加载器肯定是不能进行加载的，既然是自己编写的代码，那就需要由应用程序启动类去进行类加载。于是乎，这个时候就引入线程上下文件类加载器(Thread Context ClassLoader)。有了这个东西之后，程序就可以把原本需要由启动类加载器进行加载的类，由应用程序类加载器去进行加载了。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Connection</span> <span class="token function">getConnection</span><span class="token punctuation">(</span>    <span class="token class-name">String</span> url<span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Properties</span> info<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> caller<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//callerCL为空的时候，其实说明这个ClassLoader是启动类加载器，但是这个启动类加载并不能识别rt.jar之外的类，这个时候就把callerCL赋值为Thread.currentThread().getContextClassLoader();也就是应用程序启动类</span>    <span class="token class-name">ClassLoader</span> callerCL <span class="token operator">=</span> caller <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> caller<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>callerCL <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            callerCL <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></code></pre><p>第三次破坏：</p><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换、模块热部署等，简答的说就是机器不用重启，只要部署上就能用。<br>OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi幻境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当受到类加载请求时，OSGi将按照下面的顺序进行类搜索：<br>1）将java.＊开头的类委派给父类加载器加载。<br>2）否则，将委派列表名单内的类委派给父类加载器加载。<br>3）否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。<br>4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。<br>5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。<br>6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。<br>7）否则，类加载器失败。</p>]]></content>
      
      
      <categories>
          
          <category> 深入理解Java虚拟机读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3章 垃圾收集器与内存分配策略</title>
      <link href="posts/a8f159ba/"/>
      <url>posts/a8f159ba/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>垃圾收集技术在1960年的Lisp语言就开始使用了。</p><p>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生灭，不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然也就跟着回收了。</p><p>但Java堆和方法区不同，一个接口的多个实现类的内存可能不一样，一个方法所执行的不同条件所需要的内存也可能不一样，这部分内存分配和回收是动态的。</p><h3 id="对象存活判断"><a href="#对象存活判断" class="headerlink" title="对象存活判断"></a>对象存活判断</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器值为零的对象就是不可能再被使用的。</p><p>这种算法虽然占用了额外的内存空间，但原理简单，效率高。但在Java领域，主流虚拟机都没采用它来管理内存，因为这个算法要考虑很多例外情况，比如循环引用：</p><pre class="language-java" data-language="java"><code class="language-java">objA<span class="token punctuation">.</span>instence <span class="token operator">=</span> objB<span class="token punctuation">;</span>objB<span class="token punctuation">.</span>instence <span class="token operator">=</span> objA</code></pre><p>他们互相引用对方，导致它们的引用计数不为零，无法回收。</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>主流虚拟机都是用这个算法来判定对象是否存活的。这个算法的思路是通过一系列称为‘GC Roots’的根对象作为起始节点集，从这些节点根据引用向下搜索，走过的路径叫引用链，如果某个对象到GC Roots间没有引用链相连，那就证明这个对象不再使用。</p><p>可以作为GC Roots的对象包括：</p><ul><li>虚拟机栈中引用的变量（方法执行完毕后弹栈，这些变量就不存在了，正好gc回收）。</li><li>方法区中类静态属性引用的对象（类的全局属性，存在于方法区中，每个线程共享）。</li><li>方法区中常量引用的对象（被final修饰，不能更改）。</li><li>本地方法栈中Native方法（JNI）引用的对象。</li></ul><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>判断对象是否存活与引用离不开关系。</p><p>在JDK1.2之前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。但这种引用描述不了那种内存足够时可以保存在内存中，不够时可以抛弃的对象，就无能为力了。</p><p>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种，这四种引用强度依次逐渐减弱。</p><ul><li>强引用就是程序代码中普遍存在的，类似“Object object = new Object()”这类的引用，只要强引用存在，垃圾收集器永远不会回收掉被引用的对象</li><li>软引用用来描述一些还有用，但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中，并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来试下你软引用。</li><li>弱引用也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。</li><li>虚引用也称为幽灵引用或者幻影应引用，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生成时间构成影响，也无法通过虚引用来取得一个实例对象。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚应引用。</li></ul><h4 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h4><p>在可达性分析算法中判定为不可达对象也不是马上死亡的，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将被第一次标记，然后筛选重写了finalized()方法并且finalized()方法没有被调用过的对象，将他们放置到一个叫F-Queue的队列里，并在稍后由一条虚拟机自动建立的、低调度优先级的Finalizer线程去执行他们的finalized() 方法，这里的执行是虚拟机会触发这个方法开始运行，但不一定会等他运行结束，因为它可能会死循环导致阻塞。</p><h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>很多人认为方法区是没有垃圾收集的，Java虚拟机规范中确实说过不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的性价比很低：在堆中，尤其是新生代，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而方法区的垃圾收集效率远低于此。</p><p>方法区的垃圾收集主要回收两部分内容：废弃常量和无用的类型。回收废弃常量与回收Java堆中的对象非常类似。假如当前系统中没有一个对象引用了当前常量池中的某个常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p><p> 判断一个类是否无用的条件比判断常量苛刻的多，类需要满足以下三个条件，才会被判定为“无用的类”</p><ul><li>该类的所有实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li><li>加载该类的ClassLoader已经被回收</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类方法。</li></ul><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>从如何判定对象消亡的角度出发，垃圾收集算法可划分为“引用计数式垃圾收集”和“追踪式垃圾收集”两大类，这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。</p><h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h4><p>商业虚拟机的垃圾收集器大多遵循了分代收集的理论，它建立在两个分代假说上：</p><ol><li><p><strong>弱分代假说：绝大多数对象都是朝生夕灭的。</strong></p></li><li><p><strong>强分代假说：熬过越多次垃圾收集过程的对象越难以消亡。</strong></p></li></ol><p>收集器将Java堆划分出不同的区域，然后将回收对象依据起年龄(即对象熬过垃圾收集过程的次数)分配到不同的区域之中存储。这种把它们集中到一块的方式，使虚拟机可以使用较低的频率来回收集这个区域，兼顾时间开销和内存空间的有效利用。</p><p>分代收集并不是简单划分内存区域那么容易，它存在一个问题，对象之间可能存在跨代引用。假如收集局限于新生代区域，但<strong>新生代的对象完全可能被老年代引用</strong>，那就要多遍历一遍老年代来防止存活对象被收集。这时就为分代收集理论添加第三条经验法则：</p><ol start="3"><li><strong>跨代引用假说：跨代引用相对于同代引用来说只占极少数。</strong></li></ol><p>有了这个假说，只需在新生代建立一个全局的数据结构(叫做记忆集)，这个结构把老年代划分成若干小块，标识出那一块内存存在跨代引用。此后当发生Minor GC(新生代收集)时，只有包含跨代引用的小块内存里的对象才会加入GC Root里进行扫描。</p><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>最早最基础的算法就是标记-清除算法。 算法分为“标记”和”清除”(Mark-Sweep)两个阶段,首先标记出需要回收的对象，在标记完成后统一回收。后续的收集算法都基于这种思路并对其不足进行改进。</p><p>缺点：一是执行效率不稳定，当Java堆包含大量对象并且大部分都要回收时，必须进行大量标记清除动作，导致标记和清除两个过程的执行效率随对象数量增长而降低；另一个是空间碎片化问题，标记清楚后会产生大量不连续的内存碎片，空间碎片太多可能导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集。</p><h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>标记-复制算法常被称为复制算法。为了解决效率问题，它将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这块内存用完了，就将还存活着的对象复制到另外一块上面，然后把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，也不会出现内存碎片等复杂情况，只要移动堆顶指针，按顺序分配即可，实现简单、高效。但<strong>代价是将内存缩小为了原来的1/2</strong>。</p><p>商业虚拟机都采用这种手机算法来回收新生代。IBM研究表明，新生代中98%的对象都是“朝生夕死”，所以不需要1:1的比例来划分内存，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中和存活的对象一次性复制到另外一块Survivor上，最后清理Eden和用过的Survivor空间。HotSpot默认Eden和Survivor大小比例为8:1。也就是新生代中可用空间为整个新生代的90%，只有10%会被“浪费”。当Survivor空间不足以容纳一次Minor GC后存活的对象时，就需要依赖其他内存(大多就是老年代)来进行分配担保。</p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记-复制算法在对象存活率较高时要进行较多的复制操作，效率将会降低，更关键的在于如果不想浪费一半的内存空间，就需要有额外空间进行分配担保，以应对被使用的内存中所有对象都是100%存活的极端情况，所以在老年代一般不能直接使用这种算法。</p><p>根据老年代的特点，研究出了“标记-整理”（Mark-Compact）算法，标记过程与“标记-清除”一样，但后续步骤不是进行清理，而是让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。</p><img src="https://i.loli.net/2020/05/07/IhbO6M7i48xRkaf.png" alt="20161101222342412"  / loading="lazy"><p>移动存活对象有一个缺点，就是在老年代这种每次回收都有大量对象存活区域，移动对象将会是一个极为负重的操作。但如果跟标记-清除算法完全不考虑移动和整理内存的话，将会导致空间内存碎片化问题，那只能依赖更复杂的内存分配器和访问器来解决。内存的访问是用户最频繁的操作，如果这个环节增加负担，肯定影响程序的吞吐量。</p><p>基于以上两点，从垃圾回收的停顿时间卡，不移动对象停顿时间短，但从整个程序吞吐量看，移动对象更划算。虽然不移动对象会使收集器效率提升一些，但内存分配和访问相比垃圾收集频率高，这部分耗时增加，总吞吐量肯定下降。</p><h3 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h3><h4 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h4><p>可作为GC Roots的节点主要在全局性的引用和执行上下文中，但查找过程要做到高效不容易，因为现在Java应用越来越大，方法区的大小就几百上千兆，逐个检查以这里为起源的引用要消耗不少时间。</p><p>现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，但根节点枚举始终还是要在一个能保障一致性的快照里进行，这就会导致垃圾收集过程必须停顿所有用户线程。</p><p>目前主流Java虚拟机都使用准确式垃圾收集，所以虚拟机是可以直接得到那些地方存放对象引用的。在HotSpot中，是使用一组叫OopMap的数据结构来达到这个目的。</p><h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><p>在OopMap的帮助下，HotSpot虚拟机可以快速的完成GC Roots的枚举。但可能导致引用关系变化的指令非常多，如果为每一条指令都生成OopMap，那将会需要大量的额外空间，这样GC的空间成本会变的很高。</p><p>实际上HotSpot只在特定的位置记录了这些信息，这些位置被称为安全点。安全点就是强制要求用户程序必须执行到安全点才能够暂停。</p><p>对于SafePoint，另一个问题是如何在GC发生时让所有线程都跑到安全点在停顿下来。这里有两种方案：抢先式中断和主动式中断。抢先式中断不需要线程代码主动配合，当GC发生时，首先把所有线程中断，如果发现线程中断的地方不在安全点上，就恢复线程，让他跑到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程来响应GC。<br>而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单的设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己在最近的安全点上主动中断挂起，轮询标志的地方和安全点是重合的，另外再加上创建对象和需要分配的内存的地方。</p><h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><p>使用安全点似乎已经完美解决了如何进入GC的问题，但实际情况却并不一定，安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入的GC的安全点。但程序不执行时(就是没有分分配处理器时间，比如线程处于Sleep或Block)，就无法响应虚拟机中断请求，那就必须引入安全区域解决。</p><p>安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域的任何地方开始GC都是安全的，我们可以把安全区域看做是扩展了的安全点。</p><p>当线程执行到安全区域中的代码时，首先标识自己已经进入了安全区，那样当在这段时间里，JVM要发起GC时，就不用管标识自己为安全区域状态的线程了。当线程要离开安全区域时，他要检查系统是否完成了根节点枚举，如果完成了，那线程就继续执行，否则他就必须等待，直到收到可以安全离开安全区域的信号为止。</p><h3 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h3><ol><li><p>Serial收集器：新生代的“单线程”的收集器</p></li><li><p>ParNew收集器：Serial收集器的多线程版本</p></li><li><p>Parallel Scavenge收集器：新生代收集器，也是使用复制算法的收集器，又是并行的多线程收集器。</p></li><li><p>Serial Old收集器：Serial收集器的老年代版本</p></li><li><p>Parallel Old收集器：Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法，jdk1.6开始提供</p></li><li><p>CMS收集器：一种获取最短回收停顿事件为目标的收集器。分为：初始标记，并发标记，重新标记，并发清除四个步骤，初始标记和重新标记需要Stop The World。基于“<strong>标记-清除</strong>”算法。</p></li><li><p>G1收集器：当今收集器技术发展的最前沿成果，具有特点：并行与并发，分代收集，空间整合，可预测的停顿</p><p>G1把连续的Java堆划分为多个大小相等的独立区域(Region)，每个Region都可以根据需要扮演Eden、Survivor或者老年代空间。回收标准不再是它属于哪个分代，而是那块内存存放的垃圾最多，回收收益最大，这就是Mixed GC模式。Region还有一类特殊的Humongous区域，存放大对象，默认只要超过一个Region一般的对象就是大对象。对于超过Region容量的大对象，被放在N个连续的Humongous Region中，G1大多数行为把Humongous当作老年代的一部分对待。关于跨Region引用，每个Region都有自己的记忆集，记录别的Region指向自己的指针。</p><p>G1收集分为四个步骤：</p><ul><li>初始标记：标记GC Roots能直接关联到的对象。需要停顿线程，但耗时很短</li><li>并发标记：从GC Root开始对堆中的对象进行可达性分析，递归扫描堆的对象图，找出要回收的对象，可与用户线程并发执行。</li><li>最终标记：堆用户线程做一个短暂的暂停，处理并发标记阶段用户线程对已经标记过的对象的修改。</li><li>筛选回收：负责更新Region的统计数据，对各个Region的回收价值和成本来排序，根据用户期望的停顿时间来制定回收计划，把决定回收的那部分Region的存活对象复制到空的Region，清理旧的Region。必须暂停用户线程，由多条收集线程并行完成。</li></ul></li></ol><h3 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h3><p>对象内存分配应该都是在堆上分配(实际上有可能经过即时编译后被拆散成标量类型并间接在栈上分配)。</p><h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><p>大多数情况下，对象在新生代Eden区分配。<strong>当Eden区没有足够空间分配时，虚拟机发起一次Minor GC。</strong></p><p>比如：</p><p>虚拟机配置：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</p><p>-Xms 堆内存的最小大小，默认为物理内存的1/64</p><p>-Xmx 堆内存的最大大小，默认为物理内存的1/4</p><p>-Xmn 堆内新生代的大小。通过这个值也可以得到老生代的大小：-Xmx减去-Xmn</p><p>XX:SurvivorRatio定义了新生代中Eden区域和Survivor区域的比例，默认为8，也就是Eden占8/10。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinalizeEscapeGC</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a1<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> a3<span class="token punctuation">,</span> a4<span class="token punctuation">;</span>        a1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>        a2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>        a3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>        a4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Heap</span> <span class="token class-name">PSYoungGen</span>      total <span class="token number">9216</span>K<span class="token punctuation">,</span> used <span class="token number">8192</span>K <span class="token punctuation">[</span><span class="token number">0x00000000ff600000</span><span class="token punctuation">,</span> <span class="token number">0x0000000100000000</span><span class="token punctuation">,</span> <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span>  eden space <span class="token number">8192</span>K<span class="token punctuation">,</span> <span class="token number">100</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff600000</span><span class="token punctuation">,</span><span class="token number">0x00000000ffe00000</span><span class="token punctuation">,</span><span class="token number">0x00000000ffe00000</span><span class="token punctuation">)</span>  from space <span class="token number">1024</span>K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000fff00000</span><span class="token punctuation">,</span><span class="token number">0x00000000fff00000</span><span class="token punctuation">,</span><span class="token number">0x0000000100000000</span><span class="token punctuation">)</span>  <span class="token keyword">to</span>   <span class="token namespace">space</span> <span class="token number">1024</span>K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ffe00000</span><span class="token punctuation">,</span><span class="token number">0x00000000ffe00000</span><span class="token punctuation">,</span><span class="token number">0x00000000fff00000</span><span class="token punctuation">)</span> <span class="token class-name">ParOldGen</span>       total <span class="token number">10240</span>K<span class="token punctuation">,</span> used <span class="token number">4096</span>K <span class="token punctuation">[</span><span class="token number">0x00000000fec00000</span><span class="token punctuation">,</span> <span class="token number">0x00000000ff600000</span><span class="token punctuation">,</span> <span class="token number">0x00000000ff600000</span><span class="token punctuation">)</span>  object space <span class="token number">10240</span>K<span class="token punctuation">,</span> <span class="token number">40</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000fec00000</span><span class="token punctuation">,</span><span class="token number">0x00000000ff000010</span><span class="token punctuation">,</span><span class="token number">0x00000000ff600000</span><span class="token punctuation">)</span> <span class="token class-name">Metaspace</span>       used <span class="token number">3137</span>K<span class="token punctuation">,</span> capacity <span class="token number">4496</span>K<span class="token punctuation">,</span> committed <span class="token number">4864</span>K<span class="token punctuation">,</span> reserved <span class="token number">1056768</span>K  <span class="token keyword">class</span> space    used <span class="token number">343</span>K<span class="token punctuation">,</span> capacity <span class="token number">388</span>K<span class="token punctuation">,</span> committed <span class="token number">512</span>K<span class="token punctuation">,</span> reserved <span class="token number">1048576</span>K</code></pre><p>可以看到前面3个大小为2MB的对象分配在Eden区内，但在分配4M大小的对象时，Eden区剩余空间不足，所以发生Minor GC，但没有对象能够回收，所以通过分配担保机制把4M对象分配到老年代去。(这里eden占用100%因为本来就26%被虚拟机占用)。</p><h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>大对象堆虚拟机的内存分配来说就是一个不折不扣的坏消息，尤其是一群朝生夕灭的短命大对象，我们写程序应该避免。因为在分配空间时，大对象容易导致还有不少内存空间时就触发垃圾收集，而且复制对象开销大。</p><p>HotSpot虚拟机的<code>-XX:PretenureSizeThreshold</code>参数可以指定大于该设置值的对象直接分配在老年代，防止在Eden区和两个Survivor区来回复制。但PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效。</p><h4 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h4><p>HotSpot虚拟机多数收集器都采用了分代收集来管理内存，为了决定对象放在新生代还是老年代，虚拟机给每个对象定义了一个对象年龄(Age)计数器，存储在对象头中。对象在Eden区诞生，第一次Minor GC后仍然存活，并能被Survivor容纳，则移动到Survivor中，并把年龄设为1，对象在Survivor中每熬过一次，年龄加一，当年龄到一定程度(默认15)，就会晋升到老年代中。==这个实验要使用-XX:+UseSerialGC，jdk8默认的不符合==</p><p>对象晋升老年代的阈值，可以通过-XX:MaxTenuringThreshold设置。</p><h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>为了更好的适应不同程序的内存情况，HotSpot虚拟机并不是要求对象年龄必须达到-XX:MaxTenuringThreshold才能晋升老年代，而是如果Survivor空间中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以进入老年代。</p><h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>在发生Minor GC前，虚拟机必须先检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果大于，可以确保Minor GC是安全的。不成立则查看-XX:HandlePromotionFailure参数的设置值是否允许担保失败，如果允许，那就会检查老年代的最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试一次Minor GC，如果小于，或者-XX:HandlePromotionFailure设置不允许冒险，那就改为进行一次Full GC。</p><p>但jdk6之后，虚拟机已经不管-XX:HandlePromotionFailure的设置了，规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC，否则Full GC。 </p><h3 id="HotSpot的serial收集器触发GC条件"><a href="#HotSpot的serial收集器触发GC条件" class="headerlink" title="HotSpot的serial收集器触发GC条件"></a>HotSpot的serial收集器触发GC条件</h3><p>最简单的分代式GC策略，按HotSpot VM的serial GC的实现来看，触发条件是：</p><ul><li>young GC：当young gen中的eden区分配满的时候触发。注意young GC中有部分存活对象会晋升到old gen，所以young GC后old gen的占用量通常会有所升高。</li><li>full GC：当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，则不会触发young GC而是转为触发full GC（因为HotSpot VM的GC里，除了CMS的concurrent collection之外，其它能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先触发一次单独的young GC）；或者System.gc()、heap dump带GC，默认也是触发full GC。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深入理解Java虚拟机读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第6章 类文件结构</title>
      <link href="posts/c431302c/"/>
      <url>posts/c431302c/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="无关性的基石"><a href="#无关性的基石" class="headerlink" title="无关性的基石"></a>无关性的基石</h3><p>各种不同平台的Java虚拟机，以及所有平台都统一支持的程序存储格式——字节码是构成平台无关性的基石。</p><p>实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不和包括 Java在内的任何语言绑定，它只与 “Class文件” 这种特定的二进制文件格式所关联，Class文件中包括了Java虚拟机指令集、符号表以及若干其他辅助信息。基于安全方面的考虑，Java虚拟机规范要求在Class文件中使用许多强制性的语法和结构化约束，但任一门功能性语言都可以表示为一个能被 Java虚拟机所接受的有效的Class文件。</p><p>Java语言中的各种语法、关键字、常量变量和运算符号的语义最终都会由多条字节码指令组合表达。</p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/SkqgRdEmITLXKi4.png" alt="image-20200514144716321" style="zoom:67%;" / loading="lazy"><h3 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h3><p>1、Java技术能够一直保持良好的向后兼容性，Class文件结构的稳定功不可没。</p><p>2、Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。</p><p>3、Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”。</p><ol><li>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节。无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li><li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表，它由如下所示的数据项构成：<img src="https://gitee.com/gzj1999/blogImg/raw/master/img/f76n1ACqxQolXcR.png" alt="image-20200514145246191" style="zoom: 80%;" / loading="lazy"></li></ol><p>4、无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的<strong>容量计数器</strong>加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的<strong>集合</strong>。</p><p>5、Class的结构不像XML等描述语言，由于它没有任何分隔符号，所以所有的数据项，无论是顺序还是数量，甚至于数据存储的字节序（Byte Ordering，Class文件中字节序为Big-Endian）这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。</p><h4 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h4><p>1、每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接受的Class文件</strong>。</p><p>2、使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。Class文件的魔数的获得很有“浪漫气息”，值为：0x<strong>CAFEBABE</strong>（咖啡宝贝）。</p><p>3、紧接着魔数的4个字节存储的是Class文件的<strong>版本号</strong>：其中第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。</p><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>1、紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时它还是在Class文件中第一个出现的表类型数据项目。</p><p>2、由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的数据，代表常量池容量计数值（constant_pool_count）。</p><p>3、与Java中语言习惯不一样的是，<strong>这个容量计数是从1而不是0开始的</strong>。这样做的目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达 “<strong>不引用任何一个常量池项目</strong>” 的含义，这种情况就可以把索引值置为0来表示。</p><p>4、Class文件结构中<strong>只有常量池的容量计数是从1开始</strong>，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始的。</p><p>5、常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。</p><ol><li>字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。</li><li>符号引用则属于编译原理方面的概念，包括了下面三类常量：<ol><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li></ol></li></ol><p>6、Java代码在进行 Javac 编译的时候，在虚拟机加载Class文件的时候进行动态连接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p><p>7、常量池每个常量都是一个表，截至JDK13，常量表有17种不同类型的常量。</p><center>常量池的项目类型</center><table><thead><tr><th align="center">类型</th><th align="center">标志</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">CONSTANT_Utf8_info</td><td align="center">1</td><td align="center">UTF-8编码的字符串</td></tr><tr><td align="center">CONSTANT_Integer_info</td><td align="center">3</td><td align="center">整形字面量</td></tr><tr><td align="center">CONSTANT_Integer_info</td><td align="center">4</td><td align="center">浮点型字面量</td></tr><tr><td align="center">CONSTANT_Long_info</td><td align="center">5</td><td align="center">长整型字面量</td></tr><tr><td align="center">CONSTANT_Double_info</td><td align="center">6</td><td align="center">双精度浮点型字面量</td></tr><tr><td align="center">CONSTANT_Class_info</td><td align="center">7</td><td align="center">类或接口的符号引用</td></tr><tr><td align="center">CONSTANT_String_info</td><td align="center">8</td><td align="center">字符串类型字面量</td></tr><tr><td align="center">CONSTANT_Fieldref_info</td><td align="center">9</td><td align="center">字段的符号引用</td></tr><tr><td align="center">CONSTANT_Methodref_info</td><td align="center">10</td><td align="center">类中方法的符号引用</td></tr><tr><td align="center">CONSTANT_InterfaceMethodref_info</td><td align="center">11</td><td align="center">接口中方法的符号引用</td></tr><tr><td align="center">CONSTANT_NameAndType_info</td><td align="center">12</td><td align="center">字段或方法的部分符号引用</td></tr><tr><td align="center">CONSTANT_MethodHandle_info</td><td align="center">15</td><td align="center">表示方法句柄</td></tr><tr><td align="center">CONSTANT_MethodType_info</td><td align="center">16</td><td align="center">表示方法类型</td></tr><tr><td align="center">CONSTANT_Dynamc_info</td><td align="center">17</td><td align="center">表示一个动态计算常量</td></tr><tr><td align="center">CONSTANT_InvoleDynamic_info</td><td align="center">18</td><td align="center">表示一个动态方法调用点</td></tr><tr><td align="center">CONSTANT_Module_info</td><td align="center">19</td><td align="center">表示一个模块</td></tr><tr><td align="center">CONSTANT_Package_info</td><td align="center">20</td><td align="center">表示一个模块中开发或导出的包</td></tr></tbody></table><p>8、实例分析</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/piK8FC5j3TGWShu.png" alt="image-20200514152333270" loading="lazy"></p><ol><li>如上图所示：Class文件的魔数值为：0xCAFEBABE。</li><li>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号(Minor Version，图中为0x0000)，第7和第8个字节是主版本号(Major Version，图中为0x0031)。</li><li>常量池容量 (偏移地址：0x00000008) 为十六进制数 0x0024，即十进制的36，这就代表常量池中有35项常量，索引值范围为1～35。</li><li>常量池的第一项常量的标志位 (偏移地址：0x0000000a) 是 0x07，表示这个常量属于CONSTANT_Class_info类型。</li><li>CONSTANT_Class_info类型的 name_index 值 (偏移地址：0x0000000b) 为0x0002，也即是指向了常量池中的第二项常量。 它的标志位 (地址：0x0000000d) 是0x01，表示这个常量属于CONSTANT_Utf8_info类型。</li><li>CONSTANT_Utf8_info类型的 length 值 (偏移地址：0x0000000e) 为0x000F，也就是长15字节，往后15字节正好都在1～127的ASCII码范围以内，内容为 jvm/SimpleClass。</li><li>剩下的常量 (从偏移地址 0x0000001f 开始) 可以通过类似的方法计算出来。</li></ol><h4 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h4><p>在常量池结束之后，紧接着的两个字节代表访问标志（access_fags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/asLx7fBTFgpwHQm.png" alt="image-20200514152704695" loading="lazy"></p><p>access_flags中一共有16个标志位可以使用，当前只定义了其中8个，没有使用到的标志位要求<strong>一律为0</strong>。在计算时将所有符合要求的标志位取出，然后做<strong>或</strong>得到最终结果。</p><h4 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h4><p>1、类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是<strong>一组 u2 类型的数据的集合</strong>，Class文件中由这三项数据来确定这个类的<strong>继承关系</strong>。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。</p><p>2、由于 Java语言不允许多重继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 Java类都有父类，<strong>因此除了 java.lang.Object外，所有 Java类的父类索都不为0</strong>。</p><p>3、接口索引集合就用来描述这个类<strong>实现了哪些接口</strong>，这些被实现的接口将按 implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。</p><h4 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h4><p>1、字段表（field_info）用于描述接口或者类中声明的变量。<strong>字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</strong></p><p>2、一个字段可以包含的信息有：</p><ul><li>字段的作用域（public、private、protected修饰符）</li><li>是实例变量还是类变量（static修饰符）</li><li>可变性（final）</li><li>并发可见性（volatile修饰符，是否强制从主内存读写）</li><li>可否被序列化（transient修饰符）</li><li>字段数据类型（基本类型、对象、数组）</li><li>字段名称</li></ul><p>3、上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</p><p>4、描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符 L 加对象的全限定名来表示。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/RmIoaF7j4ZHi8pG.png" alt="image-20200514155954253" loading="lazy"></p><p>5、对于数组类型，<strong>每一维度</strong>将使用一个前置的 <code>[</code> 字符来描述，如一个定义为 <code>java.lang.String[][]</code>类型的二维数组，将被记录为：<code>[Ljava/lang/String</code>，一个整型数组 <code>int[]</code> 将被记录为 <code>[I</code> 。</p><p>6、用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号 () 之内。<br>如方法 void inc () 的描述符为 ()V<br>方法<code>java.lang.String.toString ()</code>的描述符为<code> ()Ljava/lang/String</code><br>方法<code>int indexOf (char[] source,int sourceOffset,int sourceCount,char[] target,int targetOffset,int targetCount,int fromlndex)</code>的描述符为<code> ([CII[CIII)I</code>。</p><p>7、字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本 Java 代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。<br>8、另外，在 Java 语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。</p><h4 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h4><p>1、方法的定义可以通过访问标志、名称索引、描述符索引表达清楚，但方法里面的代码去哪里了？方法里的 Java代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为 “Code” 的属性里面。</p><p>2、与字段表集合相对应的，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器<strong>自动添加</strong>的方法，最典型的便是类构造器 <code>&lt;clinit&gt;</code> 方法和实例构造器 <code>&lt;inits&gt;</code> 方法。</p><p>3、在 Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名。</p><ul><li>特征签名就是一个方法中各个参数在常量池的字段符号引用的集合。</li><li>Java 代码的方法特征签名只包括了方法名称、参数顺序及参数类型，即不包含返回值，因此 Java 语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。</li><li>但是在 Class 文件格式中，特征签名的范围更大一些，还包括方法返回值以及受查异常表，只要描述符不是完全一致的两个方法也可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。</li></ul><h4 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h4><p>1、属性表（attribute_info）在前面已经出现过数次，在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。</p><p>2、与 Class 文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松了一些，不再要求各个属性表具有严格顺序，并且只要不与已有属性各重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p><h5 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h5><p>Java程序方法体里面的代码经过javac编译器处理后，最终变成字节码指令存储在Code属性内。并非所有的方法表都必须存在这个属性，譬如<strong>接口或者抽象类</strong>中的方法就不存在Code属性。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/hZa1LYVOTcpMIlB.png" alt="image-20200514165553782" loading="lazy"></p><p>1、attribute_name_index是指向CONSTANT_Utf8_info型常量的索引，此常量值固定为“Code”。attribute_length指示了属性值的长度，属性值长度固定为整个属性表长度减去6字节。</p><p>2、max_stack表示操作数栈深度的最大值。虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度。</p><p>3、max_locals表示局部变量表所需的内存空间。单位是变量槽(Slot)，变量槽是虚拟机为局部变量分配内存所使用的最小单位。</p><ul><li>对于byte、char、float、int、short、boolean 和 returnAddress 等长度不超过32位的数据类型，每个局部变量占用 1 个Slot，而double 和 long这两种64位的数据类型则需要两个Slot来存放。</li><li>方法参数（包括实例方法中的隐藏参数 “this”）、显式异常处理器的参数（Exception Handler Parameter，就是try-catch语句中catch块所定义的异常）、方法体中定义的局部变量都需要使用局部变量表来存放。</li><li>并不是在方法中用到了多少个局部变量，就把这些局部变量所占 Slot 之和作为max_locals的值，原因是局部变量表中的 Slot 可以重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的Slot可以被其他局部变量所使用，Javac 编译器会根据变量的作用域来分配 Slot 给各个变量使用，然后计算出max_locals的大小。</li></ul><p>4、code_length 和 code 用来存储 Java 源程序编译后生成的字节码指令。code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。既然叫字节码指令，那么每个指令就是一个u1类型的单字节，当虚拟机读取到 code 中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及参数应当如何理解。</p><p>5、一个u1数据类型的取值范围为 0x000xFF，对应十进制的0255，也就是一共可以表达256条指令。</p><p>虽然 code_length 是一个 u4 类型的长度值，理论上最大值可以达到 2^32 - 1，但是虚拟机规范中明确限制了一个方法不允许超过 65535 条字节码指令，即它实际只使用了 u2 的长度，如果超过这个限制，Javac 编译器也会拒绝编译。</p><p>6、在字节码指令之后的是这个方法的显式异常处理表集合，异常表对于Code属性来说并不是必须存在的，它的格式如下。其中字段的含义为：如果当字节码在第 start_pc 行到第 end_pe 行之间（不含第 end_pc 行）出现了类型为 catch_type 或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第 handler_pc 行继续处理。当 catch_type 的值为0时，代表任意异常情况都需要转向到 handler_pc 处进行处理。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/r1RtD4NWcPOLxpd.png" alt="image-20200514173110412" loading="lazy"></p><h5 id="Exceptions属性"><a href="#Exceptions属性" class="headerlink" title="Exceptions属性"></a>Exceptions属性</h5><p>Exceptions 属性的作用是列举出方法中可能抛出的<strong>受查异常</strong>（Checked Excepitons），也就是方法描述时在 <strong>throws</strong> 关键字后面列举的异常。</p><p><img src="https://gitee.com/gzj1999/blogImg/raw/master/img/hQq7jwcsWV8Dxy4.png" alt="image-20200514180539587" loading="lazy"></p><p>Exceptions 属性中的 number_of_exceptions 项表示方法可能抛出 number_of_exceptions 种受查异常，每一种受查异常使用一个 exception_index_table 项表示，exception_index_table 是一个指向常量池中CONSTANT_Class_info 型常量的索引，代表了该受查异常的类型。</p><h3 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h3><p>Java虚拟机的指令由<strong>一个字节长度</strong>的、代表着某种特定操作含义的数字（称为<strong>操作码</strong>，Opcode）以及跟随其后的<strong>零至多个代表此操作所需参数</strong>（称为<strong>操作数</strong>，Operands）而构成。由于 Java 虚拟机采用<strong>面向操作数栈而不是寄存器</strong>的架构，所以大多数的指令都不包含操作数，只有一个操作码。</p><p>字节码指令集是一种具有鲜明特点、优劣势都很突出的指令集架构，由于限制了 Java 虚拟机操作码的长度为<strong>一个字节</strong>（即0~255），这意味着指令集的操作码总数不可能超过<strong>256条</strong>。</p><h4 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h4><p>在 Java 虚拟机的指令集中，大多数的指令都包含了<strong>其操作所对应的数据类型信息</strong>。比如iload指令用于从局部变量表中加载int型数据到操作数栈中。</p><p>Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它，换句话说，指令集将会故意被设计成非完全独立的（Java虚拟机规范中把这种特性称为 “Not Orthogonal”，即并非每种数据类型和每一种操作都有对应的指令）。有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。</p><p>编译器在编译期或运行期将byte和short类型的数据带符号扩展为相应的int类型数据，将boolean和char类型数据零位扩展为相应的int类型数据。对于大多数boolean、byte、short和char类型数据操作时，实际上都是使用相应的对int类型作为运算类型来进行的。</p><h4 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h4><p>加载和存储指令用于将数据在栈帧中的<strong>局部变量表和操作数栈之间来回传输</strong>，这类指令包括如下内容：</p><ul><li>将一个局部变量加载到操作栈：iload、iload_&lt;n&gt;…</li><li>将一个数值从操作数栈存储到局部变量表：istore、istore_&lt;n&gt;…</li><li>将一个常量加载到操作数栈：bipush、sipush、ldc…</li><li>扩充局部变量表的访问索引的指令：wide</li></ul><p>iload_&lt;n&gt;这类尖括号结尾的指令助记符实际上代表了一组指令：iload_0, iload_1, iload_2, iload_3这几条。</p><h4 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h4><p>运算或算术指令用于<strong>对两个操作数栈上的值进行某种特定运算</strong>，并把结果重新存入到操作栈顶。</p><p>大体上算术指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令，整数和浮点数在溢出和被零除的时候也有不同的表现，无论是哪种算术指令，都使用 Java 虚拟机的数据类型。由于没有直接支持byte、short、char和boolean类型的算术指令，对于这类数据的运算，应使用操作 int 类型的指令代替。</p><h4 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h4><p>类型转换指令可以<strong>将两种不同的数值类型进行相互转换</strong>，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p><p>Java虚拟机直接支持（即转换时无需显式的转换指令）以下数值类型的宽化类型转换（Widening Numeric Conversions，即小范围类型向大范围类型的安全转换）：</p><ul><li>int类型到long、float或者double类型。</li><li>long类型到float、double类型。</li><li>float 类型到double类型。</li></ul><h4 id="对象创建与访问指令"><a href="#对象创建与访问指令" class="headerlink" title="对象创建与访问指令"></a>对象创建与访问指令</h4><p>虽然类实例和数组都是对象，但 Java 虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令如下。</p><ul><li>创建类实例的指令：new。</li><li>创建数组的指令：newarray、anewarray、multianewarray。</li><li>访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic。</li><li>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload。</li><li>将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore。</li><li>取数组长度的指令：arraylength。</li><li>检查类实例类型的指令：instanceof、checkcast。</li></ul><h4 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h4><p>如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：</p><ul><li>将操作数栈的栈顶一个或两个元素出栈：pop、pop2。</li><li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2。</li><li>将栈最顶端的两个数值互换：swap。</li></ul><h4 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h4><p>控制转移指令可以让 Java 虚拟机有条件或无条件地<strong>从指定的位置指令而不是控制转移指令的下一条指令继续执行程序</strong>，从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改PC寄存器的值。</p><p>对于boolean类型、byte类型、char 类型和short类型的条件分支比较操作，都是使用 int 类型的比较指令来完成，而对于long类型、float类型和double类型的条件分支比较操作，则会先执行相应类型的比较运算指令（dcmpg、dcmpl、fcmpg、fcmpl、1cmp），运算指令会返回一个整型值到操作数栈中，随后再执行 int 类型的条件分支比较操作来完成整个分支跳转。由于各种类型的比较最终都会转化为 int 类型的比较操作，int类型比较是否方便完善就显得尤为重要，所以Java虚拟机提供的int类型的条件分支指令是最为丰富和强大的。</p><h4 id="方法调用和返回指令"><a href="#方法调用和返回指令" class="headerlink" title="方法调用和返回指令"></a>方法调用和返回指令</h4><p>方法调用仅列举以下5条用于方法调用的指令：</p><ul><li>invokevirtual 指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。</li><li>invokeinterface 指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。</li><li>invokespecial 指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。</li><li>invokestatic 指令用于调用类方法（static方法）。</li><li>invokedynamic 指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法<br>前面4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li></ul><p>方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法以及类和接口的类初始化方法使用。</p><h4 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h4><p>在 Java 程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，除了用 throw 语句显式抛出异常情况之外，Java虚拟机规范还规定了许多运行时异常会在其他 Java 虚拟机指令检测到异常状况时自动抛出。例如，当除数为零时，虚拟机会在idiv或ldiv 指令中抛出ArithmeticException异常。而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的，而是采用异常表来完成的。</p><h4 id="同步指令"><a href="#同步指令" class="headerlink" title="同步指令"></a>同步指令</h4><p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor）来支持的。<br>方法级的同步是隐式的，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否声明为同步方法。当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。<br>同步一段指令集序列通常是由 Java语言中的 synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter 和 monitorexit 两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要 Javac 编译器与 Java 虚拟机两者共同协作支持。</p><h3 id="公有设计，私有实现"><a href="#公有设计，私有实现" class="headerlink" title="公有设计，私有实现"></a>公有设计，私有实现</h3><p>Java虚拟机规范描绘了 Java 虚拟机应有的共同程序存储格式：<strong>Class文件格式以及字节码指令集</strong>。这些内容与硬件、操作系统及具体的 Java 虚拟机实现之间是完全独立的，虚拟机实现者可能更愿意把它们看做是程序在各种 Java 平台实现之间互相安全地交互的手段。</p><p>一个优秀的虚拟机实现，在满足虚拟机规范的约束下对具体实现做出修改和优化也是完全可行的，并且虚拱机规范中明确鼓励实现者这样做。只要优化后Class文件依然可以被正确读取，并且包含在其中的语义能得到完整的保持，那实现者就可以选择任何方式去实现这些语义。</p><p>虚拟机实现者可以使用这种伸缩性来让 Java 虚拟机获得更高的性能、更低的内存消耗或者更好的可移植性，选择哪种特性取决于 Java 虚拟机实现的目标和关注点是什么。虚拟机实现的方式主要有以下两种：</p><ul><li>将输入的 Java 虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集。</li><li>将输入的 Java 虚拟机代码在加载或执行时翻译成宿主CPU的本地指令集（即 JIT-代码生成技术）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深入理解Java虚拟机读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2章 Java内存区域与内存溢出异常</title>
      <link href="posts/30994d61/"/>
      <url>posts/30994d61/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。</p><img src="https://i.loli.net/2020/05/05/WhxvawGiBzqLAMb.png" alt="image-20200505142316196" style="zoom: 50%;" / loading="lazy"><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。它在线程隔离的数据区，属于线程私有的内存。</p><p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地方法，这个计数器值应为空(Undifined)。</p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>Java虚拟机栈是线程私有的，它的生命周期和线程相同。</p><img src="https://i.loli.net/2020/05/14/myXArgNB1WKhE6a.png" alt="image-20200514224901767" style="zoom: 67%;" / loading="lazy"><p>每个方法被执行的时候，Java虚拟机都会同步的创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。</p><p>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型、对象引用类型和returnAddress类型(指向一条字节码指令的地址)。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的。</p><p>如果线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverFlowError异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够内存时抛出OutOfMemoryError异常。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈与Java虚拟机栈作用类似，区别是虚拟机栈为虚拟机执行Java方法服务，本地方法栈则是为虚拟机用到的本地方法服务。</p><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的是存放对象实例。</p><p>Java堆是垃圾收集器管理的内存区域，可以处于物理上不连续的内存空间中，但在逻辑上被视为连续的。</p><p>Java堆既可以被实现成固定大小的，也可以是扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的。如果Java堆没有内存完成实例分配，并且堆无法扩展时，会抛出OutOfMemoryError异常。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p>在jdk8以前，很多人把方法区称为永久代，但两者不同，当初是hotspot虚拟机设计团队选择使用永久代来实现方法区，这样就可以让hotspot的垃圾收集器可以像管理Java堆一样管理方法区。但这样设计让Java应用更容易遇到内存溢出问题(永久代有-XX:MaxPermSize上限)，在jdk8时，完全废弃了永久代的概念，改为在本地内存实现的元空间。</p><p>如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池具有动态性，不要求常量一定只有编译期才产生，比如String类的intern方法。</p><p>常量池无法申请到内存时会抛出OutOfMemory异常。</p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存（Direct Memory）就是Java堆外内存。直接内存不是虚拟机运行时数据区的一部分，但这部分内存经常被使用，也有可能导致OutOfMemory异常。</p><p>在jdk1.4中新加入了NIO类，引入了基于通道和缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样可以在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>直接内存会受到本机总内存大小以及处理器寻址空间的限制，不当处理回出现OutOfMemory异常。</p><h3 id="HotSpot虚拟机的对象"><a href="#HotSpot虚拟机的对象" class="headerlink" title="HotSpot虚拟机的对象"></a>HotSpot虚拟机的对象</h3><p>关于HotSpot虚拟机在Java堆中对象(不包括数组和Class对象)分配、布局和访问的全过程。</p><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><p>在虚拟机遇见new指令时，先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个引用代表的类是否被加载、解析和初始化过，没有，那就先执行类加载。</p><p>类加载检查通过后，接下来虚拟机为对象分配内存。如果Java堆中内存是绝对规整的，就是使用过的内存在一边，没用过的在另一边，那分配内存就是把指针向空闲方移动一段，称位‘指针碰撞’。如果不规整，那虚拟机就维护一个列表，记录内存是否可用，这种方式是‘空闲列表‘。一般Java堆采用有空间压缩整理能力的GC时可以用指针碰撞。</p><p>对象分配很频繁，只是指针碰撞的话，它不是线程安全的。目前有两种方式解决：一是采用CAS配上失败重试的方式保证更新操作的原子性；另一种是把内存分配的动作按线程划分在不同空间进行，即每个线程在Java堆先分配一小块内存，称为本地线程分配缓冲(TLAB)，如果使用TLAB的话，可以在TLAB分配时顺便进行内存初始化，否则只能在分配完毕后初始化为零值。然后对对象头进行设置，这样从虚拟机角度看，一个对象就产生了。但从程序员角度看，构造函数还没执行，然后执行构造函数。</p><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>在HotSpot虚拟机里，对象在堆中的存储可以分为三部分：对象头、实例数据和对齐填充。</p><p>对象头主要有两类信息：</p><ul><li><p>一类是存储对象自身的数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等，称为<code>Mark Word</code>。考虑虚拟机空间效率，Mark Word被设计成有动态定义的数据结构。</p></li><li><p>另一类是类型指针，即对象指向它的类型元数据的指针，虚拟机通过这个指针确定对象是那个类的实例。但查找对象的元数据信息并不一定经过对象本身。如果对象是一个Java数组，对象头还有一块用于记录数组长度的数据。</p></li></ul><p>实例数据部分是对象真正存储的有效信息，即我们在程序代码里面定义的各种类型的字段内容，无论父类继承还是子类中定义的都记录下来。</p><p>对齐填充就是起到占位符的作用。虚拟机自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是对象大小是8字节的整数倍。实例数据没有填充够8字节的整数倍的话，就要对齐填充来补全。</p><h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>Java程序通过栈上的reference数据来操作堆上的具体对象。目前主流的访问方式主要有句柄和直接指针两种。</p><p>句柄：Java堆会划分出一块内存用来作为句柄池，reference中存储的就是对象的句柄地址，句柄包含对象实例数据和类型数据各自具体的地址信息。</p><p>优点是reference存储的是稳定的句柄地址，对象移动时只会改变句柄的实例数据指针，reference本身不修改。</p><p>缺点是增加了一次指针定位的时间开销。</p><p><img src="https://i.loli.net/2020/05/06/nhRbjHZoq5azAsO.png" alt="3130736-b43450a00c0a9866" loading="lazy"></p><p>直接指针：reference存储的就是对象地址，只访问对象本身，不需要多一次间接访问的开销。速度更快</p><p><img src="https://i.loli.net/2020/05/06/ySxwzpvH27rZt9o.png" alt="3130736-38e0a509ec16d1b0" loading="lazy"></p><p>HotSpot虚拟机主要是使用直接指针来进行对象访问。</p><h2 id="一个有趣的实验"><a href="#一个有趣的实验" class="headerlink" title="一个有趣的实验"></a>一个有趣的实验</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"计算机"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"软件"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"ja"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"va"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>这段代码在jdk6运行会得到两个false，在jdk7中运行会得到一个true和一个false。</p><p>原因是在jdk6中，intern方法会把首次遇到的字符串实例复制到永久代的字符串常量池中存储，返回的也是永久代的字符串实例的引用，但由于stringBuilder创建的在Java堆上，所以false。</p><p>而JDK 7（以及部分其他虚拟机，例如JRockit）的intern()方法实现就不需要再拷贝字符串的实例到永久代了，<strong>既然字符串常量池已经移到Java堆中，那只需要在常量池里记录一下首次出现的实例引用即可，因此intern()返回的引用和由StringBuilder创建的那个字符串实例就是同一个</strong>。而对str2比较返回false，这是因为“java”这个字符串在执行String-Builder.toString()之前就已经出现过了，字符串常量池中已经有它的引用，不符合intern()方法要求“首次遇到”的原则，“计算机软件”这个字符串则是首次出现的，因此结果返回true。</p><p>Java这个字符串在执行main时已经加载到了字符串常量池中，所以是false。</p><p><strong>intern作用：intern()的本质是改变字符串引用的方向,让对等价字符串对象的引用都指向同一个字符串对象,使得多余的等价字符串对象可以被回收，防止在堆中new出多个相同的字符串都有引用无法被回收的情况。</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"计s机软件"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//String s1 = new String("计s机软件");等价于String s = "计s机软件"; String s1 = new String(s);</span><span class="token comment">//所以常量池已经有"计s机软件"，s1就会在堆里创建一个对象，而s1.intern()是之前加载到常量池的对象，所以是false</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//f</span><span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"ja"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"va"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这个是因为java字符串在jvm加载时就已经进入常量池，s2是新创建在堆里的对象，所以不等</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//f</span><span class="token class-name">String</span> s3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"计算机"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"软件"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//字符串常量池已经移到Java堆中，那只需要在常量池里记录一下首次出现的实例引用</span><span class="token comment">//s3字符串是首次出现的，s3.intern实际上还是s3的实例引用，所以相等。</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> s3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//t</span><span class="token class-name">String</span> s5 <span class="token operator">=</span> <span class="token string">"计算机软件"</span><span class="token punctuation">;</span><span class="token comment">//因为字符串常量池记录的是首次出现在堆里的字符串的实例引用，所以s3是堆的实例引用，s5是常量池里记录的堆的实例引用，所以相等。</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s5 <span class="token operator">==</span> s3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//t</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 深入理解Java虚拟机读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
